
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>파이썬 3.8의 새로운 기능 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파이썬 3.7의 새로운 기능" href="3.7.html" />
    <link rel="prev" title="파이썬 3.9의 새로운 기능" href="3.9.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/whatsnew/3.8.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="3.7.html" title="파이썬 3.7의 새로운 기능"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="3.9.html" title="파이썬 3.9의 새로운 기능"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬의 새로운 기능</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-3-8">
<h1>파이썬 3.8의 새로운 기능<a class="headerlink" href="#what-s-new-in-python-3-8" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">편집자</dt>
<dd class="field-odd"><p>Raymond Hettinger</p>
</dd>
</dl>
<p>이 기사에서는 파이썬 3.7과 비교하여 3.8의 새로운 기능에 관해 설명합니다. 자세한 내용은 <a class="reference internal" href="changelog.html#changelog"><span class="std std-ref">changelog</span></a>를 참조하세요.</p>
<div class="section" id="summary-release-highlights">
<h2>요약 -- 배포 주요 사항<a class="headerlink" href="#summary-release-highlights" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="new-features">
<h2>새로운 기능<a class="headerlink" href="#new-features" title="제목 주소">¶</a></h2>
<div class="section" id="assignment-expressions">
<h3>대입 표현식<a class="headerlink" href="#assignment-expressions" title="제목 주소">¶</a></h3>
<p>더 큰 표현식의 일부로 변수에 값을 대입하는 새로운 문법 <code class="docutils literal notranslate"><span class="pre">:=</span></code> 이 있습니다. <a class="reference external" href="https://en.wikipedia.org/wiki/Walrus#/media/File:Pacific_Walrus_-_Bull_(8247646168).jpg">바다코끼리의 눈과 엄니</a>를 닮아서 &quot;바다코끼리 연산자(the walrus operator)&quot;라고 친근하게 알려져 있습니다.</p>
<p>이 예에서, 대입 표현식은 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>을 두 번 호출하지 않도록 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;List is too long (</span><span class="si">{n}</span><span class="s2"> elements, expected &lt;= 10)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>정규식 일치 중에도 비슷한 이점이 있습니다. 일치 객체가 두 번 필요합니다, 일치하는지 검사할 때 한 번, 서브 그룹을 추출할 때 한 번:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">discount</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mo</span> <span class="p">:</span><span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)</span><span class="si">% d</span><span class="s1">iscount&#39;</span><span class="p">,</span> <span class="n">advertisement</span><span class="p">)):</span>
    <span class="n">discount</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mf">100.0</span>
</pre></div>
</div>
<p>이 연산자는 루프 종료를 검사하기 위해 값을 계산한 다음 루프의 바디에서 그 값이 다시 필요한 while 루프에도 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 고정 길이 블록을 루핑합니다</span>
<span class="k">while</span> <span class="p">(</span><span class="n">block</span> <span class="p">:</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">256</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
<p>필터링 조건에서 계산된 값이 표현식 바디에도 필요한 리스트 컴프리헨션에서 또 다른 사용 사례가 생깁니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">clean_name</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">clean_name</span> <span class="p">:</span><span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFC&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="ow">in</span> <span class="n">allowed_names</span><span class="p">]</span>
</pre></div>
</div>
<p>복잡성을 줄이고 가독성을 개선하는 명확한 사례로 바다코끼리 연산자 사용을 제한하십시오.</p>
<p>자세한 설명은 <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0572"><strong>PEP 572</strong></a>를 참조하십시오.</p>
<p>(Contributed by Emily Morehouse in <a class="reference external" href="https://bugs.python.org/issue35224">bpo-35224</a>.)</p>
</div>
<div class="section" id="positional-only-parameters">
<h3>위치 전용 매개 변수<a class="headerlink" href="#positional-only-parameters" title="제목 주소">¶</a></h3>
<p>일부 함수 매개 변수를 위치적으로 지정해야만 하고 키워드 인자로 사용할 수 없도록 지시하는 새로운 함수 매개 변수 문법 <code class="docutils literal notranslate"><span class="pre">/</span></code> 이 있습니다. 이것은 Larry Hastings의 <a class="reference external" href="../howto/clinic.html">Argument Clinic</a> 도구로 어노테이트된 C 함수들에 대해 <code class="docutils literal notranslate"><span class="pre">help()</span></code>가 보여주는 것과 같은 표기법입니다.</p>
<p>다음 예에서, 매개 변수 <em>a</em>와 <em>b</em>는 위치 전용이며, <em>c</em>나 <em>d</em>는 위치나 키워드일 수 있으며, <em>e</em>나 <em>f</em>는 키워드 전용이어야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>다음은 유효한 호출입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>하지만, 다음은 잘못된 호출입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>   <span class="c1"># b는 키워드 인자일 수 없습니다</span>
<span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>           <span class="c1"># e는 키워드 인자여야 합니다</span>
</pre></div>
</div>
<p>이 표기법의 한 가지 사용 사례는 순수 파이썬 함수가 기존 C 코드 함수의 동작을 완전히 흉내 낼 수 있다는 것입니다. 예를 들어, 내장 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 함수는 키워드 인자를 허용하지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
    <span class="s2">&quot;내장 divmod() 함수를 흉내 냅니다&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">//</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>또 다른 사용 사례는 매개 변수 이름이 도움이 되지 않을 때 키워드 인자를 배제하는 것입니다. 예를 들어, 내장 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 함수의 서명은 <code class="docutils literal notranslate"><span class="pre">len(obj,</span> <span class="pre">/)</span></code>입니다. 이것은 다음과 같은 어색한 호출을 금지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1"># &quot;obj&quot; 키워드 인자는 가독성을 떨어뜨립니다</span>
</pre></div>
</div>
<p>매개 변수를 위치 전용으로 표시하면 클라이언트 코드를 손상할 위험 없이 매개 변수 이름을 나중에 변경할 수 있다는 추가적인 이점이 있습니다. 예를 들어, <a class="reference internal" href="../library/statistics.html#module-statistics" title="statistics: Mathematical statistics functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">statistics</span></code></a> 모듈에서, 매개 변수 이름 <em>dist</em>는 나중에 변경될 수 있습니다. 이것은 다음과 같은 함수 명세 때문에 가능해졌습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">quantiles</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exclusive&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">/</span></code>의 왼쪽에 있는 매개 변수는 가능한 키워드로 노출되지 않기 때문에, 매개 변수 이름은 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>에서 계속 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>         <span class="c1"># a와 b는 두 가지 방식으로 사용됩니다</span>
<span class="go">10 20 {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
</pre></div>
</div>
<p>이는 임의의 키워드 인자를 받아들여야 하는 함수와 메서드의 구현을 크게 단순화합니다. 예를 들어, 다음은 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈의 코드에서 뽑아온 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># &quot;iterable&quot;이 가능한 키워드 인자임에 유의하십시오</span>
</pre></div>
</div>
<p>자세한 설명은 <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0570"><strong>PEP 570</strong></a>을 참조하십시오.</p>
<p>(Contributed by Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue36540">bpo-36540</a>.)</p>
</div>
<div class="section" id="parallel-filesystem-cache-for-compiled-bytecode-files">
<h3>컴파일된 바이트 코드 파일을 위한 병렬 파일 시스템 캐시<a class="headerlink" href="#parallel-filesystem-cache-for-compiled-bytecode-files" title="제목 주소">¶</a></h3>
<p>새 <span class="target" id="index-52"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPYCACHEPREFIX"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPYCACHEPREFIX</span></code></a> 설정(<a class="reference internal" href="../using/cmdline.html#id5"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">pycache_prefix</span></code>로도 사용 가능합니다)은 각 소스 디렉터리 내의 기본 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 하위 디렉터리 대신 별도의 병렬 파일 시스템 트리를 사용하도록 묵시적 바이트 코드 캐시를 구성합니다.</p>
<p>캐시의 위치는 <a class="reference internal" href="../library/sys.html#sys.pycache_prefix" title="sys.pycache_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.pycache_prefix</span></code></a>로 보고됩니다 (<a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 하위 디렉터리의 기본 위치를 나타냅니다).</p>
<p>(Contributed by Carl Meyer in <a class="reference external" href="https://bugs.python.org/issue33499">bpo-33499</a>.)</p>
</div>
<div class="section" id="debug-build-uses-the-same-abi-as-release-build">
<h3>디버그 빌드는 릴리스 빌드와 같은 ABI를 사용합니다.<a class="headerlink" href="#debug-build-uses-the-same-abi-as-release-build" title="제목 주소">¶</a></h3>
<p>파이썬은 이제 릴리스나 디버그 모드 중 어느 것으로 빌드되더라도 같은 ABI를 사용합니다. 유닉스에서, 파이썬이 디버그 모드로 빌드될 때, 이제 릴리스 모드로 빌드된 C 확장과 안정(stable) ABI를 사용해서 빌드된 C 확장을 로드할 수 있습니다.</p>
<p>릴리스 빌드와 디버그 빌드는 이제 ABI 호환됩니다: <code class="docutils literal notranslate"><span class="pre">Py_DEBUG</span></code> 매크로를 정의하는 것은 더는 <code class="docutils literal notranslate"><span class="pre">Py_TRACE_REFS</span></code> 매크로를 암시하지 않습니다, 이것은 ABI 비 호환성만 도입할 뿐입니다. <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getobjects()</span></code> 함수와 <span class="target" id="index-53"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDUMPREFS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDUMPREFS</span></code></a> 환경 변수를 추가하는 <code class="docutils literal notranslate"><span class="pre">Py_TRACE_REFS</span></code> 매크로는 새로운 <code class="docutils literal notranslate"><span class="pre">./configure</span> <span class="pre">--with-trace-refs</span></code> 빌드 옵션을 사용하여 설정할 수 있습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36465">bpo-36465</a>.)</p>
<p>유닉스에서, C 확장은 안드로이드와 Cygwin을 제외하고는 더는 libpython에 링크되지 않습니다. 이제 정적으로 링크된 파이썬이 공유 라이브러리 파이썬을 사용하여 빌드된 C 확장을 로드할 수 있습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue21536">bpo-21536</a>.)</p>
<p>유닉스에서, 파이썬이 디버그 모드로 빌드될 때, 임포트는 이제 릴리스 모드로 컴파일된 C 확장과 안정(stable) ABI로 컴파일된 C 확장도 찾습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36722">bpo-36722</a>.)</p>
<p>파이썬을 응용 프로그램에 내장하려면, 새로운 <code class="docutils literal notranslate"><span class="pre">--embed</span></code> 옵션을 <code class="docutils literal notranslate"><span class="pre">python3-config</span> <span class="pre">--libs</span> <span class="pre">--embed</span></code>에 전달하여 <code class="docutils literal notranslate"><span class="pre">-lpython3.8</span></code>을 얻어야 합니다 (응용 프로그램을 libpython에 링크합니다). 3.8 이하를 모두 지원하려면, 먼저 <code class="docutils literal notranslate"><span class="pre">python3-config</span> <span class="pre">--libs</span> <span class="pre">--embed</span></code>를 시도하고, 실패하면 <code class="docutils literal notranslate"><span class="pre">python3-config</span> <span class="pre">--libs</span></code>(<code class="docutils literal notranslate"><span class="pre">--embed</span></code> 없이)로 대체하십시오.</p>
<p>파이썬을 응용 프로그램에 내장하기 위해, pkg-config <code class="docutils literal notranslate"><span class="pre">python-3.8-embed</span></code> 모듈을 추가했습니다: <code class="docutils literal notranslate"><span class="pre">pkg-config</span> <span class="pre">python-3.8-embed</span> <span class="pre">--libs</span></code> 는 <code class="docutils literal notranslate"><span class="pre">-lpython3.8</span></code>을 포함합니다. 3.8 이하를 모두 지원하려면, 먼저 <code class="docutils literal notranslate"><span class="pre">pkg-config</span> <span class="pre">python-X.Y-embed</span> <span class="pre">--libs</span></code> 를 시도하고, 실패하면 <code class="docutils literal notranslate"><span class="pre">pkg-config</span> <span class="pre">python-X.Y</span> <span class="pre">--libs</span></code>(<code class="docutils literal notranslate"><span class="pre">--embed</span></code> 없이)로 대체하십시오 (<code class="docutils literal notranslate"><span class="pre">X.Y</span></code>를 파이썬 버전으로 교체하십시오).</p>
<p>반면에, <code class="docutils literal notranslate"><span class="pre">pkg-config</span> <span class="pre">python3.8</span> <span class="pre">--libs</span></code> 는 더는 <code class="docutils literal notranslate"><span class="pre">-lpython3.8</span></code>을 포함하지 않습니다. C 확장은 libpython에 링크되어서는 안 됩니다 (안드로이드와 Cygwin은 예외인데, 이들은 스크립트로 처리됩니다); 이 변경은 의도적으로 이전 버전과 호환되지 않습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36721">bpo-36721</a>.)</p>
</div>
<div class="section" id="f-strings-support-for-self-documenting-expressions-and-debugging">
<h3>f-문자열은 스스로 설명하는 표현식과 디버깅을 위해 =를 지원합니다.<a class="headerlink" href="#f-strings-support-for-self-documenting-expressions-and-debugging" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-f-string"><span class="xref std std-term">f-문자열</span></a>에 <code class="docutils literal notranslate"><span class="pre">=</span></code> 지정자를 추가했습니다. <code class="docutils literal notranslate"><span class="pre">f'{expr=}'</span></code>과 같은 f-문자열은 표현식의 텍스트, 등호, 평가된 표현식의 표현(repr)으로 확장됩니다. 예를 들어:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="s1">&#39;eric_idle&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">member_since</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">1975</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;{user=} {member_since=}&#39;</span>
<span class="go">&quot;user=&#39;eric_idle&#39; member_since=datetime.date(1975, 7, 31)&quot;</span>
</pre></div>
</div>
<p>일반적인 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">f-문자열 포맷 지정자</span></a>를 사용하면 표현식의 결과가 표시되는 방식을 더 잘 제어할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">delta</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="o">-</span> <span class="n">member_since</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;{user=!s}  {delta.days=:,d}&#39;</span>
<span class="go">&#39;user=eric_idle  delta.days=16,075&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">=</span></code> 지정자는 계산을 표시할 수 있도록 전체 표현식을 표시합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;{theta=}  {cos(radians(theta))=:.3f}&#39;</span><span class="p">)</span>
<span class="go">theta=30  cos(radians(theta))=0.866</span>
</pre></div>
</div>
<p>(Contributed by Eric V. Smith and Larry Hastings in <a class="reference external" href="https://bugs.python.org/issue36817">bpo-36817</a>.)</p>
</div>
<div class="section" id="pep-578-python-runtime-audit-hooks">
<h3>PEP 578: 파이썬 런타임 감사 훅<a class="headerlink" href="#pep-578-python-runtime-audit-hooks" title="제목 주소">¶</a></h3>
<p>이 PEP는 감사 훅(Audit Hook)과 확인된 열기 훅(Verified Open Hook)을 추가합니다. 둘 다 파이썬과 네이티브 코드에서 사용 가능해서, 순수 파이썬 코드로 작성된 응용 프로그램과 프레임워크가 추가 알림을 활용할 수 있도록 함과 동시에 임베더(embedder)나 시스템 관리자가 감사가 항상 활성화된 파이썬 빌드를 배치할 수 있도록 합니다.</p>
<p>자세한 설명은 <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0578"><strong>PEP 578</strong></a>을 참조하십시오.</p>
</div>
<div class="section" id="pep-587-python-initialization-configuration">
<h3>PEP 587: 파이썬 초기화 구성<a class="headerlink" href="#pep-587-python-initialization-configuration" title="제목 주소">¶</a></h3>
<p><span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0587"><strong>PEP 587</strong></a>은 파이썬 초기화를 구성하는 새로운 C API를 추가하여 전체 구성에 대한 세밀한 제어와 개선된 에러 보고를 제공합니다.</p>
<p>새로운 구조체:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyPreConfig" title="PyPreConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyPreConfig</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus" title="PyStatus"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyStatus</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyWideStringList" title="PyWideStringList"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyWideStringList</span></code></a></p></li>
</ul>
<p>새로운 함수:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_Clear" title="PyConfig_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Clear()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_InitIsolatedConfig" title="PyConfig_InitIsolatedConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_InitIsolatedConfig()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_InitPythonConfig" title="PyConfig_InitPythonConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_InitPythonConfig()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_SetArgv" title="PyConfig_SetArgv"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_SetArgv()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_SetBytesArgv" title="PyConfig_SetBytesArgv"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_SetBytesArgv()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_SetBytesString" title="PyConfig_SetBytesString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_SetBytesString()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyConfig_SetString" title="PyConfig_SetString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_SetString()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyPreConfig_InitIsolatedConfig" title="PyPreConfig_InitIsolatedConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyPreConfig_InitIsolatedConfig()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyPreConfig_InitPythonConfig" title="PyPreConfig_InitPythonConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyPreConfig_InitPythonConfig()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_Error" title="PyStatus_Error"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_Error()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_Exception" title="PyStatus_Exception"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_Exception()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_Exit" title="PyStatus_Exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_Exit()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_IsError" title="PyStatus_IsError"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_IsError()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_IsExit" title="PyStatus_IsExit"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_IsExit()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_NoMemory" title="PyStatus_NoMemory"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_NoMemory()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyStatus_Ok" title="PyStatus_Ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStatus_Ok()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyWideStringList_Append" title="PyWideStringList_Append"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyWideStringList_Append()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.PyWideStringList_Insert" title="PyWideStringList_Insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyWideStringList_Insert()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/veryhigh.html#c.Py_BytesMain" title="Py_BytesMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BytesMain()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.Py_ExitStatusException" title="Py_ExitStatusException"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_ExitStatusException()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.Py_PreInitialize" title="Py_PreInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_PreInitialize()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.Py_PreInitializeFromArgs" title="Py_PreInitializeFromArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_PreInitializeFromArgs()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.Py_PreInitializeFromBytesArgs" title="Py_PreInitializeFromBytesArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_PreInitializeFromBytesArgs()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/init_config.html#c.Py_RunMain" title="Py_RunMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_RunMain()</span></code></a></p></li>
</ul>
<p>이 PEP는 이러한 내부 구조체에 <code class="docutils literal notranslate"><span class="pre">_PyRuntimeState.preconfig</span></code>(<a class="reference internal" href="../c-api/init_config.html#c.PyPreConfig" title="PyPreConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyPreConfig</span></code></a> 형)와 <code class="docutils literal notranslate"><span class="pre">PyInterpreterState.config</span></code> (<a class="reference internal" href="../c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a> 형) 필드를 추가합니다. <code class="docutils literal notranslate"><span class="pre">PyInterpreterState.config</span></code>는 전역 구성 변수와 기타 내부(private) 변수를 대체하는 새로운 참조 구성이 됩니다.</p>
<p>설명서는 <a class="reference internal" href="../c-api/init_config.html#init-config"><span class="std std-ref">파이썬 초기화 구성</span></a>을 참조하십시오.</p>
<p>자세한 설명은 <span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0587"><strong>PEP 587</strong></a>을 참조하십시오.</p>
<p>(Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36763">bpo-36763</a>.)</p>
</div>
<div class="section" id="pep-590-vectorcall-a-fast-calling-protocol-for-cpython">
<h3>PEP 590: 벡터콜: CPython을 위한 빠른 호출 프로토콜<a class="headerlink" href="#pep-590-vectorcall-a-fast-calling-protocol-for-cpython" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../c-api/call.html#vectorcall"><span class="std std-ref">벡터콜(Vectorcall) 프로토콜</span></a>이 파이썬/C API에 추가되었습니다. 이것은 이미 다양한 클래스에 대해 수행된 기존 최적화를 형식화하기 위한 것입니다. 콜러블을 구현하는 모든 정적인 형은 이 프로토콜을 사용할 수 있습니다.</p>
<p>이것은 현재 잠정적(provisional)입니다. 목표는 파이썬 3.9에서 완전히 공개하는 것입니다.</p>
<p>자세한 설명은 <span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0590"><strong>PEP 590</strong></a>을 참조하십시오.</p>
<p>(Contributed by Jeroen Demeyer, Mark Shannon and Petr Viktorin in <a class="reference external" href="https://bugs.python.org/issue36974">bpo-36974</a>.)</p>
</div>
<div class="section" id="pickle-protocol-5-with-out-of-band-data-buffers">
<h3>아웃 오브 밴드 데이터 버퍼를 사용하는 피클 프로토콜 5<a class="headerlink" href="#pickle-protocol-5-with-out-of-band-data-buffers" title="제목 주소">¶</a></h3>
<p>멀티 코어나 멀티 머신 프로세싱을 활용하기 위해 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>을 사용해서 파이썬 프로세스 간에 큰 데이터를 전송할 때, 메모리 복사를 줄이고 데이터 종속적 압축과 같은 사용자 정의 기술을 적용하여 전송을 최적화하는 것이 중요합니다.</p>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 프로토콜 5는 통신 계층의 재량에 따라 <span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> 호환 데이터가 주 피클 스트림과 별도로 전송될 수 있는 아웃 오브 밴드 버퍼를 지원합니다.</p>
<p>자세한 설명은 <span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0574"><strong>PEP 574</strong></a>를 참조하십시오.</p>
<p>(Contributed by Antoine Pitrou in <a class="reference external" href="https://bugs.python.org/issue36785">bpo-36785</a>.)</p>
</div>
</div>
<div class="section" id="other-language-changes">
<h2>기타 언어 변경<a class="headerlink" href="#other-language-changes" title="제목 주소">¶</a></h2>
<ul>
<li><p><a class="reference internal" href="../reference/simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문은 구현 문제로 인해 <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절에서 사용할 수 없었습니다. 파이썬 3.8에서는 이 제한이 제거되었습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue32489">bpo-32489</a>.)</p></li>
<li><p><a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 및 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 형에는 이제 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>와 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>에서 발견되는 것과 유사한 <a class="reference internal" href="../library/stdtypes.html#int.as_integer_ratio" title="int.as_integer_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_integer_ratio()</span></code></a> 메서드가 있습니다. 이 작은 API 확장을 통해 <code class="docutils literal notranslate"><span class="pre">numerator,</span> <span class="pre">denominator</span> <span class="pre">=</span> <span class="pre">x.as_integer_ratio()</span></code>라고 쓰고 여러 숫자 형에서 작동하도록 할 수 있습니다. (Contributed by Lisa Roach in <a class="reference external" href="https://bugs.python.org/issue33073">bpo-33073</a> and Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue37819">bpo-37819</a>.)</p></li>
<li><p><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 및 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>의 생성자는 이제 해당 메서드 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 또는 <a class="reference internal" href="../reference/datamodel.html#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a>를 사용할 수 없을 때, <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 특수 메서드가 있으면 사용할 수 있습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue20092">bpo-20092</a>.)</p></li>
<li><p><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">정규식</span></code></a>에 <code class="docutils literal notranslate"><span class="pre">\N{name}</span></code> 이스케이프 지원이 추가되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">notice</span> <span class="o">=</span> <span class="s1">&#39;Copyright © 2019&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copyright_year_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\N{copyright sign}\s*(\d</span><span class="si">{4}</span><span class="s1">)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">copyright_year_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">notice</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">2019</span>
</pre></div>
</div>
<p>(Contributed by Jonathan Eunice and Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue30688">bpo-30688</a>.)</p>
</li>
<li><p>이제 딕셔너리와 딕셔너리 뷰는 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a>를 사용하여 삽입 순서의 역순으로 이터레이트 할 수 있습니다. (Contributed by Rémi Lapeyre in <a class="reference external" href="https://bugs.python.org/issue33462">bpo-33462</a>.)</p></li>
<li><p>함수 호출에서 키워드 이름에 허용된 문법이 더 제한되었습니다. 특히, <code class="docutils literal notranslate"><span class="pre">f((keyword)=arg)</span></code>는 더는 허용되지 않습니다. 키워드 인자 대입 항의 왼쪽에 이름 그대로 이상의 것을 허용하려는 의도는 결코 없었습니다. (Contributed by Benjamin Peterson in <a class="reference external" href="https://bugs.python.org/issue34641">bpo-34641</a>.)</p></li>
<li><p><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>와 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문에서의 일반화된 이터러블 언 패킹은 더는 둘러싸는 괄호를 요구하지 않습니다. 이는 <em>yield</em>와 <em>return</em> 문법이 일반 대입 문법과 더 잘 일치하도록 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">family</span><span class="p">):</span>
<span class="go">        lastname, *members = family.split()</span>
<span class="go">        return lastname.upper(), *members</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;simpsons homer marge bart lisa maggie&#39;</span><span class="p">)</span>
<span class="go">(&#39;SIMPSONS&#39;, &#39;homer&#39;, &#39;marge&#39;, &#39;bart&#39;, &#39;lisa&#39;, &#39;maggie&#39;)</span>
</pre></div>
</div>
<p>(Contributed by David Cuthbert and Jordan Chapman in <a class="reference external" href="https://bugs.python.org/issue32117">bpo-32117</a>.)</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">[(10,</span> <span class="pre">20)</span> <span class="pre">(30,</span> <span class="pre">40)]</span></code>와 같은 코드에서처럼 쉼표가 빠질 때, 컴파일러는 유용한 제안과 함께 <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>을 표시합니다. 이것은 단지 첫 번째 튜플이 콜러블이 아니라고 알리는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 개선한 것입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue15248">bpo-15248</a>.)</p></li>
<li><p><a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a>나 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>의 서브 클래스와 <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.timedelta</span></code></a> 객체 간의 산술 연산은 이제 베이스 클래스가 아닌 서브 클래스의 인스턴스를 반환합니다. 이는 <a class="reference internal" href="../library/datetime.html#datetime.datetime.astimezone" title="datetime.datetime.astimezone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astimezone()</span></code></a>과 같은 <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.timedelta</span></code></a> 산술을 직접 또는 간접적으로 사용하는 연산의 반환형에도 영향을 줍니다. (Contributed by Paul Ganssle in <a class="reference external" href="https://bugs.python.org/issue32417">bpo-32417</a>.)</p></li>
<li><p>파이썬 인터프리터가 Ctrl-C(SIGINT)에 의해 인터럽트 되고 그로 인한 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 예외가 잡히지 않으면, 파이썬 프로세스는 이제 Ctrl-C로 인해 죽었다는 것을 호출한 프로세스가 감지할 수 있도록 SIGINT 시그널을 통해서나 올바른 종료 코드를 통해 종료합니다. POSIX와 윈도우의 셸은 대화식 세션에서 스크립트를 올바르게 종료하기 위해 이를 사용합니다. (Contributed by Google via Gregory P. Smith in <a class="reference external" href="https://bugs.python.org/issue1054041">bpo-1054041</a>.)</p></li>
<li><p>일부 고급 프로그래밍 스타일은 기존 함수에 대한 <a class="reference internal" href="../library/types.html#types.CodeType" title="types.CodeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.CodeType</span></code></a> 객체를 갱신할 필요가 있습니다. 코드 객체는 불변이므로, 기존 코드 객체에 기반하는 새 코드 객체를 만들어야 합니다. 19개의 매개 변수 때문에, 다소 지루했습니다. 이제, 새로운 <code class="docutils literal notranslate"><span class="pre">replace()</span></code> 메서드를 사용하면 몇 가지 변경된 매개 변수만으로 복제본을 만들 수 있습니다.</p>
<p>다음은 <em>data</em> 매개 변수가 키워드 인자로 사용되지 않도록 <a class="reference internal" href="../library/statistics.html#statistics.mean" title="statistics.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.mean()</span></code></a> 함수를 변경하는 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">statistics</span> <span class="k">import</span> <span class="n">mean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
<span class="go">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">co_posonlyargcount</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">mean() got some positional-only arguments passed as keyword arguments: &#39;data&#39;</span>
</pre></div>
</div>
<p>(Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue37032">bpo-37032</a>.)</p>
</li>
<li><p>정수의 경우, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 함수의 세 인자 형식은 이제 밑이 모듈러스와 서로소일 때 음수 지수를 허용합니다. 지수가 <code class="docutils literal notranslate"><span class="pre">-1</span></code>일 때 밑에 대한 모듈러 역수를 계산하고, 다른 음수 지수에 대해서는 그 역수의 적절한 거듭제곱을 계산합니다. 예를 들어, 모듈로 137에 대한 38의 <a class="reference external" href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">모듈러 역수</a>를 계산하려면, 다음과 같이 작성하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">pow</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">137</span><span class="p">)</span>
<span class="go">119</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">119</span> <span class="o">*</span> <span class="mi">38</span> <span class="o">%</span> <span class="mi">137</span>
<span class="go">1</span>
</pre></div>
</div>
<p>모듈러 역수는 <a class="reference external" href="https://en.wikipedia.org/wiki/Diophantine_equation">선형 디오판토스 방정식(linear Diophantine equations)</a>의 해에서 나타납니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">4258𝑥</span> <span class="pre">+</span> <span class="pre">147𝑦</span> <span class="pre">=</span> <span class="pre">369</span></code>에 대한 정수해를 찾으려면, 먼저 <code class="docutils literal notranslate"><span class="pre">4258𝑥</span> <span class="pre">≡</span> <span class="pre">369</span> <span class="pre">(mod</span> <span class="pre">147)</span></code>로 다시 쓴 다음 해를 구하십시오:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">369</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">4258</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">147</span><span class="p">)</span> <span class="o">%</span> <span class="mi">147</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4258</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">369</span><span class="p">)</span> <span class="o">//</span> <span class="o">-</span><span class="mi">147</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4258</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">147</span> <span class="o">*</span> <span class="n">y</span>
<span class="go">369</span>
</pre></div>
</div>
<p>(Contributed by Mark Dickinson in <a class="reference external" href="https://bugs.python.org/issue36027">bpo-36027</a>.)</p>
</li>
<li><p>키가 먼저 계산되고 값이 두 번째로 계산되도록, 딕셔너리 컴프리헨션은 딕셔너리 리터럴과 동기화되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 딕셔너리 컴프리헨션</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span> <span class="o">=</span> <span class="p">{</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;role? &#39;</span><span class="p">):</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;actor? &#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)}</span>
<span class="go">role? King Arthur</span>
<span class="go">actor? Chapman</span>
<span class="go">role? Black Knight</span>
<span class="go">actor? Cleese</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 딕셔너리 리터럴</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span> <span class="o">=</span> <span class="p">{</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;role? &#39;</span><span class="p">):</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;actor? &#39;</span><span class="p">)}</span>
<span class="go">role? Sir Robin</span>
<span class="go">actor? Eric Idle</span>
</pre></div>
</div>
<p>키 표현식에서 대입된 변수를 값 표현식에서 사용할 수 있기 때문에, 보장된 실행 순서는 대입 표현식에 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Martin von Löwis&#39;</span><span class="p">,</span> <span class="s1">&#39;Łukasz Langa&#39;</span><span class="p">,</span> <span class="s1">&#39;Walter Dörwald&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{(</span><span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;NFC&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span><span class="o">.</span><span class="n">casefold</span><span class="p">()</span> <span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
<span class="go">{&#39;martin von löwis&#39;: &#39;Martin von Löwis&#39;,</span>
<span class="go"> &#39;łukasz langa&#39;: &#39;Łukasz Langa&#39;,</span>
<span class="go"> &#39;walter dörwald&#39;: &#39;Walter Dörwald&#39;}</span>
</pre></div>
</div>
<p>(Contributed by Jörn Heissler in <a class="reference external" href="https://bugs.python.org/issue35224">bpo-35224</a>.)</p>
</li>
<li><p><a class="reference internal" href="../library/pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__reduce__()</span></code></a> 메서드는 이제 2개에서 6개 요소 길이의 튜플을 반환할 수 있습니다. 이전에는 5가 한계였습니다. 새로운 선택적 여섯 번째 요소는 <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code> 서명을 갖는 콜러블입니다. 이를 통해 특정 객체의 상태 갱신 동작을 직접 제어할 수 있습니다. <em>None</em>이 아니면, 이 콜러블은 객체의 <a class="reference internal" href="../library/pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 메서드보다 우선합니다. (Contributed by Pierre Glaser and Olivier Grisel in <a class="reference external" href="https://bugs.python.org/issue35900">bpo-35900</a>.)</p></li>
</ul>
</div>
<div class="section" id="new-modules">
<h2>새 모듈<a class="headerlink" href="#new-modules" title="제목 주소">¶</a></h2>
<ul>
<li><p>새로운 <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code> 모듈은 제삼자 패키지에서 메타 데이터를 읽을 수 있도록 (잠정적으로) 지원합니다. 예를 들어, 설치된 패키지의 버전 번호, 진입점 목록 등을 추출 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 다음 예에서는 널리 사용되는 &quot;requests&quot; 패키지가 설치되어 있어야 함에 유의하십시오.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">importlib.metadata</span> <span class="k">import</span> <span class="n">version</span><span class="p">,</span> <span class="n">requires</span><span class="p">,</span> <span class="n">files</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">version</span><span class="p">(</span><span class="s1">&#39;requests&#39;</span><span class="p">)</span>
<span class="go">&#39;2.22.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">requires</span><span class="p">(</span><span class="s1">&#39;requests&#39;</span><span class="p">))</span>
<span class="go">[&#39;chardet (&lt;3.1.0,&gt;=3.0.2)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">files</span><span class="p">(</span><span class="s1">&#39;requests&#39;</span><span class="p">))[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[PackagePath(&#39;requests-2.22.0.dist-info/INSTALLER&#39;),</span>
<span class="go"> PackagePath(&#39;requests-2.22.0.dist-info/LICENSE&#39;),</span>
<span class="go"> PackagePath(&#39;requests-2.22.0.dist-info/METADATA&#39;),</span>
<span class="go"> PackagePath(&#39;requests-2.22.0.dist-info/RECORD&#39;),</span>
<span class="go"> PackagePath(&#39;requests-2.22.0.dist-info/WHEEL&#39;)]</span>
</pre></div>
</div>
<p>(Contributed by Barry Warsaw and Jason R. Coombs in <a class="reference external" href="https://bugs.python.org/issue34632">bpo-34632</a>.)</p>
</li>
</ul>
</div>
<div class="section" id="improved-modules">
<h2>개선된 모듈<a class="headerlink" href="#improved-modules" title="제목 주소">¶</a></h2>
<div class="section" id="ast">
<h3>ast<a class="headerlink" href="#ast" title="제목 주소">¶</a></h3>
<p>이제 AST 노드는 노드 끝의 정확한 위치를 제공하는 <code class="docutils literal notranslate"><span class="pre">end_lineno</span></code>와 <code class="docutils literal notranslate"><span class="pre">end_col_offset</span></code> 어트리뷰트를 가집니다. (이것은 <code class="docutils literal notranslate"><span class="pre">lineno</span></code>와 <code class="docutils literal notranslate"><span class="pre">col_offset</span></code> 어트리뷰트가 있는 노드에만 적용됩니다.)</p>
<p>새 함수 <a class="reference internal" href="../library/ast.html#ast.get_source_segment" title="ast.get_source_segment"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.get_source_segment()</span></code></a>는 특정 AST 노드의 소스 코드를 반환합니다.</p>
<p>(Contributed by Ivan Levkivskyi in <a class="reference external" href="https://bugs.python.org/issue33416">bpo-33416</a>.)</p>
<p><a class="reference internal" href="../library/ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.parse()</span></code></a> 함수에는 몇 가지 새로운 플래그가 있습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type_comments=True</span></code>는 특정 AST 노드와 연관된 <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>와 <span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 형 주석의 텍스트를 반환하도록 합니다;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mode='func_type'</span></code>은 <span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> &quot;서명 형 주석&quot;(함수 정의 AST 노드에 대해 반환됩니다)을 구문 분석하는 데 사용될 수 있습니다;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">feature_version=(3,</span> <span class="pre">N)</span></code>은 이전 버전의 파이썬 3을 지정할 수 있게 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">feature_version=(3,</span> <span class="pre">4)</span></code>는 <a class="reference internal" href="../reference/compound_stmts.html#async"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span></code></a>와 <a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>를 예약어가 아닌 단어로 취급합니다.</p></li>
</ul>
<p>(Contributed by Guido van Rossum in <a class="reference external" href="https://bugs.python.org/issue35766">bpo-35766</a>.)</p>
</div>
<div class="section" id="asyncio">
<h3>asyncio<a class="headerlink" href="#asyncio" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>은 임시 API를 졸업하고 안정 API가 되었습니다. 이 함수는 이벤트 루프를 자동으로 관리하면서 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a>을 실행하고 결과를 반환하는 데 사용할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>이것은 <em>대략</em> 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>실제 구현은 훨씬 더 복잡합니다. 따라서, <a class="reference internal" href="../library/asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>은 asyncio 프로그램을 실행하는 데 선호되는 방법이어야 합니다.</p>
<p>(Contributed by Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue32314">bpo-32314</a>.)</p>
<p><code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">asyncio</span></code>를 실행하면 네이티브 하게 비동기 REPL을 시작합니다. 이를 통해 최상위 <a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>가 있는 코드를 빠르게 실험할 수 있습니다. 더는 호출할 때마다 새로운 이벤트 루프를 만드는 <code class="docutils literal notranslate"><span class="pre">asyncio.run()</span></code>을 직접 호출할 필요가 없습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python -m asyncio
asyncio REPL 3.8.0
Use &quot;await&quot; directly instead of &quot;asyncio.run()&quot;.
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; await asyncio.sleep(10, result=&#39;hello&#39;)
hello
</pre></div>
</div>
<p>(Contributed by Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue37028">bpo-37028</a>.)</p>
<p><a class="reference internal" href="../library/asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> 예외는 이제 <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a>이 아닌 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseException</span></code></a>을 상속하고, 더는 <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.CancelledError</span></code></a>를 상속하지 않습니다. (Contributed by Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue32528">bpo-32528</a>.)</p>
<p>윈도우에서, 기본 이벤트 루프는 이제 <a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 입니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue34687">bpo-34687</a>.)</p>
<p><a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>는 이제 UDP도 지원합니다. (Contributed by Adam Meily and Andrew Svetlov in <a class="reference external" href="https://bugs.python.org/issue29883">bpo-29883</a>.)</p>
<p>이제 <a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>가 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>(&quot;CTRL+C&quot;)에 의해 인터럽트 될 수 있습니다. (Contributed by Vladimir Matveev in <a class="reference external" href="https://bugs.python.org/issue23057">bpo-23057</a>.)</p>
<p><a class="reference internal" href="../library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> 내에 래핑 된 코루틴을 얻기 위한 <a class="reference internal" href="../library/asyncio-task.html#asyncio.Task.get_coro" title="asyncio.Task.get_coro"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.Task.get_coro()</span></code></a>를 추가했습니다. (Contributed by Alex Grönholm in <a class="reference external" href="https://bugs.python.org/issue36999">bpo-36999</a>.)</p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">name</span></code> 키워드 인자를 <a class="reference internal" href="../library/asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a>나 <a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_task()</span></code></a> 이벤트 루프 메서드에 전달하거나, 태스크 객체의 <a class="reference internal" href="../library/asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_name()</span></code></a> 메서드를 호출하여 asyncio 태스크의 이름을 지정할 수 있습니다. 태스크 이름은 <a class="reference internal" href="../library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">repr()</span></code> 출력에 표시되며 <a class="reference internal" href="../library/asyncio-task.html#asyncio.Task.get_name" title="asyncio.Task.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> 메서드를 사용하여 조회할 수도 있습니다. (Contributed by Alex Grönholm in <a class="reference external" href="https://bugs.python.org/issue34270">bpo-34270</a>.)</p>
<p><a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.create_connection()</span></code></a>에 <a class="reference external" href="https://en.wikipedia.org/wiki/Happy_Eyeballs">Happy Eyeballs</a>에 대한 지원이 추가되었습니다. 동작을 지정하기 위해, 두 개의 매개변수가 추가되었습니다: <em>happy_eyeballs_delay</em>와 <em>interleave</em>. Happy Eyeballs 알고리즘은 IPv4와 IPv6을 지원하는 응용 프로그램에서 둘 모두를 사용하여 동시에 연결을 시도하여 응답성을 향상합니다. (Contributed by twisteroid ambassador in <a class="reference external" href="https://bugs.python.org/issue33530">bpo-33530</a>.)</p>
</div>
<div class="section" id="builtins">
<h3>builtins<a class="headerlink" href="#builtins" title="제목 주소">¶</a></h3>
<p>내장 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">ast.PyCF_ALLOW_TOP_LEVEL_AWAIT</span></code> 플래그를 받아들이도록 개선되었습니다. 이 새 플래그가 전달되면, <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>은 일반적으로 유효하지 문법으로 간주하는 최상위 수준 <code class="docutils literal notranslate"><span class="pre">await</span></code>, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 및 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 구문을 허용합니다. 그러면 <code class="docutils literal notranslate"><span class="pre">CO_COROUTINE</span></code> 플래그로 표시된 비동기 코드 객체가 반환될 수 있습니다. (Contributed by Matthias Bussonnier in <a class="reference external" href="https://bugs.python.org/issue34616">bpo-34616</a>)</p>
</div>
<div class="section" id="collections">
<h3>collections<a class="headerlink" href="#collections" title="제목 주소">¶</a></h3>
<p>이제 <a class="reference internal" href="../library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>의 <a class="reference internal" href="../library/collections.html#collections.somenamedtuple._asdict" title="collections.somenamedtuple._asdict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_asdict()</span></code></a> 메서드는 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 대신 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>를 반환합니다. 파이썬 3.7부터 일반 딕셔너리가 순서를 보장하기 때문에 이것이 가능합니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code>의 추가 기능이 필요하면, 제안된 해결 방법은 원하는 형으로 결과를 캐스팅하는 것입니다: <code class="docutils literal notranslate"><span class="pre">OrderedDict(nt._asdict())</span></code>. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue35864">bpo-35864</a>.)</p>
</div>
<div class="section" id="cprofile">
<h3>cProfile<a class="headerlink" href="#cprofile" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/profile.html#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code></a> 클래스는 이제 컨텍스트 관리자로 사용할 수 있습니다. 다음처럼 코드 블록을 프로파일 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>

<span class="k">with</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span> <span class="k">as</span> <span class="n">profiler</span><span class="p">:</span>
      <span class="c1"># 프로파일 할 코드</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>(Contributed by Scott Sanderson in <a class="reference external" href="https://bugs.python.org/issue29235">bpo-29235</a>.)</p>
</div>
<div class="section" id="csv">
<h3>csv<a class="headerlink" href="#csv" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/csv.html#csv.DictReader" title="csv.DictReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">csv.DictReader</span></code></a>는 이제 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 대신 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>의 인스턴스를 반환합니다. 이 도구는 이제 여전히 필드 순서를 유지하면서 더 빠르고 메모리를 덜 사용합니다. (Contributed by Michael Selik in <a class="reference external" href="https://bugs.python.org/issue34003">bpo-34003</a>.)</p>
</div>
<div class="section" id="curses">
<h3>curses<a class="headerlink" href="#curses" title="제목 주소">¶</a></h3>
<p>하부 ncurses 라이브러리에 대한 구조화된 버전 정보를 담는 새로운 변수를 추가했습니다: <a class="reference internal" href="../library/curses.html#curses.ncurses_version" title="curses.ncurses_version"><code class="xref py py-data docutils literal notranslate"><span class="pre">ncurses_version</span></code></a>. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue31680">bpo-31680</a>.)</p>
</div>
<div class="section" id="ctypes">
<h3>ctypes<a class="headerlink" href="#ctypes" title="제목 주소">¶</a></h3>
<p>윈도우에서, <a class="reference internal" href="../library/ctypes.html#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 및 서브 클래스는 이제 하부 <code class="docutils literal notranslate"><span class="pre">LoadLibraryEx</span></code> 호출에 대한 플래그를 지정하는 <em>winmode</em> 매개 변수를 받아들입니다. 기본 플래그는 DLL이 저장된 경로(전체나 부분 경로가 초기 DLL을 로드하는 데 사용되었다면)와 <a class="reference internal" href="../library/os.html#os.add_dll_directory" title="os.add_dll_directory"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_dll_directory()</span></code></a>로 추가된 경로를 포함하여 신뢰할 수 있는 위치에서만 DLL 종속성을 로드하도록 설정됩니다. (Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue36085">bpo-36085</a>.)</p>
</div>
<div class="section" id="datetime">
<h3>datetime<a class="headerlink" href="#datetime" title="제목 주소">¶</a></h3>
<p>ISO 년, 주 번호 및 요일로 <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code>와 <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 객체를 각각 생성하는, 새로운 대체 생성자 <a class="reference internal" href="../library/datetime.html#datetime.date.fromisocalendar" title="datetime.date.fromisocalendar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.date.fromisocalendar()</span></code></a> 와 <a class="reference internal" href="../library/datetime.html#datetime.datetime.fromisocalendar" title="datetime.datetime.fromisocalendar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.datetime.fromisocalendar()</span></code></a>를 추가했습니다; 이것들은 각 클래스의 <code class="docutils literal notranslate"><span class="pre">isocalendar</span></code> 메서드의 역입니다. (Contributed by Paul Ganssle in <a class="reference external" href="https://bugs.python.org/issue36004">bpo-36004</a>.)</p>
</div>
<div class="section" id="functools">
<h3>functools<a class="headerlink" href="#functools" title="제목 주소">¶</a></h3>
<p>이제 <a class="reference internal" href="../library/functools.html#functools.lru_cache" title="functools.lru_cache"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.lru_cache()</span></code></a>는 데코레이터를 반환하는 함수가 아닌 직접적인 데코레이터로 사용할 수 있습니다. 그래서 이 두 가지가 모두 지원됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@lru_cache</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>

<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue36772">bpo-36772</a>.)</p>
<p>인스턴스 수명 동안 캐시 된 계산된 속성을 위한 새로운 <a class="reference internal" href="../library/functools.html#functools.cached_property" title="functools.cached_property"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cached_property()</span></code></a> 데코레이터를 추가했습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">statistics</span>

<span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_of_numbers</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sequence_of_numbers</span>

   <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
   <span class="k">def</span> <span class="nf">variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">statistics</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contributed by Carl Meyer in <a class="reference external" href="https://bugs.python.org/issue21145">bpo-21145</a>)</p>
<p><a class="reference internal" href="../glossary.html#term-single-dispatch"><span class="xref std std-term">싱글 디스패치</span></a>를 사용하여 메서드를 <a class="reference internal" href="../glossary.html#term-generic-function"><span class="xref std std-term">제네릭 함수</span></a>로 변환하는 새로운 <a class="reference internal" href="../library/functools.html#functools.singledispatchmethod" title="functools.singledispatchmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatchmethod()</span></code></a> 데코레이터를 추가했습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">singledispatchmethod</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">suppress</span>

<span class="k">class</span> <span class="nc">TaskManager</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@discard</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="p">):</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]</span>
</pre></div>
</div>
<p>(Contributed by Ethan Smith in <a class="reference external" href="https://bugs.python.org/issue32380">bpo-32380</a>)</p>
</div>
<div class="section" id="gc">
<h3>gc<a class="headerlink" href="#gc" title="제목 주소">¶</a></h3>
<p>이제 <a class="reference internal" href="../library/gc.html#gc.get_objects" title="gc.get_objects"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_objects()</span></code></a>는 객체를 가져올 세대(generation)를 나타내는 선택적 <em>generation</em> 매개 변수를 받을 수 있습니다. (Contributed by Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue36016">bpo-36016</a>.)</p>
</div>
<div class="section" id="gettext">
<h3>gettext<a class="headerlink" href="#gettext" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/gettext.html#gettext.pgettext" title="gettext.pgettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">pgettext()</span></code></a>와 그 변형을 추가했습니다. (Contributed by Franz Glasner, Éric Araujo, and Cheryl Sabella in <a class="reference external" href="https://bugs.python.org/issue2504">bpo-2504</a>.)</p>
</div>
<div class="section" id="gzip">
<h3>gzip<a class="headerlink" href="#gzip" title="제목 주소">¶</a></h3>
<p>재현성 있는 출력을 위해 <a class="reference internal" href="../library/gzip.html#gzip.compress" title="gzip.compress"><code class="xref py py-func docutils literal notranslate"><span class="pre">gzip.compress()</span></code></a>에 <em>mtime</em> 매개 변수를 추가했습니다. (Contributed by Guo Ci Teo in <a class="reference external" href="https://bugs.python.org/issue34898">bpo-34898</a>.)</p>
<p>특정 유형의 유효하지 않거나 손상된 gzip 파일의 경우 이제 <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 대신 <a class="reference internal" href="../library/gzip.html#gzip.BadGzipFile" title="gzip.BadGzipFile"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BadGzipFile</span></code></a> 예외가 발생합니다. (Contributed by Filip Gruszczyński, Michele Orrù, and Zackery Spytz in <a class="reference external" href="https://bugs.python.org/issue6584">bpo-6584</a>.)</p>
</div>
<div class="section" id="idle-and-idlelib">
<h3>IDLE과 idlelib<a class="headerlink" href="#idle-and-idlelib" title="제목 주소">¶</a></h3>
<p>N 줄(기본적으로 50)을 초과하는 출력은 버튼으로 축소됩니다. N은 설정 대화 상자의 General 페이지의 PyShell 섹션에서 변경할 수 있습니다. 그보다 작은, 하지만 아주 길 수도 있는, 줄은 출력을 마우스 오른쪽 버튼으로 클릭하면 압착할 수 있습니다. 압착된 출력은 버튼을 더블 클릭해서 제자리에서 확장하거나, 버튼을 마우스 오른쪽 단추로 클릭하여 클립 보드나 별도의 창으로 확장할 수 있습니다. (Contributed by Tal Einat in <a class="reference external" href="https://bugs.python.org/issue1529353">bpo-1529353</a>.)</p>
<p>사용자 정의 설정으로 모듈을 실행하기 위해 Run 메뉴에 &quot;Run Customized&quot;를 추가합니다. 입력한 모든 명령 줄 인자는 sys.argv에 추가됩니다. 또한 다음 사용자 정의 실행을 위해 상자에 다시 나타납니다. 일반적인 셸 메인 모듈 재시작을 억제할 수도 있습니다. (Contributed by Cheryl Sabella, Terry Jan Reedy, and others in <a class="reference external" href="https://bugs.python.org/issue5680">bpo-5680</a> and <a class="reference external" href="https://bugs.python.org/issue37627">bpo-37627</a>.)</p>
<p>IDLE 편집기 창에 선택적인 줄 번호를 추가했습니다. 창은 구성 대화 상자의 General 탭에서 설정하지 않는 한 줄 번호 없이 열립니다. 기존 창의 줄 번호는 옵션 메뉴에서 표시되거나 숨겨집니다. (Contributed by Tal Einat and Saimadhav Heblikar in <a class="reference external" href="https://bugs.python.org/issue17535">bpo-17535</a>.)</p>
<p>OS 네이티브 인코딩은 이제 파이썬 문자열과 Tcl 객체 간 변환에 사용됩니다. 이를 통해 IDLE은 그림 이모티콘과 기타 BMP가 아닌 문자를 사용할 수 있습니다. 이러한 문자는 표시하거나 클립 보드에 복사하고 클립보드에서 붙여넣을 수 있습니다. 문자열을 Tcl에서 파이썬으로 변환했다가 되돌리는 것은 이제 실패하지 않습니다. (많은 사람이 8년 동안 이 작업을 했지만, 마침내 Serhiy Storchaka가 이 문제를 <a class="reference external" href="https://bugs.python.org/issue13153">bpo-13153</a>에서 해결했습니다.)</p>
<p>3.8.1의 새로운 기능:</p>
<p>커서 깜박임을 토글하는 옵션을 추가합니다. (Contributed by Zackery Spytz in <a class="reference external" href="https://bugs.python.org/issue4603">bpo-4603</a>.)</p>
<p>이스케이프 키는 이제 IDLE 완성(completion) 창을 닫습니다. (Contributed by Johnny Najera in <a class="reference external" href="https://bugs.python.org/issue38944">bpo-38944</a>.)</p>
<p>위의 변경 사항은 3.7 유지 보수 릴리스로 역 이식되었습니다.</p>
<p>모듈 이름 완성 리스트에 키워드를 추가합니다. (Contributed by Terry J. Reedy in <a class="reference external" href="https://bugs.python.org/issue37765">bpo-37765</a>.)</p>
</div>
<div class="section" id="inspect">
<h3>inspect<a class="headerlink" href="#inspect" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> 함수는 이제 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 어트리뷰트가 값이 독스트링인 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>면 독스트링을 찾을 수 있습니다. 이것은 <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a>, <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 및 <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>에 대해 이미 가지고 있는 것과 유사한 문서화 옵션을 제공합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AudioClip</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bit_rate&#39;</span><span class="p">:</span> <span class="s1">&#39;expressed in kilohertz to one decimal place&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="s1">&#39;in seconds, rounded up to an integer&#39;</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bit_rate</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_rate</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">bit_rate</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue36326">bpo-36326</a>.)</p>
</div>
<div class="section" id="io">
<h3>io<a class="headerlink" href="#io" title="제목 주소">¶</a></h3>
<p>개발 모드(<a class="reference internal" href="../using/cmdline.html#id5"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">env</span></code>)와 디버그 빌드에서, <code class="docutils literal notranslate"><span class="pre">close()</span></code> 메서드가 실패하면 <a class="reference internal" href="../library/io.html#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.IOBase</span></code></a> 파이널라이저가 이제 예외를 로그 합니다. 릴리스 빌드에서는 기본적으로 예외가 조용히 무시됩니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue18748">bpo-18748</a>.)</p>
</div>
<div class="section" id="itertools">
<h3>itertools<a class="headerlink" href="#itertools" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/itertools.html#itertools.accumulate" title="itertools.accumulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.accumulate()</span></code></a> 함수는 초깃값을 지정하기 위한 옵션 <em>initial</em> 키워드 인자를 추가했습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">accumulate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">1000</span><span class="p">))</span>
<span class="go">[1000, 1010, 1015, 1045, 1060]</span>
</pre></div>
</div>
<p>(Contributed by Lisa Roach in <a class="reference external" href="https://bugs.python.org/issue34659">bpo-34659</a>.)</p>
</div>
<div class="section" id="json-tool">
<h3>json.tool<a class="headerlink" href="#json-tool" title="제목 주소">¶</a></h3>
<p>모든 입력 행을 별도의 JSON 객체로 구문 분석하는 <code class="docutils literal notranslate"><span class="pre">--json-lines</span></code> 옵션을 추가했습니다. (Contributed by Weipeng Hong in <a class="reference external" href="https://bugs.python.org/issue31553">bpo-31553</a>.)</p>
</div>
<div class="section" id="logging">
<h3>logging<a class="headerlink" href="#logging" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/logging.html#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">logging.basicConfig()</span></code></a>에 <em>force</em> 키워드 인자를 추가했습니다. 참으로 설정하면, 루트 로거에 연결된 기존 처리기는 다른 인자로 지정된 구성을 수행하기 전에 제거되고 닫힙니다.</p>
<p>이것은 오랜 문제를 해결합니다. 일단 로거나 <em>basicConfig()</em>가 호출되면, <em>basicConfig()</em>에 대한 후속 호출은 조용히 무시되었습니다. 이로 인해 대화식 프롬프트나 Jupyter 노트북을 사용하여 다양한 로깅 구성 옵션을 갱신, 실험 또는 가르치기가 어려웠습니다.</p>
<p>(Suggested by Raymond Hettinger, implemented by Dong-hee Na, and
reviewed by Vinay Sajip in <a class="reference external" href="https://bugs.python.org/issue33897">bpo-33897</a>.)</p>
</div>
<div class="section" id="math">
<h3>math<a class="headerlink" href="#math" title="제목 주소">¶</a></h3>
<p>두 점 사이의 유클리드 거리를 계산하기 위한 새로운 함수 <a class="reference internal" href="../library/math.html#math.dist" title="math.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.dist()</span></code></a>가 추가되었습니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue33089">bpo-33089</a>.)</p>
<p>다중 차원을 처리하도록 <a class="reference internal" href="../library/math.html#math.hypot" title="math.hypot"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.hypot()</span></code></a> 함수를 확장했습니다. 이전에는, 2-D 케이스 만 지원했습니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue33089">bpo-33089</a>.)</p>
<p>'start' 값(기본값: 1)과 숫자의 이터러블의 곱을 반환하는 <a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>의 대응 물인 새 함수 <a class="reference internal" href="../library/math.html#math.prod" title="math.prod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.prod()</span></code></a>를 추가했습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prior</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">likelihoods</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.625</span><span class="p">,</span> <span class="mf">0.84</span><span class="p">,</span> <span class="mf">0.30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="go">0.126</span>
</pre></div>
</div>
<p>(Contributed by Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue35606">bpo-35606</a>.)</p>
<p>새로운 조합 함수(combinatoric functions) <a class="reference internal" href="../library/math.html#math.perm" title="math.perm"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.perm()</span></code></a>와 <a class="reference internal" href="../library/math.html#math.comb" title="math.comb"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.comb()</span></code></a>가 추가되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>    <span class="c1"># 10개 중에서 한 번에 3개를 취한 순열</span>
<span class="go">720</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>    <span class="c1"># 10개 중에서 한 번에 3개를 취한 조합</span>
<span class="go">120</span>
</pre></div>
</div>
<p>(Contributed by Yash Aggarwal, Keller Fuchs, Serhiy Storchaka, and Raymond
Hettinger in <a class="reference external" href="https://bugs.python.org/issue37128">bpo-37128</a>, <a class="reference external" href="https://bugs.python.org/issue37178">bpo-37178</a>, and <a class="reference external" href="https://bugs.python.org/issue35431">bpo-35431</a>.)</p>
<p>정수 제곱근을 부동 소수점으로 변환하지 않고 정확하게 계산하기 위한 새로운 함수 <a class="reference internal" href="../library/math.html#math.isqrt" title="math.isqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.isqrt()</span></code></a>를 추가했습니다. 새 함수는 제한 없이 큰 정수를 지원합니다. <code class="docutils literal notranslate"><span class="pre">floor(sqrt(n))</span></code> 보다 빠르지만 <a class="reference internal" href="../library/math.html#math.sqrt" title="math.sqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sqrt()</span></code></a> 보다 느립니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="mi">650320427</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isqrt</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>         <span class="c1"># 정확합니다</span>
<span class="go">650320426</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">floor</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1"># 부정확합니다</span>
<span class="go">650320427</span>
</pre></div>
</div>
<p>(Contributed by Mark Dickinson in <a class="reference external" href="https://bugs.python.org/issue36887">bpo-36887</a>.)</p>
<p>함수 <a class="reference internal" href="../library/math.html#math.factorial" title="math.factorial"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.factorial()</span></code></a>은 더는 int-류가 아닌 인자를 받아들이지 않습니다. (Contributed by Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue33083">bpo-33083</a>.)</p>
</div>
<div class="section" id="mmap">
<h3>mmap<a class="headerlink" href="#mmap" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/mmap.html#mmap.mmap" title="mmap.mmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">mmap.mmap</span></code></a> 클래스에는 이제 <code class="docutils literal notranslate"><span class="pre">madvise()</span></code> 시스템 호출에 액세스하는 <a class="reference internal" href="../library/mmap.html#mmap.mmap.madvise" title="mmap.mmap.madvise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">madvise()</span></code></a> 메서드가 있습니다. (Contributed by Zackery Spytz in <a class="reference external" href="https://bugs.python.org/issue32941">bpo-32941</a>.)</p>
</div>
<div class="section" id="multiprocessing">
<h3>multiprocessing<a class="headerlink" href="#multiprocessing" title="제목 주소">¶</a></h3>
<p>새로운 <a class="reference internal" href="../library/multiprocessing.shared_memory.html#module-multiprocessing.shared_memory" title="multiprocessing.shared_memory: Provides shared memory for direct access across processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.shared_memory</span></code></a> 모듈을 추가했습니다. (Contributed by Davin Potts in <a class="reference external" href="https://bugs.python.org/issue35813">bpo-35813</a>.)</p>
<p>macOS에서, 이제 기본적으로 <em>spawn</em> 시작 방법이 사용됩니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue33725">bpo-33725</a>.)</p>
</div>
<div class="section" id="os">
<h3>os<a class="headerlink" href="#os" title="제목 주소">¶</a></h3>
<p>확장 모듈을 임포트 하거나 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>를 사용하여 DLL을 로드할 때 네이티브 종속성에 대한 추가 검색 경로를 제공하기 위해 윈도우에서 새로운 함수 <a class="reference internal" href="../library/os.html#os.add_dll_directory" title="os.add_dll_directory"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_dll_directory()</span></code></a>가 추가되었습니다. (Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue36085">bpo-36085</a>.)</p>
<p>새로운 <a class="reference internal" href="../library/os.html#os.memfd_create" title="os.memfd_create"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.memfd_create()</span></code></a> 함수가 추가되어 <code class="docutils literal notranslate"><span class="pre">memfd_create()</span></code> 시스템 호출을 감쌉니다. (Contributed by Zackery Spytz and Christian Heimes in <a class="reference external" href="https://bugs.python.org/issue26836">bpo-26836</a>.)</p>
<p>윈도우에서 재해석 지점(reparse points - 심볼릭 링크와 디렉터리 정션(directory junction)을 포함합니다)을 처리하기 위한 많은 수동 논리가 운영 체제로 위임되었습니다. 특히, <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>은 이제 운영 체제에서 지원하는 모든 것을 탐색하지만, <a class="reference internal" href="../library/os.html#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.lstat()</span></code></a>은 &quot;이름 서로게이트(name surrogates)&quot;로 식별되는 재해석 지점만 열고 다른 이름은 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>처럼 엽니다. 모든 경우에, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stat_result.st_mode</span></code>는 심볼릭 링크에만 <code class="docutils literal notranslate"><span class="pre">S_IFLNK</span></code>를 설정하고 다른 유형의 재해석 지점에는 설정하지 않습니다. 다른 유형의 재해석 지점을 식별하려면, 새 <code class="xref py py-attr docutils literal notranslate"><span class="pre">stat_result.st_reparse_tag</span></code> 어트리뷰트를 확인하십시오.</p>
<p>윈도우에서, <a class="reference internal" href="../library/os.html#os.readlink" title="os.readlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.readlink()</span></code></a>는 이제 디렉터리 정션을 읽을 수 있습니다. <a class="reference internal" href="../library/os.path.html#os.path.islink" title="os.path.islink"><code class="xref py py-func docutils literal notranslate"><span class="pre">islink()</span></code></a>는 디렉터리 정션에 대해 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환함에 유의하십시오. 따라서 <code class="docutils literal notranslate"><span class="pre">islink</span></code>를 먼저 확인하는 코드는 정션을 계속 디렉터리로 처리하지만, <a class="reference internal" href="../library/os.html#os.readlink" title="os.readlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.readlink()</span></code></a>의 에러를 처리하는 코드는 정션을 이제 링크로 처리할 수 있습니다.</p>
<p>(Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue37834">bpo-37834</a>.)</p>
</div>
<div class="section" id="os-path">
<h3>os.path<a class="headerlink" href="#os-path" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/os.path.html#os.path.exists" title="os.path.exists"><code class="xref py py-func docutils literal notranslate"><span class="pre">exists()</span></code></a>, <a class="reference internal" href="../library/os.path.html#os.path.lexists" title="os.path.lexists"><code class="xref py py-func docutils literal notranslate"><span class="pre">lexists()</span></code></a>, <a class="reference internal" href="../library/os.path.html#os.path.isdir" title="os.path.isdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">isdir()</span></code></a>, <a class="reference internal" href="../library/os.path.html#os.path.isfile" title="os.path.isfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfile()</span></code></a>, <a class="reference internal" href="../library/os.path.html#os.path.islink" title="os.path.islink"><code class="xref py py-func docutils literal notranslate"><span class="pre">islink()</span></code></a> 및 <a class="reference internal" href="../library/os.path.html#os.path.ismount" title="os.path.ismount"><code class="xref py py-func docutils literal notranslate"><span class="pre">ismount()</span></code></a>와 같은 불리언 결과를 반환하는 <a class="reference internal" href="../library/os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a> 함수는 이제 OS 수준에서 표현할 수 없는 문자나 바이트를 포함하는 경로에 대해 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>나 그것의 서브 클래스 <a class="reference internal" href="../library/exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 와 <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue33721">bpo-33721</a>.).</p>
<p>윈도우에서 <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal notranslate"><span class="pre">expanduser()</span></code></a>는 이제 <span class="target" id="index-63"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">USERPROFILE</span></code> 환경 변수를 선호하며 일반적으로 일반 사용자 계정에 설정되지 않는 <span class="target" id="index-64"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code>을 사용하지 않습니다. (Contributed by Anthony Sottile in <a class="reference external" href="https://bugs.python.org/issue36264">bpo-36264</a>.)</p>
<p>윈도우에서 <a class="reference internal" href="../library/os.path.html#os.path.isdir" title="os.path.isdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">isdir()</span></code></a>은 존재하지 않는 디렉터리에 대한 링크에 대해 더는 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하지 않습니다.</p>
<p>윈도우에서 <a class="reference internal" href="../library/os.path.html#os.path.realpath" title="os.path.realpath"><code class="xref py py-func docutils literal notranslate"><span class="pre">realpath()</span></code></a>는 이제 심볼릭 링크와 디렉터리 정션을 포함하는 재해석 지점을 결정(resolve)합니다.</p>
<p>(Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue37834">bpo-37834</a>.)</p>
</div>
<div class="section" id="pathlib">
<h3>pathlib<a class="headerlink" href="#pathlib" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/pathlib.html#pathlib.Path.exists" title="pathlib.Path.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_dir" title="pathlib.Path.is_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_dir()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_file" title="pathlib.Path.is_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_file()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_mount" title="pathlib.Path.is_mount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_mount()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_symlink" title="pathlib.Path.is_symlink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_symlink()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_block_device" title="pathlib.Path.is_block_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_block_device()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_char_device" title="pathlib.Path.is_char_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_char_device()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_fifo" title="pathlib.Path.is_fifo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_fifo()</span></code></a>, <a class="reference internal" href="../library/pathlib.html#pathlib.Path.is_socket" title="pathlib.Path.is_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_socket()</span></code></a>과 같은 불리언 결과를 반환하는 <a class="reference internal" href="../library/pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> 메서드는 OS 수준에서 표현할 수 없는 문자가 포함된 경로에 대해 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>나 그것의 서브 클래스 <a class="reference internal" href="../library/exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue33721">bpo-33721</a>.)</p>
<p>경로를 가리키는 하드 링크를 만드는 <a class="reference internal" href="../library/pathlib.html#pathlib.Path.link_to" title="pathlib.Path.link_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pathlib.Path.link_to()</span></code></a>를 추가했습니다. (Contributed by Joannah Nanjekye in <a class="reference external" href="https://bugs.python.org/issue26978">bpo-26978</a>)</p>
</div>
<div class="section" id="pickle">
<h3>pickle<a class="headerlink" href="#pickle" title="제목 주소">¶</a></h3>
<p>C 최적화된 <a class="reference internal" href="../library/pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>를 서브 클래싱하는 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 확장은 이제 특수 <a class="reference internal" href="../library/pickle.html#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> 메서드를 정의하여 함수와 클래스의 피클링 로직을 재정의할 수 있습니다. (Contributed by Pierre Glaser and Olivier Grisel in <a class="reference external" href="https://bugs.python.org/issue35900">bpo-35900</a>.)</p>
</div>
<div class="section" id="plistlib">
<h3>plistlib<a class="headerlink" href="#plistlib" title="제목 주소">¶</a></h3>
<p>새로운 <a class="reference internal" href="../library/plistlib.html#plistlib.UID" title="plistlib.UID"><code class="xref py py-class docutils literal notranslate"><span class="pre">plistlib.UID</span></code></a>가 추가되었으며 NSKeyedArchiver 인코딩된 바이너리 plist를 읽고 쓰는 지원을 활성화했습니다. (Contributed by Jon Janzen in <a class="reference external" href="https://bugs.python.org/issue26707">bpo-26707</a>.)</p>
</div>
<div class="section" id="pprint">
<h3>pprint<a class="headerlink" href="#pprint" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/pprint.html#module-pprint" title="pprint: Data pretty printer."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pprint</span></code></a> 모듈은 여러 함수에 <em>sort_dicts</em> 매개 변수를 추가했습니다. 기본적으로, 이러한 함수는 렌더링이나 인쇄 전에 딕셔너리를 계속 정렬합니다. 그러나, <em>sort_dicts</em>가 거짓으로 설정되면, 딕셔너리는 키가 삽입된 순서를 유지합니다. 디버깅하는 동안 JSON 입력과 비교하는 데 유용 할 수 있습니다.</p>
<p>또한, <a class="reference internal" href="../library/pprint.html#pprint.pprint" title="pprint.pprint"><code class="xref py py-func docutils literal notranslate"><span class="pre">pprint.pprint()</span></code></a>와 유사하지만 <em>sort_dicts</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 기본 설정된 새로운 편의 함수 <a class="reference internal" href="../library/pprint.html#pprint.pp" title="pprint.pp"><code class="xref py py-func docutils literal notranslate"><span class="pre">pprint.pp()</span></code></a>가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">pp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="s1">&#39;input.txt&#39;</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s1">&#39;filter&#39;</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">&#39;output.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pp</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>                  <span class="c1"># 원래 순서</span>
<span class="go">{&#39;source&#39;: &#39;input.txt&#39;,</span>
<span class="go"> &#39;operation&#39;: &#39;filter&#39;,</span>
<span class="go"> &#39;destination&#39;: &#39;output.txt&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>              <span class="c1"># 알파벳 순으로 정렬된 키</span>
<span class="go">{&#39;destination&#39;: &#39;output.txt&#39;,</span>
<span class="go"> &#39;operation&#39;: &#39;filter&#39;,</span>
<span class="go"> &#39;source&#39;: &#39;input.txt&#39;}</span>
</pre></div>
</div>
<p>(Contributed by Rémi Lapeyre in <a class="reference external" href="https://bugs.python.org/issue30670">bpo-30670</a>.)</p>
</div>
<div class="section" id="py-compile">
<h3>py_compile<a class="headerlink" href="#py-compile" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/py_compile.html#py_compile.compile" title="py_compile.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">py_compile.compile()</span></code></a>은 이제 조용한 모드를 지원합니다. (Contributed by Joannah Nanjekye in <a class="reference external" href="https://bugs.python.org/issue22640">bpo-22640</a>.)</p>
</div>
<div class="section" id="shlex">
<h3>shlex<a class="headerlink" href="#shlex" title="제목 주소">¶</a></h3>
<p>새 <a class="reference internal" href="../library/shlex.html#shlex.join" title="shlex.join"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.join()</span></code></a> 함수는 <a class="reference internal" href="../library/shlex.html#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.split()</span></code></a>의 역함수로 작동합니다. (Contributed by Bo Bayles in <a class="reference external" href="https://bugs.python.org/issue32102">bpo-32102</a>.)</p>
</div>
<div class="section" id="shutil">
<h3>shutil<a class="headerlink" href="#shutil" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copytree()</span></code></a>는 이제 새로운 <code class="docutils literal notranslate"><span class="pre">dirs_exist_ok</span></code> 키워드 인자를 받아들입니다. (Contributed by Josh Bronson in <a class="reference external" href="https://bugs.python.org/issue20849">bpo-20849</a>.)</p>
<p><a class="reference internal" href="../library/shutil.html#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.make_archive()</span></code></a>는 이제 이식성과 표준 적합성을 향상하기 위해 새로운 아카이브에 최신 pax (POSIX.1-2001) 형식을 기본으로 합니다, <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈에 대한 해당 변경 사항을 상속했습니다. (Contributed by C.A.M. Gerlach in <a class="reference external" href="https://bugs.python.org/issue30661">bpo-30661</a>.)</p>
<p>윈도우에서 <a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.rmtree()</span></code></a>는 이제 그 내용을 먼저 재귀적으로 삭제하지 않고 디렉터리 정션을 삭제합니다. (Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue37834">bpo-37834</a>.)</p>
</div>
<div class="section" id="socket">
<h3>socket<a class="headerlink" href="#socket" title="제목 주소">¶</a></h3>
<p>같은 소켓에서 IPv4와 IPv6 연결을 모두 받아들이는 것을 포함하여 일반적으로 서버 소켓을 만들 때 필요한 작업을 자동화하는 <a class="reference internal" href="../library/socket.html#socket.create_server" title="socket.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>와 <a class="reference internal" href="../library/socket.html#socket.has_dualstack_ipv6" title="socket.has_dualstack_ipv6"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_dualstack_ipv6()</span></code></a> 편리 함수가 추가되었습니다. (Contributed by Giampaolo Rodolà in <a class="reference external" href="https://bugs.python.org/issue17561">bpo-17561</a>.)</p>
<p><a class="reference internal" href="../library/socket.html#socket.if_nameindex" title="socket.if_nameindex"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.if_nameindex()</span></code></a>, <a class="reference internal" href="../library/socket.html#socket.if_nametoindex" title="socket.if_nametoindex"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.if_nametoindex()</span></code></a> 및 <a class="reference internal" href="../library/socket.html#socket.if_indextoname" title="socket.if_indextoname"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.if_indextoname()</span></code></a> 함수가 윈도우에서 구현되었습니다. (Contributed by Zackery Spytz in <a class="reference external" href="https://bugs.python.org/issue37007">bpo-37007</a>.)</p>
</div>
<div class="section" id="ssl">
<h3>ssl<a class="headerlink" href="#ssl" title="제목 주소">¶</a></h3>
<p>TLS 1.3 포스트 핸드 셰이크 인증을 활성화하는 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.post_handshake_auth" title="ssl.SSLContext.post_handshake_auth"><code class="xref py py-attr docutils literal notranslate"><span class="pre">post_handshake_auth</span></code></a>와 시작하는 <a class="reference internal" href="../library/ssl.html#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify_client_post_handshake()</span></code></a>를 추가했습니다. (Contributed by Christian Heimes in <a class="reference external" href="https://bugs.python.org/issue34670">bpo-34670</a>.)</p>
</div>
<div class="section" id="statistics">
<h3>statistics<a class="headerlink" href="#statistics" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/statistics.html#statistics.mean" title="statistics.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.mean()</span></code></a>의 더 빠른 부동 소수점 변형으로 <a class="reference internal" href="../library/statistics.html#statistics.fmean" title="statistics.fmean"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.fmean()</span></code></a>을 추가했습니다. (Contributed by Raymond Hettinger and Steven D'Aprano in <a class="reference external" href="https://bugs.python.org/issue35904">bpo-35904</a>.)</p>
<p><a class="reference internal" href="../library/statistics.html#statistics.geometric_mean" title="statistics.geometric_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.geometric_mean()</span></code></a>을 추가했습니다 (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue27181">bpo-27181</a>.)</p>
<p>가장 빈번한 값의 리스트를 반환하는 <a class="reference internal" href="../library/statistics.html#statistics.multimode" title="statistics.multimode"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.multimode()</span></code></a>가 추가되었습니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue35892">bpo-35892</a>.)</p>
<p>데이터나 분포를 등분위 간격(equiprobable intervals)(예를 들어, 4분위 수(quattiles), 십분위 수(deciles) 또는 백분위 수(percentiles))으로 나누는 <a class="reference internal" href="../library/statistics.html#statistics.quantiles" title="statistics.quantiles"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.quantiles()</span></code></a>를 추가했습니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue36546">bpo-36546</a>.)</p>
<p>무작위 변수의 정규 분포를 만들고 조작하기 위한 도구인 <a class="reference internal" href="../library/statistics.html#statistics.NormalDist" title="statistics.NormalDist"><code class="xref py py-class docutils literal notranslate"><span class="pre">statistics.NormalDist</span></code></a>를 추가했습니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue36018">bpo-36018</a>.)</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span> <span class="o">=</span> <span class="n">NormalDist</span><span class="o">.</span><span class="n">from_samples</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span><span class="o">.</span><span class="n">mean</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span><span class="o">.</span><span class="n">stdev</span>
<span class="go">6.356099432828281</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># 3도 이하일 확률</span>
<span class="go">0.3184678262814532</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 7도와 10도가 될 상대적 가능성</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="n">temperature_feb</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">1.2039930378537762</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">el_niño</span> <span class="o">=</span> <span class="n">NormalDist</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span> <span class="o">+=</span> <span class="n">el_niño</span>        <span class="c1"># 기후 효과(엘니뇨)를 더합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span>
<span class="go">NormalDist(mu=10.0, sigma=6.830080526611674)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span> <span class="o">*</span> <span class="p">(</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span>      <span class="c1"># 화씨(Fahrenheit)로 변환합니다</span>
<span class="go">NormalDist(mu=50.0, sigma=12.294144947901014)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_feb</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>        <span class="c1"># 무작위 샘플을 만듭니다</span>
<span class="go">[7.672102882379219, 12.000027119750287, 4.647488369766392]</span>
</pre></div>
</div>
</div>
<div class="section" id="sys">
<h3>sys<a class="headerlink" href="#sys" title="제목 주소">¶</a></h3>
<p>&quot;발생시킬 수 없는 예외(unraisable exceptions)&quot; 처리 방법을 제어하기 위해 재정의할 수 있는 새로운 <a class="reference internal" href="../library/sys.html#sys.unraisablehook" title="sys.unraisablehook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.unraisablehook()</span></code></a> 함수를 추가했습니다. 예외가 발생했지만, 파이썬에서 처리할 방법이 없을 때 호출됩니다. 예를 들어, 파괴자(destructor)가 예외를 발생시키거나 가비지 수집(<a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a>) 중에. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36829">bpo-36829</a>.)</p>
</div>
<div class="section" id="tarfile">
<h3>tarfile<a class="headerlink" href="#tarfile" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈은 새로운 아카이브를 만들 때 이제 이전의 GNU 전용이 아닌 최신 pax (POSIX.1-2001) 형식을 기본값으로 사용합니다. 이것은 표준화되고 확장 가능한 형식으로 일관된 인코딩(UTF-8)을 사용하여 플랫폼 간 이식성을 개선하고, 몇 가지 다른 이점을 제공합니다. (Contributed by C.A.M. Gerlach in <a class="reference external" href="https://bugs.python.org/issue36268">bpo-36268</a>.)</p>
</div>
<div class="section" id="threading">
<h3>threading<a class="headerlink" href="#threading" title="제목 주소">¶</a></h3>
<p>잡히지 않은 <a class="reference internal" href="../library/threading.html#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.Thread.run()</span></code></a> 예외를 처리하는 새로운 <a class="reference internal" href="../library/threading.html#threading.excepthook" title="threading.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.excepthook()</span></code></a> 함수를 추가했습니다. 잡히지 않은 <a class="reference internal" href="../library/threading.html#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.Thread.run()</span></code></a> 예외가 처리되는 방식을 제어하기 위해 재정의될 수 있습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue1230540">bpo-1230540</a>.)</p>
<p>새로운 <a class="reference internal" href="../library/threading.html#threading.get_native_id" title="threading.get_native_id"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.get_native_id()</span></code></a> 함수와 <a class="reference internal" href="../library/threading.html#threading.Thread.native_id" title="threading.Thread.native_id"><code class="xref py py-data docutils literal notranslate"><span class="pre">native_id</span></code></a> 어트리뷰트를 <a class="reference internal" href="../library/threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a> 클래스에 추가합니다. 이것들은 커널이 할당한 현재 스레드의 네이티브 정수 스레드 ID를 반환합니다. 이 기능은 특정 플랫폼에서만 사용할 수 있습니다, 자세한 내용은 <a class="reference internal" href="../library/threading.html#threading.get_native_id" title="threading.get_native_id"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_native_id</span></code></a>를 참조하십시오. (Contributed by Jake Tesler in <a class="reference external" href="https://bugs.python.org/issue36084">bpo-36084</a>.)</p>
</div>
<div class="section" id="tokenize">
<h3>tokenize<a class="headerlink" href="#tokenize" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tokenize</span></code></a> 모듈은 이제 후행 줄 넘김이 없는 입력을 제공할 때 묵시적으로 <code class="docutils literal notranslate"><span class="pre">NEWLINE</span></code> 토큰을 출력합니다. 이 동작은 이제 C 토크나이저가 내부적으로 수행하는 것과 일치합니다. (Contributed by Ammar Askar in <a class="reference external" href="https://bugs.python.org/issue33899">bpo-33899</a>.)</p>
</div>
<div class="section" id="tkinter">
<h3>tkinter<a class="headerlink" href="#tkinter" title="제목 주소">¶</a></h3>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">tkinter.Spinbox</span></code> 클래스에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">selection_from()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">selection_present()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">selection_range()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">selection_to()</span></code> 메서드를 추가했습니다. (Contributed by Juliette Monsel in <a class="reference external" href="https://bugs.python.org/issue34829">bpo-34829</a>.)</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">tkinter.Canvas</span></code> 클래스에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">moveto()</span></code> 메서드를 추가했습니다. (Contributed by Juliette Monsel in <a class="reference external" href="https://bugs.python.org/issue23831">bpo-23831</a>.)</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">tkinter.PhotoImage</span></code> 클래스는 이제 <code class="xref py py-meth docutils literal notranslate"><span class="pre">transparency_get()</span></code>과 <code class="xref py py-meth docutils literal notranslate"><span class="pre">transparency_set()</span></code> 메서드를 갖습니다. (Contributed by Zackery Spytz in <a class="reference external" href="https://bugs.python.org/issue25451">bpo-25451</a>.)</p>
</div>
<div class="section" id="time">
<h3>time<a class="headerlink" href="#time" title="제목 주소">¶</a></h3>
<p>macOS 10.12를 위한 새로운 시계 <a class="reference internal" href="../library/time.html#time.CLOCK_UPTIME_RAW" title="time.CLOCK_UPTIME_RAW"><code class="xref py py-data docutils literal notranslate"><span class="pre">CLOCK_UPTIME_RAW</span></code></a>가 추가되었습니다. (Contributed by Joannah Nanjekye in <a class="reference external" href="https://bugs.python.org/issue35702">bpo-35702</a>.)</p>
</div>
<div class="section" id="typing">
<h3>typing<a class="headerlink" href="#typing" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 모듈은 몇 가지 새로운 기능을 통합했습니다:</p>
<ul>
<li><p>키별 형이 있는 딕셔너리 형. <span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>와 <a class="reference internal" href="../library/typing.html#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a>를 참조하십시오. TypedDict는 문자열 키만 사용합니다. 기본적으로, 모든 키가 있어야 합니다. 키를 선택적으로 만들려면 &quot;total=False&quot;를 지정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Location</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">lat_long</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="n">grid_square</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">xy_coordinate</span><span class="p">:</span> <span class="nb">tuple</span>
</pre></div>
</div>
</li>
<li><p>리터럴 형. <span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>과 <a class="reference internal" href="../library/typing.html#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Literal</span></code></a>을 참조하십시오. Literal 형은 매개 변수나 반환 값이 하나 이상의 특정 리터럴 값으로 제한됨을 나타냅니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">port</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;connected&#39;</span><span class="p">,</span> <span class="s1">&#39;disconnected&#39;</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p>&quot;최종(final)&quot; 변수, 함수, 메서드 및 클래스. <span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>, <a class="reference internal" href="../library/typing.html#typing.Final" title="typing.Final"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Final</span></code></a> 및 <a class="reference internal" href="../library/typing.html#typing.final" title="typing.final"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.final()</span></code></a>을 참조하십시오. final 한정자는 정적 형 검사기에 서브 클래싱, 재정의 또는 재대입을 제한하도록 지시합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.1415926536</span>
</pre></div>
</div>
</li>
<li><p>프로토콜 정의. <span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>, <a class="reference internal" href="../library/typing.html#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Protocol</span></code></a> 및 <a class="reference internal" href="../library/typing.html#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.runtime_checkable()</span></code></a>을 참조하십시오. <a class="reference internal" href="../library/typing.html#typing.SupportsInt" title="typing.SupportsInt"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.SupportsInt</span></code></a>와 같은 간단한 ABC는 이제 <code class="docutils literal notranslate"><span class="pre">Protocol</span></code> 서브 클래스입니다.</p></li>
<li><p>새 프로토콜 클래스 <a class="reference internal" href="../library/typing.html#typing.SupportsIndex" title="typing.SupportsIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.SupportsIndex</span></code></a>.</p></li>
<li><p>새 함수 <a class="reference internal" href="../library/typing.html#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_origin()</span></code></a>과 <a class="reference internal" href="../library/typing.html#typing.get_args" title="typing.get_args"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_args()</span></code></a>.</p></li>
</ul>
</div>
<div class="section" id="unicodedata">
<h3>unicodedata<a class="headerlink" href="#unicodedata" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 모듈은 <a class="reference external" href="http://blog.unicode.org/2019/05/unicode-12-1-en.html">유니코드 12.1.0</a> 릴리스를 사용하도록 업그레이드되었습니다.</p>
<p>새 함수 <a class="reference internal" href="../library/unicodedata.html#unicodedata.is_normalized" title="unicodedata.is_normalized"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_normalized()</span></code></a>를 문자열이 특정 정규화 형식인지 확인하는 데 사용할 수 있습니다. 종종 실제로 문자열을 정규화하는 것보다 훨씬 빠릅니다. (Contributed by Max Belanger, David Euresti, and Greg Price in <a class="reference external" href="https://bugs.python.org/issue32285">bpo-32285</a> and <a class="reference external" href="https://bugs.python.org/issue37966">bpo-37966</a>).</p>
</div>
<div class="section" id="unittest">
<h3>unittest<a class="headerlink" href="#unittest" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a>의 비동기 버전을 지원하는 <a class="reference internal" href="../library/unittest.mock.html#unittest.mock.AsyncMock" title="unittest.mock.AsyncMock"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncMock</span></code></a>이 추가되었습니다. 테스트를 위해 적절한 새로운 assert 함수들이 추가되었습니다. (Contributed by Lisa Roach in <a class="reference external" href="https://bugs.python.org/issue26467">bpo-26467</a>).</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code>과 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a>에 대한 정리를 지원하기 위해 unittest에 <a class="reference internal" href="../library/unittest.html#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> 과 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a>를 추가했습니다. (Contributed by Lisa Roach in <a class="reference external" href="https://bugs.python.org/issue24412">bpo-24412</a>.)</p>
<p>여러 mock assert 함수는 이제 실패 시 실제 호출의 리스트도 인쇄합니다. (Contributed by Petter Strandmark in <a class="reference external" href="https://bugs.python.org/issue35047">bpo-35047</a>.)</p>
<p><a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 모듈은 <a class="reference internal" href="../library/unittest.html#unittest.IsolatedAsyncioTestCase" title="unittest.IsolatedAsyncioTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.IsolatedAsyncioTestCase</span></code></a>를 통해 코루틴을 테스트 케이스로 사용하는 지원을 얻었습니다. (Contributed by Andrew Svetlov in <a class="reference external" href="https://bugs.python.org/issue32972">bpo-32972</a>.)</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>


<span class="k">class</span> <span class="nc">TestRequest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">IsolatedAsyncioTestCase</span><span class="p">):</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncSetUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncConnection</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">test_get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://example.com&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncTearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="venv">
<h3>venv<a class="headerlink" href="#venv" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>는 이제 PowerShell Core 6.1에서 가상 환경을 활성화하기 위한 모든 플랫폼에 <code class="docutils literal notranslate"><span class="pre">Activate.ps1</span></code> 스크립트를 포함합니다. (Contributed by Brett Cannon in <a class="reference external" href="https://bugs.python.org/issue32718">bpo-32718</a>.)</p>
</div>
<div class="section" id="weakref">
<h3>weakref<a class="headerlink" href="#weakref" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/weakref.html#weakref.proxy" title="weakref.proxy"><code class="xref py py-func docutils literal notranslate"><span class="pre">weakref.proxy()</span></code></a>에 의해 반환된 프락시 객체는 이제 다른 숫자 연산자에 더해 행렬 곱셈 연산자 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>을 지원합니다. (Contributed by Mark Dickinson in <a class="reference external" href="https://bugs.python.org/issue36669">bpo-36669</a>.)</p>
</div>
<div class="section" id="xml">
<h3>xml<a class="headerlink" href="#xml" title="제목 주소">¶</a></h3>
<p>DTD 및 외부 엔티티 조회에 대한 완화로서, <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a>과 <a class="reference internal" href="../library/xml.sax.html#module-xml.sax" title="xml.sax: Package containing SAX2 base classes and convenience functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.sax</span></code></a> 모듈은 기본적으로 더는 외부 엔티티를 처리하지 않습니다. (Contributed by Christian Heimes in <a class="reference external" href="https://bugs.python.org/issue17239">bpo-17239</a>.)</p>
<p><a class="reference internal" href="../library/xml.etree.elementtree.html#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 모듈의 <code class="docutils literal notranslate"><span class="pre">.find*()</span></code> 메서드는 이름 공간을 무시하는 <code class="docutils literal notranslate"><span class="pre">{*}tag</span></code>와 지정된 이름 공간의 모든 태그를 반환하는 <code class="docutils literal notranslate"><span class="pre">{namespace}*</span></code>와 같은 와일드카드 검색을 지원합니다. (Contributed by Stefan Behnel in <a class="reference external" href="https://bugs.python.org/issue28238">bpo-28238</a>.)</p>
<p><a class="reference internal" href="../library/xml.etree.elementtree.html#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 모듈은 C14N 2.0을 구현하는 새로운 함수 <code class="xref py py-func docutils literal notranslate"><span class="pre">–xml.etree.ElementTree.canonicalize()</span></code>를 제공합니다. (Contributed by Stefan Behnel in <a class="reference external" href="https://bugs.python.org/issue13611">bpo-13611</a>.)</p>
<p><a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">xml.etree.ElementTree.XMLParser</span></code></a>의 대상 객체는 새 콜백 메서드 <code class="docutils literal notranslate"><span class="pre">start_ns()</span></code>와 <code class="docutils literal notranslate"><span class="pre">end_ns()</span></code>를 통해 이름 공간 선언 이벤트를 수신할 수 있습니다. 또한, <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">xml.etree.ElementTree.TreeBuilder</span></code></a> 대상은 주석과 처리 명령어에 대한 이벤트를 처리하여 생성된 트리에 포함하도록 구성할 수 있습니다. (Contributed by Stefan Behnel in <a class="reference external" href="https://bugs.python.org/issue36676">bpo-36676</a> and <a class="reference external" href="https://bugs.python.org/issue36673">bpo-36673</a>.)</p>
</div>
<div class="section" id="xmlrpc">
<h3>xmlrpc<a class="headerlink" href="#xmlrpc" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/xmlrpc.client.html#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">xmlrpc.client.ServerProxy</span></code></a>는 이제 각 요청과 함께 보낼 HTTP 헤더의 시퀀스를 위한 선택적 <em>headers</em> 키워드 인자를 지원합니다. 무엇보다도, 기본 베이식 인증(basic authentication)에서 더 빠른 세션 인증(session authentication)으로 업그레이드 할 수 있도록 합니다. (Contributed by Cédric Krier in <a class="reference external" href="https://bugs.python.org/issue35153">bpo-35153</a>.)</p>
</div>
</div>
<div class="section" id="optimizations">
<h2>최적화<a class="headerlink" href="#optimizations" title="제목 주소">¶</a></h2>
<ul>
<li><p><a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 모듈은 이제 성능 향상을 위해 몇몇 경우 <a class="reference internal" href="../library/os.html#os.posix_spawn" title="os.posix_spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.posix_spawn()</span></code></a> 함수를 사용할 수 있습니다. 현재, 다음과 같은 조건이 모두 충족될 때 macOS와 리눅스(glibc 2.24 이상 사용)에서만 사용됩니다:</p>
<ul class="simple">
<li><p><em>close_fds</em>가 거짓입니다.</p></li>
<li><p><em>preexec_fn</em>, <em>pass_fds</em>, <em>cwd</em> 및 <em>start_new_session</em> 매개 변수가 설정되지 않았습니다.</p></li>
<li><p><em>executable</em> 경로가 디렉터리를 포함합니다.</p></li>
</ul>
<p>(Contributed by Joannah Nanjekye and Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35537">bpo-35537</a>.)</p>
</li>
<li><p><a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfile()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy2()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copytree()</span></code></a> 및 <a class="reference internal" href="../library/shutil.html#shutil.move" title="shutil.move"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.move()</span></code></a>는 파일을 보다 효율적으로 복사하기 위해 리눅스와 macOS에서 플랫폼별 &quot;빠른 복사(fast-copy)&quot; 시스템 호출을 사용합니다. &quot;빠른 복사&quot;는 복사 작업이 커널 내에서 발생하여 &quot;<code class="docutils literal notranslate"><span class="pre">outfd.write(infd.read())</span></code>&quot;처럼 파이썬에서 사용자 공간(userspace) 버퍼를 사용하지 않도록 합니다. 윈도우에서  <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfile()</span></code></a>은 더 큰 기본 버퍼 크기(16 KiB 대신 1 MiB)를 사용하고 <a class="reference internal" href="../library/shutil.html#shutil.copyfileobj" title="shutil.copyfileobj"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfileobj()</span></code></a>의 <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-func docutils literal notranslate"><span class="pre">memoryview()</span></code></a> 기반 변형이 사용됩니다. 같은 파티션 내에서 512 MiB 파일을 복사할 때 속도 개선은 리눅스에서는 약 +26%, macOS에서는 +50%, 윈도우에서는 +40%입니다. 또한, 훨씬 적은 CPU 사이클이 소모됩니다. <a class="reference internal" href="../library/shutil.html#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 절을 참조하십시오. (Contributed by Giampaolo Rodolà in <a class="reference external" href="https://bugs.python.org/issue33671">bpo-33671</a>.)</p></li>
<li><p><a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copytree()</span></code></a>는 <a class="reference internal" href="../library/os.html#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.scandir()</span></code></a> 함수를 사용하고 이것에 의존하는 모든 복사 함수는 캐시 된 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 값을 사용합니다. 8000개의 파일이 있는 디렉터리를 복사할 때 속도 개선은 리눅스에서는 +9%, 윈도우에서는 +20%, 윈도우 SMB 공유에서는 +30%입니다. 또한, <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 시스템 호출 수가 38% 감소하여 특히 <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copytree()</span></code></a>가 네트워크 파일 시스템에서 더 빠릅니다. (Contributed by Giampaolo Rodolà in <a class="reference external" href="https://bugs.python.org/issue33695">bpo-33695</a>.)</p></li>
<li><p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈의 기본 프로토콜은 이제 파이썬 3.4에서 처음 소개된 프로토콜 4입니다. 파이썬 3.0부터 사용 가능한 프로토콜 3보다 성능이 우수하고 크기가 작습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyGC_Head</span></code>에서 <code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> 멤버 하나를 삭제했습니다. 모든 GC 추적 객체(예를 들어, 튜플, 리스트, 딕셔너리)의 크기는 4 또는 8바이트 줄어듭니다. (Contributed by Inada Naoki in <a class="reference external" href="https://bugs.python.org/issue33597">bpo-33597</a>.)</p></li>
<li><p><a class="reference internal" href="../library/uuid.html#uuid.UUID" title="uuid.UUID"><code class="xref py py-class docutils literal notranslate"><span class="pre">uuid.UUID</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code>를 사용하여 메모리 사용량을 줄입니다. (Contributed by Wouter Bolsterlee and Tal Einat in <a class="reference external" href="https://bugs.python.org/issue30977">bpo-30977</a>)</p></li>
<li><p><a class="reference internal" href="../library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a>의 33% 성능 향상. 인자 처리를 최적화하고 튜플에 대한 하나의 음수가 아닌 정수 인덱스의 흔한 경우에 대한 빠른 경로를 추가했습니다 (표준 라이브러리의 일반적인 사용 사례입니다). (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue35664">bpo-35664</a>.)</p></li>
<li><p><a class="reference internal" href="../library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>에서의 필드 조회 속도 향상. 이제 두 배 이상 빨라져, 파이썬에서 가장 빠른 인스턴스 변수 조회 형식이 되었습니다. (Contributed by Raymond Hettinger, Pablo Galindo, and Joe Jevnik, Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue32492">bpo-32492</a>.)</p></li>
<li><p><a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 생성자는 입력 이터러블의 길이를 알 수 있으면 (입력이 <code class="docutils literal notranslate"><span class="pre">__len__</span></code>을 구현하면) 내부 항목 버퍼를 초과 할당하지 않습니다. 이것은 생성된 리스트가 평균 12% 작게 만듭니다. (Contributed by Raymond Hettinger and Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue33234">bpo-33234</a>.)</p></li>
<li><p>클래스 변수 쓰기 속도 두 배 향상. 특수하지 않은(non-dunder) 어트리뷰트가 갱신되었을 때, 슬롯 갱신을 위한 불필요한 호출이 있었습니다. (Contributed by Stefan Behnel, Pablo Galindo Salgado, Raymond Hettinger, Neil Schemenauer, and Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue36012">bpo-36012</a>.)</p></li>
<li><p>많은 내장 함수와 메서드에 전달된 인자를 변환하는 오버헤드 감소. 이것은 몇몇 간단한 내장 함수와 메서드 호출을 20--50%까지 가속합니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue23867">bpo-23867</a>, <a class="reference external" href="https://bugs.python.org/issue35582">bpo-35582</a> and <a class="reference external" href="https://bugs.python.org/issue36127">bpo-36127</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> 명령어는 이제 새로운 &quot;옵코드(opcode) 단위 캐시&quot; 메커니즘을 사용합니다. 이제 약 40% 빨라졌습니다. (Contributed by Yury Selivanov and Inada Naoki in <a class="reference external" href="https://bugs.python.org/issue26219">bpo-26219</a>.)</p></li>
</ul>
</div>
<div class="section" id="build-and-c-api-changes">
<h2>빌드와 C API 변경<a class="headerlink" href="#build-and-c-api-changes" title="제목 주소">¶</a></h2>
<ul>
<li><p>기본 <a class="reference internal" href="../library/sys.html#sys.abiflags" title="sys.abiflags"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.abiflags</span></code></a>는 빈 문자열이 되었습니다: pymalloc을 위한 <code class="docutils literal notranslate"><span class="pre">m</span></code> 플래그가 쓸모없게 되었으므로 (pymalloc을 포함하거나 포함하지 않는 빌드는 ABI 호환입니다) 제거되었습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36707">bpo-36707</a>.)</p>
<p>변경의 예:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">python3.8</span></code> 프로그램만 설치되고, <code class="docutils literal notranslate"><span class="pre">python3.8m</span></code> 프로그램은 사라졌습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">python3.8-config</span></code> 스크립트만 설치되고, <code class="docutils literal notranslate"><span class="pre">python3.8m-config</span></code> 스크립트는 사라졌습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m</span></code> 플래그는 동적 라이브러리 파일명의 접미사에서 제거되었습니다: 표준 라이브러리는 물론 PyPI에서 다운로드 한 것과 같은 제삼자 패키지에서 생성되고 설치된 확장 모듈. 예를 들어, 리눅스에서 파이썬 3.7 접미사 <code class="docutils literal notranslate"><span class="pre">.cpython-37m-x86_64-linux-gnu.so</span></code>는 파이썬 3.8에서 <code class="docutils literal notranslate"><span class="pre">.cpython-38-x86_64-linux-gnu.so</span></code>가 되었습니다.</p></li>
</ul>
</li>
<li><p>여러 종류의 API를 더 잘 구분할 수 있도록 헤더 파일이 재구성되었습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Include/*.h</span></code>는 이식성 있는 공용 안정 C API 여야 합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Include/cpython/*.h</span></code>는 CPython에 고유한 불안정한 C API 여야 합니다; <code class="docutils literal notranslate"><span class="pre">_Py</span></code>나 <code class="docutils literal notranslate"><span class="pre">_PY</span></code>로 시작하는 일부 비공개 API가 포함된 공개 API.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Include/internal/*.h</span></code>는 아주 CPython에 특정한 비공개 내부 C API입니다. 이 API는 과거 호환성 보증이 없어서, CPython 외부에서 사용해서는 안 됩니다. 이것은 함수를 호출하지 않고 CPython 내부에 액세스해야 하는 디버거나 프로파일과 같이 매우 구체적인 요구 사항을 위해서만 노출됩니다. 이 API는 이제 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code>에 의해 설치됩니다.</p></li>
</ul>
<p>(Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35134">bpo-35134</a> and <a class="reference external" href="https://bugs.python.org/issue35081">bpo-35081</a>, Eric Snow가 파이썬 3.7에서 시작한 작업.)</p>
</li>
<li><p>일부 매크로는 정적 인라인 함수로 변환되었습니다: 매개 변수 형과 반환형이 잘 정의되며, 매크로에 특정한 문제가 없으며, 변수는 지역 스코프를 갖습니다. 예:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a>, <a class="reference internal" href="../c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/refcounting.html#c.Py_XINCREF" title="Py_XINCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_XINCREF()</span></code></a>, <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_XDECREF()</span></code></a></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_INIT()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_INIT_VAR()</span></code></p></li>
<li><p>비공개 함수: <code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_GC_TRACK()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_GC_UNTRACK()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_Dealloc()</span></code></p></li>
</ul>
<p>(Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35059">bpo-35059</a>.)</p>
</li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyByteArray_Init()</span></code>와 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyByteArray_Fini()</span></code> 함수가 제거되었습니다. 파이썬 2.7.4와 파이썬 3.2.0부터 아무것도 하지 않고, 제한된 API(안정 ABI)에서 제외되었으며 문서로 만들어지지 않았습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35713">bpo-35713</a>.)</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyExceptionClass_Name()</span></code>의 결과는 이제 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> 대신 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> 형입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue33818">bpo-33818</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Modules/Setup.dist</span></code>와 <code class="docutils literal notranslate"><span class="pre">Modules/Setup</span></code>의 이중성이 제거되었습니다. 이전에는, CPython 소스 트리를 갱신할 때, 업스트림 변경 사항을 반영하기 위해 <code class="docutils literal notranslate"><span class="pre">Modules/Setup.dist</span></code>(소스 트리 내부)를 <code class="docutils literal notranslate"><span class="pre">Modules/Setup</span></code>(빌드 트리 내부)으로 수동으로 복사해야 했습니다. 이는 패키지 작성자에게는 작은 이점을 제공했지만, 파일 복사를 잊어버리면 빌드가 실패할 수 있어서 CPython 개발자들을 자주 귀찮게 만들었습니다.</p>
<p>이제 빌드 시스템은 항상 소스 트리 안의 <code class="docutils literal notranslate"><span class="pre">Modules/Setup</span></code>에서 읽습니다. 그 파일을 사용자 정의하고 싶은 사람들은 소스 트리에 대한 다른 변경과 마찬가지로 CPython의 git 포크나 패치 파일로 변경 사항을 유지하는 것이 좋습니다.</p>
<p>(Contributed by Antoine Pitrou in <a class="reference external" href="https://bugs.python.org/issue32430">bpo-32430</a>.)</p>
</li>
<li><p><a class="reference internal" href="../c-api/long.html#c.PyLong_AsLong" title="PyLong_AsLong"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_AsLong()</span></code></a>과 같은 파이썬 숫자를 C 정수로 변환하는 함수와, <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>처럼 <code class="docutils literal notranslate"><span class="pre">'i'</span></code>와 같은 정수 변환 포맷 단위로 인자를 구문 분석하는 함수는, 이제 사용할 수 있다면 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 대신 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 특수 메서드를 사용합니다. <code class="docutils literal notranslate"><span class="pre">__int__()</span></code> 메서드가 있지만 <code class="docutils literal notranslate"><span class="pre">__index__()</span></code> 메서드가 없는 객체(<a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>과 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code></a> 같은)에 대해서 폐지 경고가 발생합니다. <a class="reference internal" href="../c-api/number.html#c.PyNumber_Check" title="PyNumber_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Check()</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">__index__()</span></code>를 구현하는 객체에 대해 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다. <a class="reference internal" href="../c-api/number.html#c.PyNumber_Long" title="PyNumber_Long"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Long()</span></code></a>, <a class="reference internal" href="../c-api/number.html#c.PyNumber_Float" title="PyNumber_Float"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Float()</span></code></a> 및 <a class="reference internal" href="../c-api/float.html#c.PyFloat_AsDouble" title="PyFloat_AsDouble"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_AsDouble()</span></code></a>은 이제 사용할 수 있으면 <code class="docutils literal notranslate"><span class="pre">__index__()</span></code> 메서드를 사용합니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue36048">bpo-36048</a> and <a class="reference external" href="https://bugs.python.org/issue20092">bpo-20092</a>.)</p></li>
<li><p>힙에 할당된 형 객체는 이제 <a class="reference internal" href="../c-api/type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>이 아닌 <a class="reference internal" href="../c-api/allocation.html#c.PyObject_Init" title="PyObject_Init"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Init()</span></code></a>(그리고 이것과 평행한 매크로 <code class="docutils literal notranslate"><span class="pre">PyObject_INIT</span></code>)에서 참조 횟수를 증가시킵니다. 인스턴스 할당이나 할당 해제를 수정하는 형은 조정이 필요할 수 있습니다. (Contributed by Eddie Elizondo in <a class="reference external" href="https://bugs.python.org/issue35810">bpo-35810</a>.)</p></li>
<li><p>새 함수 <a class="reference internal" href="../c-api/code.html#c.PyCode_NewWithPosOnlyArgs" title="PyCode_NewWithPosOnlyArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_NewWithPosOnlyArgs()</span></code></a>는 <a class="reference internal" href="../c-api/code.html#c.PyCode_New" title="PyCode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_New()</span></code></a>처럼 코드 객체를 만들 수 있지만, 위치 전용 인자의 개수를 나타내는 <em>posonlyargcount</em> 매개 변수가 추가로 있습니다. (Contributed by Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue37221">bpo-37221</a>.)</p></li>
<li><p><a class="reference internal" href="../c-api/init.html#c.Py_SetPath" title="Py_SetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPath()</span></code></a>는 이제 <a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>을 프로그램 이름(<a class="reference internal" href="../c-api/init.html#c.Py_GetProgramName" title="Py_GetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramName()</span></code></a>) 대신 프로그램 전체 경로(<a class="reference internal" href="../c-api/init.html#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>)로 설정합니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue38234">bpo-38234</a>.)</p></li>
</ul>
</div>
<div class="section" id="deprecated">
<h2>폐지<a class="headerlink" href="#deprecated" title="제목 주소">¶</a></h2>
<ul>
<li><p>distutils <code class="docutils literal notranslate"><span class="pre">bdist_wininst</span></code> 명령은 이제 폐지되었습니다, 대신 <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code>(wheel 패키지)을 사용하십시오. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue37481">bpo-37481</a>.)</p></li>
<li><p><a class="reference internal" href="../library/xml.etree.elementtree.html#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 모듈의 폐지된 메서드 <code class="docutils literal notranslate"><span class="pre">getchildren()</span></code>과 <code class="docutils literal notranslate"><span class="pre">getiterator()</span></code>는 이제 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a> 대신 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 발생시킵니다. 이것들은 파이썬 3.9에서 제거될 것입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue29209">bpo-29209</a>.)</p></li>
<li><p><a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a>의 인스턴스가 아닌 객체를 <a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.loop.set_default_executor" title="asyncio.loop.set_default_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_default_executor()</span></code></a>로 전달하는 것은 폐지되었고 파이썬 3.9에서 금지될 것입니다. (Contributed by Elvis Pranskevichus in <a class="reference external" href="https://bugs.python.org/issue34075">bpo-34075</a>.)</p></li>
<li><p><a class="reference internal" href="../library/xml.dom.pulldom.html#xml.dom.pulldom.DOMEventStream" title="xml.dom.pulldom.DOMEventStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">xml.dom.pulldom.DOMEventStream</span></code></a>, <a class="reference internal" href="../library/wsgiref.html#wsgiref.util.FileWrapper" title="wsgiref.util.FileWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">wsgiref.util.FileWrapper</span></code></a> 및 <a class="reference internal" href="../library/fileinput.html#fileinput.FileInput" title="fileinput.FileInput"><code class="xref py py-class docutils literal notranslate"><span class="pre">fileinput.FileInput</span></code></a>의 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드는 폐지되었습니다.</p>
<p>이 메서드의 구현은 <em>index</em> 매개 변수를 무시하고 대신 다음 항목을 반환했습니다. (Contributed by Berker Peksag in <a class="reference external" href="https://bugs.python.org/issue9372">bpo-9372</a>.)</p>
</li>
<li><p><a class="reference internal" href="../library/typing.html#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code></a> 클래스는 <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 어트리뷰트를 폐지했고, 같은 정보를 갖는 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트로 대신합니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue36320">bpo-36320</a>.)</p></li>
<li><p><a class="reference internal" href="../library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 클래스 <code class="docutils literal notranslate"><span class="pre">Num</span></code>, <code class="docutils literal notranslate"><span class="pre">Str</span></code>, <code class="docutils literal notranslate"><span class="pre">Bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">NameConstant</span></code> 및 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>는 폐지된 것으로 간주하고 향후 파이썬 버전에서 제거될 예정입니다. 대신 <a class="reference internal" href="../library/ast.html#ast.Constant" title="ast.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>를 사용해야 합니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue32892">bpo-32892</a>.)</p></li>
<li><p><a class="reference internal" href="../library/ast.html#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NodeVisitor</span></code></a> 메서드 <code class="docutils literal notranslate"><span class="pre">visit_Num()</span></code>, <code class="docutils literal notranslate"><span class="pre">visit_Str()</span></code>, <code class="docutils literal notranslate"><span class="pre">visit_Bytes()</span></code>, <code class="docutils literal notranslate"><span class="pre">visit_NameConstant()</span></code> 및 <code class="docutils literal notranslate"><span class="pre">visit_Ellipsis()</span></code>는 이제 폐지되었으며 향후 파이썬 버전에서는 호출되지 않을 것입니다. 모든 상수 노드를 처리하기 위해서는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Constant()</span></code> 메서드를 추가하십시오. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue36917">bpo-36917</a>.)</p></li>
<li><p><a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a> <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>는 폐지되었고 버전 3.10에서 제거됩니다. <code class="docutils literal notranslate"><span class="pre">&#64;asyncio.coroutine</span></code> 대신, <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>를 사용하십시오. (Contributed by Andrew Svetlov in <a class="reference external" href="https://bugs.python.org/issue36921">bpo-36921</a>.)</p></li>
<li><p><a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>에서, 다음에 대해 <em>loop</em> 인자의 명시적 전달은 폐지되었고 버전 3.10에서 제거됩니다: <a class="reference internal" href="../library/asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>, <a class="reference internal" href="../library/asyncio-task.html#asyncio.gather" title="asyncio.gather"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.gather()</span></code></a>, <a class="reference internal" href="../library/asyncio-task.html#asyncio.shield" title="asyncio.shield"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.shield()</span></code></a>, <a class="reference internal" href="../library/asyncio-task.html#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.wait_for()</span></code></a>, <a class="reference internal" href="../library/asyncio-task.html#asyncio.wait" title="asyncio.wait"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.wait()</span></code></a>, <a class="reference internal" href="../library/asyncio-task.html#asyncio.as_completed" title="asyncio.as_completed"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.as_completed()</span></code></a>, <a class="reference internal" href="../library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>, <a class="reference internal" href="../library/asyncio-sync.html#asyncio.Lock" title="asyncio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Lock</span></code></a>, <a class="reference internal" href="../library/asyncio-sync.html#asyncio.Event" title="asyncio.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Event</span></code></a>, <a class="reference internal" href="../library/asyncio-sync.html#asyncio.Condition" title="asyncio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Condition</span></code></a>, <a class="reference internal" href="../library/asyncio-sync.html#asyncio.Semaphore" title="asyncio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Semaphore</span></code></a>, <a class="reference internal" href="../library/asyncio-sync.html#asyncio.BoundedSemaphore" title="asyncio.BoundedSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.BoundedSemaphore</span></code></a>, <a class="reference internal" href="../library/asyncio-queue.html#asyncio.Queue" title="asyncio.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Queue</span></code></a>, <a class="reference internal" href="../library/asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a> 및 <a class="reference internal" href="../library/asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a>.</p></li>
<li><p>코루틴 객체를 <a class="reference internal" href="../library/asyncio-task.html#asyncio.wait" title="asyncio.wait"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.wait()</span></code></a>에 명시적으로 전달하는 것은 폐지되었고 버전 3.11에서 제거됩니다. (Contributed by Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue34790">bpo-34790</a>.)</p></li>
<li><p><a class="reference internal" href="../library/gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 모듈에서는 다음 함수와 메서드가 폐지되었습니다: <a class="reference internal" href="../library/gettext.html#gettext.lgettext" title="gettext.lgettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">lgettext()</span></code></a>, <a class="reference internal" href="../library/gettext.html#gettext.ldgettext" title="gettext.ldgettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">ldgettext()</span></code></a>, <a class="reference internal" href="../library/gettext.html#gettext.lngettext" title="gettext.lngettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">lngettext()</span></code></a> 및 <a class="reference internal" href="../library/gettext.html#gettext.ldngettext" title="gettext.ldngettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">ldngettext()</span></code></a>. 이들은 인코딩된 바이트열을 반환하며, 번역된 문자열에 인코딩 문제가 있을 때 예기치 않은 유니코드 관련 예외가 발생할 수 있습니다. 파이썬 3에서 유니코드 문자열을 반환하는 대안을 사용하는 것이 훨씬 낫습니다. 이 함수들은 오랫동안 망가져 있었습니다.</p>
<p>함수 <a class="reference internal" href="../library/gettext.html#gettext.bind_textdomain_codeset" title="gettext.bind_textdomain_codeset"><code class="xref py py-func docutils literal notranslate"><span class="pre">bind_textdomain_codeset()</span></code></a>, 메서드 <a class="reference internal" href="../library/gettext.html#gettext.NullTranslations.output_charset" title="gettext.NullTranslations.output_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">output_charset()</span></code></a>과 <a class="reference internal" href="../library/gettext.html#gettext.NullTranslations.set_output_charset" title="gettext.NullTranslations.set_output_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_output_charset()</span></code></a>, 함수 <a class="reference internal" href="../library/gettext.html#gettext.translation" title="gettext.translation"><code class="xref py py-func docutils literal notranslate"><span class="pre">translation()</span></code></a>과 <a class="reference internal" href="../library/gettext.html#gettext.install" title="gettext.install"><code class="xref py py-func docutils literal notranslate"><span class="pre">install()</span></code></a>의 <em>codeset</em> 매개 변수도 폐지되었습니다, <code class="docutils literal notranslate"><span class="pre">l*gettext()</span></code> 함수에서만 사용되기 때문입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue33710">bpo-33710</a>.)</p>
</li>
<li><p><a class="reference internal" href="../library/threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a>의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">isAlive()</span></code> 메서드가 폐지되었습니다. (Contributed by Dong-hee Na in <a class="reference external" href="https://bugs.python.org/issue35283">bpo-35283</a>.)</p></li>
<li><p>정수 인자를 받아들이는 많은 내장과 확장 함수는 이제 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>들, <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code></a>들 및 정수로 변환될 때 손실을 수반하는 다른 객체들(예를 들어, <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 메서드는 있지만 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 메서드는 없는 것들)에 대해 폐지 경고를 발생시킵니다. 이후 버전에서는 에러가 될 것입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue36048">bpo-36048</a>.)</p></li>
<li><p>다음 인자들을 키워드 인자로 전달하는 것이 폐지되었습니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/functools.html#functools.partialmethod" title="functools.partialmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partialmethod()</span></code></a>, <a class="reference internal" href="../library/weakref.html#weakref.finalize" title="weakref.finalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">weakref.finalize()</span></code></a>, <a class="reference internal" href="../library/profile.html#profile.Profile.runcall" title="profile.Profile.runcall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">profile.Profile.runcall()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">cProfile.Profile.runcall()</span></code>, <a class="reference internal" href="../library/bdb.html#bdb.Bdb.runcall" title="bdb.Bdb.runcall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bdb.Bdb.runcall()</span></code></a>, <a class="reference internal" href="../library/trace.html#trace.Trace.runfunc" title="trace.Trace.runfunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trace.Trace.runfunc()</span></code></a> 및 <a class="reference internal" href="../library/curses.html#curses.wrapper" title="curses.wrapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">curses.wrapper()</span></code></a>의 <em>func</em>.</p></li>
<li><p><a class="reference internal" href="../library/unittest.html#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unittest.TestCase.addCleanup()</span></code></a>의 <em>function</em>.</p></li>
<li><p><a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a>과 <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ProcessPoolExecutor</span></code></a>의 <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.Executor.submit" title="concurrent.futures.Executor.submit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">submit()</span></code></a> 메서드의 <em>fn</em>.</p></li>
<li><p><a class="reference internal" href="../library/contextlib.html#contextlib.ExitStack.callback" title="contextlib.ExitStack.callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contextlib.ExitStack.callback()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">contextlib.AsyncExitStack.callback()</span></code> 및 <a class="reference internal" href="../library/contextlib.html#contextlib.AsyncExitStack.push_async_callback" title="contextlib.AsyncExitStack.push_async_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contextlib.AsyncExitStack.push_async_callback()</span></code></a>의 <em>callback</em></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.managers.Server</span></code>와 <code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.managers.SharedMemoryServer</span></code>의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code> 메서드의 <em>c</em>와 <em>typeid</em>.</p></li>
<li><p><a class="reference internal" href="../library/weakref.html#weakref.finalize" title="weakref.finalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">weakref.finalize()</span></code></a>의 <em>obj</em>.</p></li>
</ul>
<p>파이썬의 향후 배포에서, 이것들은 <a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">위치 전용</span></a>이 될 것입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue36492">bpo-36492</a>.)</p>
</li>
</ul>
</div>
<div class="section" id="api-and-feature-removals">
<h2>API 및 기능 제거<a class="headerlink" href="#api-and-feature-removals" title="제목 주소">¶</a></h2>
<p>다음 기능과 API는 파이썬 3.8에서 제거되었습니다.:</p>
<ul class="simple">
<li><p>파이썬 3.3부터, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>에서 ABC를 임포트 하는 것은 폐지되었고, <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>에서 임포트를 수행해야 합니다. collections에서 임포트할 수 있는 것은 3.8에서 제거될 것으로 표시되었지만 3.9로 지연되었습니다. (<a class="reference external" href="https://bugs.python.org/issue36952">bpo-36952</a> 참조)</p></li>
<li><p>파이썬 3.7에서 폐지된, <code class="xref py py-mod docutils literal notranslate"><span class="pre">macpath</span></code> 모듈이 제거되었습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35471">bpo-35471</a>.)</p></li>
<li><p>파이썬 3.3부터 폐지된 이후로, <code class="xref py py-func docutils literal notranslate"><span class="pre">platform.popen()</span></code> 함수는 제거되었습니다: 대신 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>을 사용하십시오. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35345">bpo-35345</a>.)</p></li>
<li><p>파이썬 3.3부터 폐지된 이후로, <code class="xref py py-func docutils literal notranslate"><span class="pre">time.clock()</span></code> 함수는 제거되었습니다: 잘 정의된 동작을 위해, 요구 사항에 따라 <a class="reference internal" href="../library/time.html#time.perf_counter" title="time.perf_counter"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a>나 <a class="reference internal" href="../library/time.html#time.process_time" title="time.process_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.process_time()</span></code></a>을 대신 사용하십시오. (Contributed by Matthias Bussonnier in <a class="reference external" href="https://bugs.python.org/issue36895">bpo-36895</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 스크립트를 제거하고 <code class="docutils literal notranslate"><span class="pre">python3.8</span> <span class="pre">-m</span> <span class="pre">venv</span></code>로 대체하여, 어떤 파이썬 인터프리터가 <code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 스크립트와 연결되어 있는지에 대한 혼란을 없애줍니다. (Contributed by Brett Cannon in <a class="reference external" href="https://bugs.python.org/issue25427">bpo-25427</a>.)</p></li>
<li><p><a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code></a> 모듈에서 <code class="docutils literal notranslate"><span class="pre">parse_qs</span></code>, <code class="docutils literal notranslate"><span class="pre">parse_qsl</span></code> 및 <code class="docutils literal notranslate"><span class="pre">escape</span></code>가 제거되었습니다. 파이썬 3.2 이하에서 폐지되었습니다. 대신 <code class="docutils literal notranslate"><span class="pre">urllib.parse</span></code>와 <code class="docutils literal notranslate"><span class="pre">html</span></code> 모듈에서 임포트 해야 합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filemode</span></code> 함수가 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈에서 제거되었습니다. 문서로 만들어지지 않았고, 파이썬 3.3부터 폐지되었습니다.</p></li>
<li><p><a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 생성자는 더는 <em>html</em> 인자를 받아들이지 않습니다. 효과가 있었던 적이 없고 3.4에서 폐지되었습니다. 다른 모든 매개 변수는 이제 <a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">키워드 전용</span></a>입니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue29209">bpo-29209</a>.)</p></li>
<li><p><a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">doctype()</span></code> 메서드를 제거했습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue29209">bpo-29209</a>.)</p></li>
<li><p>&quot;unicode_internal&quot; 코덱이 제거되었습니다. (Contributed by Inada Naoki in <a class="reference external" href="https://bugs.python.org/issue36297">bpo-36297</a>.)</p></li>
<li><p><a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈의 <code class="docutils literal notranslate"><span class="pre">Cache</span></code>와 <code class="docutils literal notranslate"><span class="pre">Statement</span></code> 객체는 사용자에게 노출되지 않습니다. (Contributed by Aviv Palivoda in <a class="reference external" href="https://bugs.python.org/issue30262">bpo-30262</a>.)</p></li>
<li><p><a class="reference internal" href="../library/fileinput.html#fileinput.input" title="fileinput.input"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileinput.input()</span></code></a>과 <a class="reference internal" href="../library/fileinput.html#fileinput.FileInput" title="fileinput.FileInput"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileinput.FileInput()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">bufsize</span></code> 키워드 인자는 무시 되었고 파이썬 3.6부터 폐지되었으며, 이제 제거되었습니다. <a class="reference external" href="https://bugs.python.org/issue36952">bpo-36952</a> (Contributed by Matthias Bussonnier.)</p></li>
<li><p>파이썬 3.7에서 폐지된 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_coroutine_wrapper()</span></code>와 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.get_coroutine_wrapper()</span></code> 함수는 제거되었습니다; <a class="reference external" href="https://bugs.python.org/issue36933">bpo-36933</a> (Contributed by Matthias Bussonnier.)</p></li>
</ul>
</div>
<div class="section" id="porting-to-python-3-8">
<h2>파이썬 3.8로 이식하기<a class="headerlink" href="#porting-to-python-3-8" title="제목 주소">¶</a></h2>
<p>이 절에서는 여러분의 코드 수정을 요구할 수도 있는 이전에 설명한 변경 사항과 다른 버그 수정 사항을 나열합니다.</p>
<div class="section" id="changes-in-python-behavior">
<h3>파이썬 동작의 변경<a class="headerlink" href="#changes-in-python-behavior" title="제목 주소">¶</a></h3>
<ul class="simple">
<li><p>일드 표현식(<code class="docutils literal notranslate"><span class="pre">yield</span></code>와 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 절 모두)은 이제 컴프리헨션과 제너레이터 표현식에서 허용되지 않습니다 (가장 왼쪽 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절의 이터러블 표현식 제외). (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue10544">bpo-10544</a>.)</p></li>
<li><p>아이덴티티 검사(<code class="docutils literal notranslate"><span class="pre">is</span></code>와 <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>)가 특정 형의 리터럴(예를 들어, 문자열, 숫자)과 함께 사용될 때 컴파일러는 이제 <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>을 생성합니다. 이들은 종종 CPython에서 우연히 작동할 수 있지만, 언어 명세에 의해 보장되지는 않습니다. 이 경고는 사용자가 동등 검사(<code class="docutils literal notranslate"><span class="pre">==</span></code>와 <code class="docutils literal notranslate"><span class="pre">!=</span></code>)를 대신 사용하도록 권장합니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue34850">bpo-34850</a>.)</p></li>
<li><p>CPython 인터프리터는 때에 따라 예외를 삼킬 수 있습니다. 파이썬 3.8에서는 이런 경우가 덜 발생합니다. 특히, 형 딕셔너리에서 어트리뷰트를 가져올 때 발생하는 예외는 더는 무시되지 않습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue35459">bpo-35459</a>.)</p></li>
<li><p>내장형 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 및 표준 라이브러리의 일부 클래스에서 <code class="docutils literal notranslate"><span class="pre">__str__</span></code> 구현을 제거했습니다. 이제 이들은 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>에서 <code class="docutils literal notranslate"><span class="pre">__str__()</span></code>을 상속합니다. 결과적으로, 이러한 클래스의 서브 클래스에서 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> 메서드를 정의하면 문자열 표현에 영향을 줍니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue36793">bpo-36793</a>.)</p></li>
<li><p>AIX에서, <a class="reference internal" href="../library/sys.html#sys.platform" title="sys.platform"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.platform</span></code></a>은 더는 주(major) 버전을 포함하지 않습니다. <code class="docutils literal notranslate"><span class="pre">'aix3'</span></code> .. <code class="docutils literal notranslate"><span class="pre">'aix7'</span></code> 대신 항상 <code class="docutils literal notranslate"><span class="pre">'aix'</span></code>입니다. 이전 버전의 파이썬에서는 버전 번호가 포함되어 있기 때문에, 항상 <code class="docutils literal notranslate"><span class="pre">sys.platform.startswith('aix')</span></code>를 사용하는 것이 좋습니다. (Contributed by M. Felt in <a class="reference external" href="https://bugs.python.org/issue36588">bpo-36588</a>.)</p></li>
<li><p><a class="reference internal" href="../c-api/init.html#c.PyEval_AcquireLock" title="PyEval_AcquireLock"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_AcquireLock()</span></code></a>과 <a class="reference internal" href="../c-api/init.html#c.PyEval_AcquireThread" title="PyEval_AcquireThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_AcquireThread()</span></code></a>는 인터프리터가 파이널라이즈하는 동안 호출되면 현재 스레드를 종료하여, <a class="reference internal" href="../c-api/init.html#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>, <a class="reference internal" href="../c-api/init.html#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a> 및 <a class="reference internal" href="../c-api/init.html#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>와 일관되게 만듭니다. 이 동작을 원하지 않으면, <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code>이나 <code class="xref c c-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code>을 확인하여 호출을 보호하십시오. (Contributed by Joannah Nanjekye in <a class="reference external" href="https://bugs.python.org/issue36475">bpo-36475</a>.)</p></li>
</ul>
</div>
<div class="section" id="changes-in-the-python-api">
<h3>파이썬 API의 변경<a class="headerlink" href="#changes-in-the-python-api" title="제목 주소">¶</a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/os.html#os.getcwdb" title="os.getcwdb"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwdb()</span></code></a> 함수는 이제 윈도우에서 ANSI 코드 페이지가 아닌 UTF-8 인코딩을 사용합니다. 이유는 <span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0529"><strong>PEP 529</strong></a>를 참조하십시오. 이 함수는 윈도우에서 더는 폐지되지 않았습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue37412">bpo-37412</a>.)</p></li>
<li><p><a class="reference internal" href="../library/subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>은 이제 어떤 경우에 더 나은 성능을 위해 <a class="reference internal" href="../library/os.html#os.posix_spawn" title="os.posix_spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.posix_spawn()</span></code></a>을 사용할 수 있습니다. 리눅스용 윈도우 하위 시스템과 QEMU 사용자 에뮬레이션에서, <a class="reference internal" href="../library/os.html#os.posix_spawn" title="os.posix_spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.posix_spawn()</span></code></a>을 사용하는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code> 생성자는 더는 &quot;프로그램 누락&quot;과 같은 에러에 예외를 발생시키지 않습니다. 대신 자식 프로세스는 0이 아닌 <code class="xref py py-attr docutils literal notranslate"><span class="pre">returncode</span></code>로 실패합니다. (Contributed by Joannah Nanjekye and Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35537">bpo-35537</a>.)</p></li>
<li><p><a class="reference internal" href="../library/subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>의 <em>preexec_fn</em> 인자는 더는 서브 인터프리터와 호환되지 않습니다. 서브 인터프리터에서 매개 변수를 사용하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다. (Contributed by Eric Snow in <a class="reference external" href="https://bugs.python.org/issue34651">bpo-34651</a>, modified by Christian Heimes in <a class="reference external" href="https://bugs.python.org/issue37951">bpo-37951</a>.)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">imap.IMAP4.logout()</span></code> 메서드는 더는 조용히 임의의 예외를 무시하지 않습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36348">bpo-36348</a>.)</p></li>
<li><p>파이썬 3.3부터 폐지된 이후로, <code class="xref py py-func docutils literal notranslate"><span class="pre">platform.popen()</span></code> 함수는 제거되었습니다: 대신 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>을 사용하십시오. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue35345">bpo-35345</a>.)</p></li>
<li><p><a class="reference internal" href="../library/statistics.html#statistics.mode" title="statistics.mode"><code class="xref py py-func docutils literal notranslate"><span class="pre">statistics.mode()</span></code></a> 함수는 다중 모드(multimodal) 데이터가 주어질 때 더는 예외를 발생시키지 않습니다. 대신, 입력 데이터에서 만나는 첫 번째 모드를 반환합니다. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue35892">bpo-35892</a>.)</p></li>
<li><p><a class="reference internal" href="../library/tkinter.ttk.html#tkinter.ttk.Treeview" title="tkinter.ttk.Treeview"><code class="xref py py-class docutils literal notranslate"><span class="pre">tkinter.ttk.Treeview</span></code></a> 클래스의 <a class="reference internal" href="../library/tkinter.ttk.html#tkinter.ttk.Treeview.selection" title="tkinter.ttk.Treeview.selection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selection()</span></code></a> 메서드는 더는 인자를 받아들이지 않습니다. 선택을 변경하기 위해 인자와 함께 사용하는 것은 파이썬 3.6에서 폐지되었습니다. 선택을 변경하려면 <a class="reference internal" href="../library/tkinter.ttk.html#tkinter.ttk.Treeview.selection_set" title="tkinter.ttk.Treeview.selection_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selection_set()</span></code></a>과 같은 특화된 메서드를 사용하십시오. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue31508">bpo-31508</a>.)</p></li>
<li><p><a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a> 모듈의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">writexml()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">toprettyxml()</span></code> 메서드와 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree</span></code>의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 메서드는 이제 사용자가 지정한 어트리뷰트 순서를 보존합니다. (Contributed by Diego Rojas and Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue34160">bpo-34160</a>.)</p></li>
<li><p>플래그 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>로 열린 <a class="reference internal" href="../library/dbm.html#module-dbm.dumb" title="dbm.dumb: Portable implementation of the simple DBM interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.dumb</span></code></a> 데이터베이스는 이제 읽기 전용입니다. <code class="docutils literal notranslate"><span class="pre">'r'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> 플래그로 <a class="reference internal" href="../library/dbm.html#dbm.dumb.open" title="dbm.dumb.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">dbm.dumb.open()</span></code></a>하면 더는 데이터베이스가 없을 때 만들지 않습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue32749">bpo-32749</a>.)</p></li>
<li><p><a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>의 서브 클래스에 정의된 <code class="docutils literal notranslate"><span class="pre">doctype()</span></code> 메서드는 더는 호출되지 않으며 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 대신 <a class="reference internal" href="../library/exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a>을 방출합니다. XML doctype 선언을 처리하려면 대상에 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.TreeBuilder.doctype" title="xml.etree.ElementTree.TreeBuilder.doctype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doctype()</span></code></a> 메서드를 정의하십시오. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue29209">bpo-29209</a>.)</p></li>
<li><p>사용자 지정 메타 클래스가 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>에 전달된 이름 공간에 <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> 항목을 제공하지 않으면 이제 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다. 파이썬 3.6--3.7에서는 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>이 방출되었습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue23722">bpo-23722</a>.)</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> 클래스는 이제 컨텍스트 관리자로 사용할 수 있습니다. (Contributed by Scott Sanderson in <a class="reference external" href="https://bugs.python.org/issue29235">bpo-29235</a>.)</p></li>
<li><p><a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfile()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy2()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copytree()</span></code></a> 및 <a class="reference internal" href="../library/shutil.html#shutil.move" title="shutil.move"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.move()</span></code></a>는 플랫폼 특정 &quot;고속 복사(fast-copy)&quot; 시스템 호출을 사용합니다 (<a class="reference internal" href="../library/shutil.html#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 절을 참조하십시오).</p></li>
<li><p>윈도우에서 <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfile()</span></code></a> 기본 버퍼 크기가 16 KiB에서 1 MiB로 변경되었습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyGC_Head</span></code> 구조체가 완전히 변경되었습니다. 구조체 멤버를 건드리는 모든 코드는 다시 작성해야 합니다. (<a class="reference external" href="https://bugs.python.org/issue33597">bpo-33597</a> 참조.)</p></li>
<li><p><a class="reference internal" href="../c-api/init.html#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 구조체는 &quot;내부&quot; 헤더 파일(구체적으로 Include/internal/pycore_pystate.h)로 이동했습니다. 불투명한 <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code>는 공용 API(와 안정 ABI)의 일부로 계속 사용할 수 있습니다. 설명서는 구조체의 필드가 공용이 아니라고 말하고 있으니, 아무도 해당 필드를 사용하지 않기를 바랍니다. 그러나, 하나 이상의 내부 필드에 의지하고 대안이 없으면 BPO 이슈를 여십시오. 조정을 돕기 위해 노력할 것입니다 (공용 API에 접근 함수를 추가하는 것도 가능합니다). (<a class="reference external" href="https://bugs.python.org/issue35886">bpo-35886</a>을 참조하십시오.)</p></li>
<li><p><a class="reference internal" href="../library/mmap.html#mmap.mmap.flush" title="mmap.mmap.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mmap.flush()</span></code></a> 메서드는 이제 모든 플랫폼에서 성공 시 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하고 에러 시 예외를 발생시킵니다. 이전에는, 그 동작이 플랫폼에 따라 달랐습니다: 윈도우에서 성공 시 0이 아닌 값이 반환되었습니다; 에러 시 0이 반환되었습니다. 유닉스에서 성공 시 0 값이 반환되었습니다; 에러 시 예외가 발생했습니다. (Contributed by Berker Peksag in <a class="reference external" href="https://bugs.python.org/issue2122">bpo-2122</a>.)</p></li>
<li><p><a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a>과 <a class="reference internal" href="../library/xml.sax.html#module-xml.sax" title="xml.sax: Package containing SAX2 base classes and convenience functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.sax</span></code></a> 모듈은 기본적으로 더는 외부 엔티티를 처리하지 않습니다. (Contributed by Christian Heimes in <a class="reference external" href="https://bugs.python.org/issue17239">bpo-17239</a>.)</p></li>
<li><p>읽기 전용 <a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: Interfaces to various Unix &quot;database&quot; formats."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm</span></code></a> 데이터베이스(<a class="reference internal" href="../library/dbm.html#module-dbm.dumb" title="dbm.dumb: Portable implementation of the simple DBM interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.dumb</span></code></a>, <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> 또는 <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a>)에서 키를 삭제하면 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 대신 <code class="xref py py-attr docutils literal notranslate"><span class="pre">error</span></code>(<a class="reference internal" href="../library/dbm.html#dbm.dumb.error" title="dbm.dumb.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">dbm.dumb.error</span></code></a>, <a class="reference internal" href="../library/dbm.html#dbm.gnu.error" title="dbm.gnu.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">dbm.gnu.error</span></code></a> 또는 <a class="reference internal" href="../library/dbm.html#dbm.ndbm.error" title="dbm.ndbm.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">dbm.ndbm.error</span></code></a>)를 발생시킵니다. (Contributed by Xiang Zhang in <a class="reference external" href="https://bugs.python.org/issue33106">bpo-33106</a>.)</p></li>
<li><p>리터럴을 위해 단순화된 AST. 모든 상수는 <a class="reference internal" href="../library/ast.html#ast.Constant" title="ast.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Constant</span></code></a> 인스턴스로 표시됩니다. 이전 클래스 <code class="docutils literal notranslate"><span class="pre">Num</span></code>, <code class="docutils literal notranslate"><span class="pre">Str</span></code>, <code class="docutils literal notranslate"><span class="pre">Bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">NameConstant</span></code> 및 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>를 인스턴스 화하면 <code class="docutils literal notranslate"><span class="pre">Constant</span></code> 인스턴스가 반환됩니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue32892">bpo-32892</a>.)</p></li>
<li><p>윈도우에서 <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal notranslate"><span class="pre">expanduser()</span></code></a>는 이제 <span class="target" id="index-70"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">USERPROFILE</span></code> 환경 변수를 선호하며 일반적으로 일반 사용자 계정에 설정되지 않는 <span class="target" id="index-71"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code>을 사용하지 않습니다. (Contributed by Anthony Sottile in <a class="reference external" href="https://bugs.python.org/issue36264">bpo-36264</a>.)</p></li>
<li><p><a class="reference internal" href="../library/asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> 예외는 이제 <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a>이 아닌 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseException</span></code></a>을 상속하고, 더는 <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.CancelledError" title="concurrent.futures.CancelledError"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.CancelledError</span></code></a>를 상속하지 않습니다. (Contributed by Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue32528">bpo-32528</a>.)</p></li>
<li><p><a class="reference internal" href="../library/asyncio-task.html#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.wait_for()</span></code></a> 함수는 이제 <a class="reference internal" href="../library/asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> 인스턴스를 사용할 때 취소를 올바르게 기다립니다. 이전에는, <em>timeout</em>에 도달하면 취소되어 즉시 반환되었습니다. (Contributed by Elvis Pranskevichus in <a class="reference external" href="https://bugs.python.org/issue32751">bpo-32751</a>.)</p></li>
<li><p><a class="reference internal" href="../library/asyncio-protocol.html#asyncio.BaseTransport.get_extra_info" title="asyncio.BaseTransport.get_extra_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.BaseTransport.get_extra_info()</span></code></a> 함수는 이제 'socket'이 <em>name</em> 매개 변수로 전달될 때 안전하게 사용할 수 있는 소켓 객체를 반환합니다. (Contributed by Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue37027">bpo-37027</a>.)</p></li>
<li><p><a class="reference internal" href="../library/asyncio-protocol.html#asyncio.BufferedProtocol" title="asyncio.BufferedProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.BufferedProtocol</span></code></a>는 졸업해서 안정 API가 되었습니다.</p></li>
</ul>
<ul class="simple" id="bpo-36085-whatsnew">
<li><p>윈도우에서 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 로드된 확장 모듈과 DLL에 대한 DLL 종속성이 이제 더 안전하게 처리됩니다. 시스템 경로, DLL이나 PYD 파일이 들어 있는 디렉터리 및 <a class="reference internal" href="../library/os.html#os.add_dll_directory" title="os.add_dll_directory"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_dll_directory()</span></code></a>로 추가된 디렉터리만 로드 시간 종속성을 위해 검색합니다. 특히, <span class="target" id="index-72"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code>와 현재 작업 디렉터리는 더는 사용되지 않으며, 이러한 것들에 대한 수정은 더는 일반 DLL 결정(resolution)에 영향을 주지 않습니다. 여러분의 응용 프로그램이 이러한 메커니즘에 의존한다면, <a class="reference internal" href="../library/os.html#os.add_dll_directory" title="os.add_dll_directory"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_dll_directory()</span></code></a>가 있는지 확인하고, 있다면 이를 사용하여 라이브러리를 로드하는 동안 DLL 디렉터리를 추가하십시오. 윈도우 7 사용자는 윈도우 업데이트 KB2533623이 설치되었는지 확인해야 합니다 (이는 설치 프로그램에서도 확인합니다). (Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue36085">bpo-36085</a>.)</p></li>
<li><p>pgen과 관련된 헤더 파일과 함수는 순수 파이썬 구현으로 대체 된 후에 제거되었습니다. (Contributed by Pablo Galindo in <a class="reference external" href="https://bugs.python.org/issue36623">bpo-36623</a>.)</p></li>
<li><p><a class="reference internal" href="../library/types.html#types.CodeType" title="types.CodeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.CodeType</span></code></a>은 <span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0570"><strong>PEP 570</strong></a>에 정의된 위치 전용 인자를 지원하기 위해 생성자의 두 번째 위치에 새 매개 변수(<em>posonlyargcount</em>)를 갖습니다. 첫 번째 인자(<em>argcount</em>)는 이제 위치 인자의 총수(위치 전용 인자 포함)를 나타냅니다. <a class="reference internal" href="../library/types.html#types.CodeType" title="types.CodeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.CodeType</span></code></a>의 새로운 <code class="docutils literal notranslate"><span class="pre">replace()</span></code> 메서드를 사용하면 코드가 미래에도 안전하게 만들 수 있습니다.</p></li>
</ul>
</div>
<div class="section" id="changes-in-the-c-api">
<h3>C API의 변경<a class="headerlink" href="#changes-in-the-c-api" title="제목 주소">¶</a></h3>
<ul>
<li><p><a class="reference internal" href="../c-api/veryhigh.html#c.PyCompilerFlags" title="PyCompilerFlags"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCompilerFlags</span></code></a> 구조체에 새로운 <em>cf_feature_version</em> 필드가 생겼습니다. <code class="docutils literal notranslate"><span class="pre">PY_MINOR_VERSION</span></code>으로 초기화해야합니다. 이 필드는 기본적으로 무시되며, <code class="docutils literal notranslate"><span class="pre">PyCF_ONLY_AST</span></code> 플래그가 <em>cf_flags</em>에 설정되었을 때, 또 그때만 사용됩니다. (Contributed by Guido van Rossum in <a class="reference external" href="https://bugs.python.org/issue35766">bpo-35766</a>.)</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_ReInitThreads()</span></code> 함수가 C API에서 제거되었습니다. 명시적으로 호출하면 안 됩니다: 대신 <a class="reference internal" href="../c-api/sys.html#c.PyOS_AfterFork_Child" title="PyOS_AfterFork_Child"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_AfterFork_Child()</span></code></a>를 사용하십시오. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue36728">bpo-36728</a>.)</p></li>
<li><p>유닉스에서, C 확장은 더는 안드로이드와 Cygwin을 제외하고는 libpython에 링크되지 않습니다. 파이썬이 내장될 때, <code class="docutils literal notranslate"><span class="pre">libpython</span></code>은 <code class="docutils literal notranslate"><span class="pre">RTLD_LOCAL</span></code>이 아니라 <code class="docutils literal notranslate"><span class="pre">RTLD_GLOBAL</span></code>로 로드되어야 합니다. 이전에는, <code class="docutils literal notranslate"><span class="pre">RTLD_LOCAL</span></code>을 사용하여, <code class="docutils literal notranslate"><span class="pre">Modules/Setup</span></code>의 <code class="docutils literal notranslate"><span class="pre">*shared*</span></code> 섹션에 의해 빌드된 표준 라이브러리의 C 확장과 같이 <code class="docutils literal notranslate"><span class="pre">libpython</span></code>에 링크되지 않은 C 확장을 로드할 수 없었습니다. (Contributed by Victor Stinner in <a class="reference external" href="https://bugs.python.org/issue21536">bpo-21536</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code>이 정의되지 않은 상태에서 값을 구문 분석하거나 빌드할 때(예를 들어, <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, <a class="reference internal" href="../c-api/arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>, <a class="reference internal" href="../c-api/call.html#c.PyObject_CallFunction" title="PyObject_CallFunction"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunction()</span></code></a> 등) 포맷의 <code class="docutils literal notranslate"><span class="pre">#</span></code> 변형을 사용하면 <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code>이 발생합니다. 3.10이나 4.0에서 제거됩니다. 자세한 내용은 <a class="reference internal" href="../c-api/arg.html#arg-parsing"><span class="std std-ref">인자 구문 분석과 값 구축</span></a>를 참조하십시오. (Contributed by Inada Naoki in <a class="reference external" href="https://bugs.python.org/issue36381">bpo-36381</a>.)</p></li>
<li><p>힙에 할당된 형(가령 <a class="reference internal" href="../c-api/type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a>으로 만들어진 것들)의 인스턴스는 해당 형 객체에 대한 참조를 보유합니다. 이러한 형 객체의 참조 횟수를 늘리는 것이 <a class="reference internal" href="../c-api/type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>에서 더 저수준 함수 <a class="reference internal" href="../c-api/allocation.html#c.PyObject_Init" title="PyObject_Init"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Init()</span></code></a>와 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_INIT()</span></code>로 옮겨졌습니다. 이렇게 하면 <a class="reference internal" href="../c-api/type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a>을 통해 만들어진 형이, 관리되는 코드의 다른 클래스처럼 작동합니다.</p>
<p>정적으로 할당된 형은 영향을 받지 않습니다.</p>
<p>대다수의 경우, 부작용이 없어야 합니다. 그러나, 인스턴스를 할당한 후 수동으로 참조 횟수를 늘리는 형(아마도 버그를 회피하기 위해)이 이제 불멸이 될 수 있습니다. 이를 피하고자, 이런 클래스는 인스턴스 할당 해제 중에 형 객체에 Py_DECREF를 호출할 필요가 있습니다.</p>
<p>이러한 형들을 3.8로 올바르게 이식하려면, 다음 변경 사항을 적용하십시오:</p>
<ul>
<li><p>인스턴스를 할당한 후 형 객체에 대한 <a class="reference internal" href="../c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_INCREF</span></code></a>를 제거하십시오 - 있다면. 이것은 <a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_New()</span></code></a>, <a class="reference internal" href="../c-api/allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_NewVar()</span></code></a>, <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a>, <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a> 또는 <a class="reference internal" href="../c-api/allocation.html#c.PyObject_Init" title="PyObject_Init"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Init()</span></code></a>나 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_INIT()</span></code>를 사용하는 다른 사용자 정의 할당자를 호출한 후에 발생할 수 있습니다.</p>
<p>예:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">foo_struct</span> <span class="o">*</span>
<span class="nf">foo_new</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">foo_struct</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">foo_struct</span><span class="p">,</span> <span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#if PY_VERSION_HEX &lt; 0x03080000</span>
    <span class="c1">// 파이썬 이슈 35810에 대한 해결 방법; 파이썬 3.8에서는 더는 필요 없습니다</span>
    <span class="n">PY_INCREF</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
<span class="cp">#endif</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>힙에 할당되는 형의 모든 사용자 정의 <code class="docutils literal notranslate"><span class="pre">tp_dealloc</span></code> 함수가 형의 참조 횟수를 감소시키도록 하십시오.</p>
<p>예:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">foo_dealloc</span><span class="p">(</span><span class="n">foo_struct</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
    <span class="n">PyObject_GC_Del</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="cp">#if PY_VERSION_HEX &gt;= 0x03080000</span>
    <span class="c1">// 파이썬 3.8 이전에서는 필요하지 않았습니다 (파이썬 이슈 35810)</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>(Contributed by Eddie Elizondo in <a class="reference external" href="https://bugs.python.org/issue35810">bpo-35810</a>.)</p>
</li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_DEPRECATED()</span></code> 매크로는 MSVC 용으로 구현되었습니다. 매크로는 이제 기호 이름 앞에 놓여야 합니다.</p>
<p>예:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_DEPRECATED</span><span class="p">(</span><span class="mf">3.8</span><span class="p">)</span> <span class="n">PyAPI_FUNC</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">Py_OldFunction</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>(Contributed by Zackery Spytz in <a class="reference external" href="https://bugs.python.org/issue33407">bpo-33407</a>.)</p>
</li>
<li><p>인터프리터는 더는 기능 배포에서 확장형의 바이너리 호환성을 지원하지 않습니다. 제삼자 확장 모듈에서 내보낸 <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>는 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> (<a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_HAVE_FINALIZE" title="Py_TPFLAGS_HAVE_FINALIZE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_FINALIZE</span></code></a>는 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>를 읽기 전에 더는 확인되지 않습니다)를 포함하여 현재 파이썬 버전이 기대하는 모든 슬롯을 가지고 있다고 가정합니다.</p>
<p>(Contributed by Antoine Pitrou in <a class="reference external" href="https://bugs.python.org/issue32388">bpo-32388</a>.)</p>
</li>
<li><p>함수 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyNode_AddChild()</span></code>와 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyParser_AddToken()</span></code>는 이제 두 개의 추가 <code class="docutils literal notranslate"><span class="pre">int</span></code> 인자 <em>end_lineno</em>와 <em>end_col_offset</em>을 받아들입니다.</p></li>
<li><p>MinGW 도구가 <code class="file docutils literal notranslate"><span class="pre">python38.dll</span></code>에 대해 직접 링크할 수 있도록 허용하는 <code class="file docutils literal notranslate"><span class="pre">libpython38.a</span></code> 파일은 더는 일반 윈도우 배포에 포함되지 않습니다. 이 파일이 필요하면, MinGW binutils 패키지의 일부인 <code class="docutils literal notranslate"><span class="pre">gendef</span></code>와 <code class="docutils literal notranslate"><span class="pre">dlltool</span></code> 도구로 생성할 수 있습니다:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gendef - python38.dll &gt; tmp.def
dlltool --dllname python38.dll --def tmp.def --output-lib libpython38.a
</pre></div>
</div>
<p>설치된 <code class="file docutils literal notranslate"><span class="pre">pythonXY.dll</span></code>의 위치는 윈도우의 설치 옵션과 버전 및 언어에 따라 다릅니다. 자세한 내용은 <a class="reference internal" href="../using/windows.html#using-on-windows"><span class="std std-ref">윈도우에서 파이썬 사용하기</span></a>를 참조하십시오. 결과 라이브러리는 <code class="file docutils literal notranslate"><span class="pre">pythonXY.lib</span></code>(일반적으로 파이썬 설치 환경의 <code class="file docutils literal notranslate"><span class="pre">libs</span></code> 디렉터리입니다)와 같은 디렉터리에 위치해야 합니다.</p>
<p>(Contributed by Steve Dower in <a class="reference external" href="https://bugs.python.org/issue37351">bpo-37351</a>.)</p>
</li>
</ul>
</div>
<div class="section" id="cpython-bytecode-changes">
<h3>CPython 바이트 코드 변경<a class="headerlink" href="#cpython-bytecode-changes" title="제목 주소">¶</a></h3>
<ul>
<li><p>인터프리터 루프는 블록 스택을 언 롤링하는 로직을 컴파일러로 이동시킴으로써 단순화되었습니다. 컴파일러는 이제 값 스택을 조정하고 <a class="reference internal" href="../reference/simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, <a class="reference internal" href="../reference/simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 및 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>에 대한 정리 코드를 호출하는 명시적인 명령을 출력합니다.</p>
<p>옵코드 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">BREAK_LOOP</span></code>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">CONTINUE_LOOP</span></code>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">SETUP_LOOP</span></code> 및 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">SETUP_EXCEPT</span></code>를 제거했습니다. 새로운 옵코드 <a class="reference internal" href="../library/dis.html#opcode-ROT_FOUR"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">ROT_FOUR</span></code></a>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">BEGIN_FINALLY</span></code>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_FINALLY</span></code> 및 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_FINALLY</span></code>가 추가되었습니다. <code class="xref std std-opcode docutils literal notranslate"><span class="pre">END_FINALLY</span></code>와 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">WITH_CLEANUP_START</span></code>의 동작이 변경되었습니다.</p>
<p>(Contributed by Mark Shannon, Antoine Pitrou and Serhiy Storchaka in
<a class="reference external" href="https://bugs.python.org/issue17611">bpo-17611</a>.)</p>
</li>
<li><p><a class="reference internal" href="../reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 루프에서 다음 항목을 await 할 때 발생하는 예외를 처리하기 위한 새로운 옵코드 <a class="reference internal" href="../library/dis.html#opcode-END_ASYNC_FOR"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">END_ASYNC_FOR</span></code></a>가 추가되었습니다. (Contributed by Serhiy Storchaka in <a class="reference external" href="https://bugs.python.org/issue33041">bpo-33041</a>.)</p></li>
<li><p><a class="reference internal" href="../library/dis.html#opcode-MAP_ADD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">MAP_ADD</span></code></a>는 이제 값을 스택의 첫 번째 요소로, 키를 두 번째 요소로 기대합니다. 이 변경은 <span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0572"><strong>PEP 572</strong></a>의 제안에 따라, 딕셔너리 컴프리헨션에서 키가 값보다 항상 먼저 평가되도록 하기 위해 만들어졌습니다. (Contributed by Jörn Heissler in <a class="reference external" href="https://bugs.python.org/issue35224">bpo-35224</a>.)</p></li>
</ul>
</div>
<div class="section" id="demos-and-tools">
<h3>데모와 도구<a class="headerlink" href="#demos-and-tools" title="제목 주소">¶</a></h3>
<p>변수를 액세스하는 다양한 방법의 시간을 측정하기 위한 벤치마크 스크립트를 추가했습니다: <code class="docutils literal notranslate"><span class="pre">Tools/scripts/var_access_benchmark.py</span></code>. (Contributed by Raymond Hettinger in <a class="reference external" href="https://bugs.python.org/issue35884">bpo-35884</a>.)</p>
<p>다음은 파이썬 3.3 이후의 성능 향상에 대한 요약입니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Python version                       3.3     3.4     3.5     3.6     3.7     3.8
--------------                       ---     ---     ---     ---     ---     ---

Variable and attribute read access:
    read_local                       4.0     7.1     7.1     5.4     5.1     3.9
    read_nonlocal                    5.3     7.1     8.1     5.8     5.4     4.4
    read_global                     13.3    15.5    19.0    14.3    13.6     7.6
    read_builtin                    20.0    21.1    21.6    18.5    19.0     7.5
    read_classvar_from_class        20.5    25.6    26.5    20.7    19.5    18.4
    read_classvar_from_instance     18.5    22.8    23.5    18.8    17.1    16.4
    read_instancevar                26.8    32.4    33.1    28.0    26.3    25.4
    read_instancevar_slots          23.7    27.8    31.3    20.8    20.8    20.2
    read_namedtuple                 68.5    73.8    57.5    45.0    46.8    18.4
    read_boundmethod                29.8    37.6    37.9    29.6    26.9    27.7

Variable and attribute write access:
    write_local                      4.6     8.7     9.3     5.5     5.3     4.3
    write_nonlocal                   7.3    10.5    11.1     5.6     5.5     4.7
    write_global                    15.9    19.7    21.2    18.0    18.0    15.8
    write_classvar                  81.9    92.9    96.0   104.6   102.1    39.2
    write_instancevar               36.4    44.6    45.8    40.0    38.9    35.5
    write_instancevar_slots         28.7    35.6    36.1    27.3    26.6    25.7

Data structure read access:
    read_list                       19.2    24.2    24.5    20.8    20.8    19.0
    read_deque                      19.9    24.7    25.5    20.2    20.6    19.8
    read_dict                       19.7    24.3    25.7    22.3    23.0    21.0
    read_strdict                    17.9    22.6    24.3    19.5    21.2    18.9

Data structure write access:
    write_list                      21.2    27.1    28.5    22.5    21.6    20.0
    write_deque                     23.8    28.7    30.1    22.7    21.8    23.5
    write_dict                      25.9    31.4    33.3    29.3    29.2    24.7
    write_strdict                   22.9    28.4    29.9    27.5    25.2    23.1

Stack (or queue) operations:
    list_append_pop                144.2    93.4   112.7    75.4    74.2    50.8
    deque_append_pop                30.4    43.5    57.0    49.4    49.2    42.5
    deque_append_popleft            30.8    43.7    57.3    49.7    49.7    42.8

Timing loop:
    loop_overhead                    0.3     0.5     0.6     0.4     0.3     0.3
</pre></div>
</div>
<p>벤치마크는 <a class="reference external" href="https://www.python.org/downloads/mac-osx/">python.org</a>에서 찾을 수 있는 macOS 64비트 빌드를 실행하는 <a class="reference external" href="https://ark.intel.com/content/www/us/en/ark/products/76088/intel-core-i7-4960hq-processor-6m-cache-up-to-3-80-ghz.html">Intel® Core™ i7-4960HQ processor</a>에서 측정되었습니다. 벤치마크 스크립트는 타이밍을 나노초로 표시합니다.</p>
</div>
</div>
<div class="section" id="notable-changes-in-python-3-8-1">
<h2>파이썬 3.8.1의 주목할만한 변경 사항<a class="headerlink" href="#notable-changes-in-python-3-8-1" title="제목 주소">¶</a></h2>
<p>심각한 보안 문제로 인해, <a class="reference internal" href="../library/asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.loop.create_datagram_endpoint()</span></code></a>의 <em>reuse_address</em> 매개 변수는 더는 지원되지 않습니다. 이것은 UDP에서 소켓 옵션 <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>의 동작 때문입니다. 자세한 내용은 <code class="docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code> 설명서를 참조하십시오. (Contributed by Kyle Stanley, Antoine Pitrou, and Yury Selivanov in <a class="reference external" href="https://bugs.python.org/issue37228">bpo-37228</a>.)</p>
</div>
<div class="section" id="notable-changes-in-python-3-8-8">
<h2>파이썬 3.8.8의 주목할만한 변경 사항<a class="headerlink" href="#notable-changes-in-python-3-8-8" title="제목 주소">¶</a></h2>
<p>Earlier Python versions allowed using both <code class="docutils literal notranslate"><span class="pre">;</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as
query parameter separators in <a class="reference internal" href="../library/urllib.parse.html#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.parse_qs()</span></code></a> and
<a class="reference internal" href="../library/urllib.parse.html#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.parse_qsl()</span></code></a>.  Due to security concerns, and to conform with
newer W3C recommendations, this has been changed to allow only a single
separator key, with <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as the default.  This change also affects
<a class="reference internal" href="../library/cgi.html#cgi.parse" title="cgi.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">cgi.parse()</span></code></a> and <a class="reference internal" href="../library/cgi.html#cgi.parse_multipart" title="cgi.parse_multipart"><code class="xref py py-func docutils literal notranslate"><span class="pre">cgi.parse_multipart()</span></code></a> as they use the affected
functions internally. For more details, please see their respective
documentation.
(Contributed by Adam Goldschmidt, Senthil Kumaran and Ken Jin in <a class="reference external" href="https://bugs.python.org/issue42967">bpo-42967</a>.)</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">파이썬 3.8의 새로운 기능</a><ul>
<li><a class="reference internal" href="#summary-release-highlights">요약 -- 배포 주요 사항</a></li>
<li><a class="reference internal" href="#new-features">새로운 기능</a><ul>
<li><a class="reference internal" href="#assignment-expressions">대입 표현식</a></li>
<li><a class="reference internal" href="#positional-only-parameters">위치 전용 매개 변수</a></li>
<li><a class="reference internal" href="#parallel-filesystem-cache-for-compiled-bytecode-files">컴파일된 바이트 코드 파일을 위한 병렬 파일 시스템 캐시</a></li>
<li><a class="reference internal" href="#debug-build-uses-the-same-abi-as-release-build">디버그 빌드는 릴리스 빌드와 같은 ABI를 사용합니다.</a></li>
<li><a class="reference internal" href="#f-strings-support-for-self-documenting-expressions-and-debugging">f-문자열은 스스로 설명하는 표현식과 디버깅을 위해 =를 지원합니다.</a></li>
<li><a class="reference internal" href="#pep-578-python-runtime-audit-hooks">PEP 578: 파이썬 런타임 감사 훅</a></li>
<li><a class="reference internal" href="#pep-587-python-initialization-configuration">PEP 587: 파이썬 초기화 구성</a></li>
<li><a class="reference internal" href="#pep-590-vectorcall-a-fast-calling-protocol-for-cpython">PEP 590: 벡터콜: CPython을 위한 빠른 호출 프로토콜</a></li>
<li><a class="reference internal" href="#pickle-protocol-5-with-out-of-band-data-buffers">아웃 오브 밴드 데이터 버퍼를 사용하는 피클 프로토콜 5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-language-changes">기타 언어 변경</a></li>
<li><a class="reference internal" href="#new-modules">새 모듈</a></li>
<li><a class="reference internal" href="#improved-modules">개선된 모듈</a><ul>
<li><a class="reference internal" href="#ast">ast</a></li>
<li><a class="reference internal" href="#asyncio">asyncio</a></li>
<li><a class="reference internal" href="#builtins">builtins</a></li>
<li><a class="reference internal" href="#collections">collections</a></li>
<li><a class="reference internal" href="#cprofile">cProfile</a></li>
<li><a class="reference internal" href="#csv">csv</a></li>
<li><a class="reference internal" href="#curses">curses</a></li>
<li><a class="reference internal" href="#ctypes">ctypes</a></li>
<li><a class="reference internal" href="#datetime">datetime</a></li>
<li><a class="reference internal" href="#functools">functools</a></li>
<li><a class="reference internal" href="#gc">gc</a></li>
<li><a class="reference internal" href="#gettext">gettext</a></li>
<li><a class="reference internal" href="#gzip">gzip</a></li>
<li><a class="reference internal" href="#idle-and-idlelib">IDLE과 idlelib</a></li>
<li><a class="reference internal" href="#inspect">inspect</a></li>
<li><a class="reference internal" href="#io">io</a></li>
<li><a class="reference internal" href="#itertools">itertools</a></li>
<li><a class="reference internal" href="#json-tool">json.tool</a></li>
<li><a class="reference internal" href="#logging">logging</a></li>
<li><a class="reference internal" href="#math">math</a></li>
<li><a class="reference internal" href="#mmap">mmap</a></li>
<li><a class="reference internal" href="#multiprocessing">multiprocessing</a></li>
<li><a class="reference internal" href="#os">os</a></li>
<li><a class="reference internal" href="#os-path">os.path</a></li>
<li><a class="reference internal" href="#pathlib">pathlib</a></li>
<li><a class="reference internal" href="#pickle">pickle</a></li>
<li><a class="reference internal" href="#plistlib">plistlib</a></li>
<li><a class="reference internal" href="#pprint">pprint</a></li>
<li><a class="reference internal" href="#py-compile">py_compile</a></li>
<li><a class="reference internal" href="#shlex">shlex</a></li>
<li><a class="reference internal" href="#shutil">shutil</a></li>
<li><a class="reference internal" href="#socket">socket</a></li>
<li><a class="reference internal" href="#ssl">ssl</a></li>
<li><a class="reference internal" href="#statistics">statistics</a></li>
<li><a class="reference internal" href="#sys">sys</a></li>
<li><a class="reference internal" href="#tarfile">tarfile</a></li>
<li><a class="reference internal" href="#threading">threading</a></li>
<li><a class="reference internal" href="#tokenize">tokenize</a></li>
<li><a class="reference internal" href="#tkinter">tkinter</a></li>
<li><a class="reference internal" href="#time">time</a></li>
<li><a class="reference internal" href="#typing">typing</a></li>
<li><a class="reference internal" href="#unicodedata">unicodedata</a></li>
<li><a class="reference internal" href="#unittest">unittest</a></li>
<li><a class="reference internal" href="#venv">venv</a></li>
<li><a class="reference internal" href="#weakref">weakref</a></li>
<li><a class="reference internal" href="#xml">xml</a></li>
<li><a class="reference internal" href="#xmlrpc">xmlrpc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimizations">최적화</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">빌드와 C API 변경</a></li>
<li><a class="reference internal" href="#deprecated">폐지</a></li>
<li><a class="reference internal" href="#api-and-feature-removals">API 및 기능 제거</a></li>
<li><a class="reference internal" href="#porting-to-python-3-8">파이썬 3.8로 이식하기</a><ul>
<li><a class="reference internal" href="#changes-in-python-behavior">파이썬 동작의 변경</a></li>
<li><a class="reference internal" href="#changes-in-the-python-api">파이썬 API의 변경</a></li>
<li><a class="reference internal" href="#changes-in-the-c-api">C API의 변경</a></li>
<li><a class="reference internal" href="#cpython-bytecode-changes">CPython 바이트 코드 변경</a></li>
<li><a class="reference internal" href="#demos-and-tools">데모와 도구</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notable-changes-in-python-3-8-1">파이썬 3.8.1의 주목할만한 변경 사항</a></li>
<li><a class="reference internal" href="#notable-changes-in-python-3-8-8">파이썬 3.8.8의 주목할만한 변경 사항</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="3.9.html"
                        title="이전 장">파이썬 3.9의 새로운 기능</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="3.7.html"
                        title="다음 장">파이썬 3.7의 새로운 기능</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="3.7.html" title="파이썬 3.7의 새로운 기능"
             >다음</a> |</li>
        <li class="right" >
          <a href="3.9.html" title="파이썬 3.9의 새로운 기능"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬의 새로운 기능</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>