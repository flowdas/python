
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>파이썬 모듈 설치 (레거시 버전) &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="prev" title="9. API 레퍼런스" href="../distutils/apiref.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/install/index.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="../distutils/apiref.html" title="9. API 레퍼런스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="installing-python-modules-legacy-version">
<span id="install-index"></span><h1>파이썬 모듈 설치 (레거시 버전)<a class="headerlink" href="#installing-python-modules-legacy-version" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">저자</dt>
<dd class="field-odd"><p>Greg Ward</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference internal" href="../installing/index.html#installing-index"><span class="std std-ref">파이썬 모듈 설치하기</span></a></dt><dd><p>최신 모듈 설치 설명서. 일반적인 파이썬 사용이라면, 거의 확실하게 이 설명서를 원할 것입니다.</p>
</dd>
</dl>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 문서는 <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html">https://setuptools.readthedocs.io/en/latest/setuptools.html</a> 의 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 설명서가 현재 여기에 포함된 모든 관련 정보를 독립적으로 다루기 전까지만 보존됩니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 지침서에서는 이 파이썬 버전의 일부로 제공되는 확장을 빌드하고 배포하기 위한 기본 도구만 다룹니다. 제삼자 도구는 사용하기 쉽고 더 안전한 대안을 제공합니다. 자세한 정보는 파이썬 패키징 사용자 지침서의 <a class="reference external" href="https://packaging.python.org/guides/tool-recommendations/">quick recommendations section</a>을 참조하십시오.</p>
</div>
<div class="section" id="introduction">
<span id="inst-intro"></span><h2>소개<a class="headerlink" href="#introduction" title="제목 주소">¶</a></h2>
<p>파이썬 2.0에서, <code class="docutils literal notranslate"><span class="pre">distutils</span></code> API가 처음으로 표준 라이브러리에 추가되었습니다. 이는 리눅스 배포 관리자에게 파이썬 프로젝트를 리눅스 배포 패키지로 변환하는 표준 방법을 제공하고, 시스템 관리자에게는 대상 시스템에 직접 설치하는 표준 방법을 제공했습니다.</p>
<p>파이썬 2.0이 출시된 이후 수년 동안, 빌드 시스템과 패키지 설치 프로그램을 언어 런타임 배포 주기에 밀접하게 연결하는 것은 문제가 되는 것으로 밝혀졌으며, 이제 프로젝트는 <code class="docutils literal notranslate"><span class="pre">distutils</span></code>를 직접 사용하기보다, <code class="docutils literal notranslate"><span class="pre">pip</span></code> 패키지 설치 프로그램과 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 빌드 시스템을 사용하도록 권장합니다.</p>
<p>자세한 내용은 <a class="reference internal" href="../installing/index.html#installing-index"><span class="std std-ref">파이썬 모듈 설치하기</span></a>와 <a class="reference internal" href="../distributing/index.html#distributing-index"><span class="std std-ref">파이썬 모듈 배포하기</span></a>를 참조하십시오.</p>
<p>이 레거시 설명서는 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 설명서가 필요한 모든 것을 다루고 있다고 확신할 때까지만 유지됩니다.</p>
<div class="section" id="distutils-based-source-distributions">
<span id="inst-new-standard"></span><h3>Distutils 기반 소스 배포<a class="headerlink" href="#distutils-based-source-distributions" title="제목 주소">¶</a></h3>
<p>모듈 소스 배포판을 다운로드하면, 표준 방식으로, 즉 Distutils를 사용하여 패키징되고 배포되었는지 매우 빠르게 알 수 있습니다. 첫째, 배포판의 이름과 버전 번호는 다운로드 한 아카이브의 이름(예를 들어 <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code>나 <code class="file docutils literal notranslate"><span class="pre">widget-0.9.7.zip</span></code>)에 눈에 띄게 표시됩니다. 다음으로, 아카이브는 비슷한 이름의 디렉터리에 압축 해제됩니다: <code class="file docutils literal notranslate"><span class="pre">foo-1.0</span></code>이나 <code class="file docutils literal notranslate"><span class="pre">widget-0.9.7</span></code>. 또한, 배포판에는 설정 스크립트 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>와 <code class="file docutils literal notranslate"><span class="pre">README.txt</span></code> 또는 어쩌면 단순히 <code class="file docutils literal notranslate"><span class="pre">README</span></code> 라는 파일이 포함됩니다. 이 파일은 모듈 배포판을 빌드하고 설치하는 것이 터미널에서 하나의 명령을 실행하는 간단한 문제임을 설명해야 합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install
</pre></div>
</div>
<p>윈도우의 경우, 이 명령은 명령 프롬프트 창(<span class="menuselection">Start ‣ Accessories</span>)에서 실행해야 합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>setup.py install
</pre></div>
</div>
<p>이 모든 것이 참이면, 방금 다운로드 한 모듈을 빌드하고 설치하는 방법을 이미 알고 있는 것입니다: 위의 명령을 실행하십시오. 비표준 방식으로 설치하거나 빌드 프로세스를 사용자 정의해야 하는 경우가 아니라면, 이 설명서가 실제로 필요하지는 않습니다. 또는, 위의 명령은 이 설명서에서 벗어나는 데 필요한 모든 것입니다.</p>
</div>
</div>
<div class="section" id="standard-build-and-install">
<span id="inst-standard-install"></span><h2>표준 빌드와 설치<a class="headerlink" href="#standard-build-and-install" title="제목 주소">¶</a></h2>
<p>섹션 <a class="reference internal" href="#inst-new-standard"><span class="std std-ref">Distutils 기반 소스 배포</span></a>에 설명된 대로, Distutils를 사용하여 모듈 배포를 빌드하고 설치하는 것은 일반적으로 터미널에서 실행하는 하나의 간단한 명령입니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install
</pre></div>
</div>
<div class="section" id="platform-variations">
<span id="inst-platform-variations"></span><h3>플랫폼 변형<a class="headerlink" href="#platform-variations" title="제목 주소">¶</a></h3>
<p>항상 배포 루트 디렉터리, 즉 모듈 소스 배포가 압축 해제된 최상위 서브 디렉터리에서 setup 명령을 실행해야 합니다. 예를 들어, 모듈 소스 배포 <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code>를 유닉스 시스템에 방금 다운로드했다면, 일반적인 작업은 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gunzip -c foo-1.0.tar.gz | tar xf -    # 디렉터리 foo-1.0 으로 압축 해제합니다
cd foo-1.0
python setup.py install
</pre></div>
</div>
<p>윈도우에서는, 아마도 <code class="file docutils literal notranslate"><span class="pre">foo-1.0.zip</span></code>을 다운로드할 것입니다. 아카이브 파일을 <code class="file docutils literal notranslate"><span class="pre">C:\Temp</span></code>로 다운로드했으면, <code class="file docutils literal notranslate"><span class="pre">C:\Temp\foo-1.0</span></code>으로 압축이 풀립니다; 그래픽 사용자 인터페이스가 있는 아카이브 조작기(가령 WinZip)나 명령 줄 도구(가령 <strong class="program">unzip</strong>이나 <strong class="program">pkunzip</strong>)를 사용하여 아카이브의 압축을 풀 수 있습니다. 그런 다음 명령 프롬프트 창을 열고 다음을 실행하십시오:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cd c:\Temp\foo-1.0
python setup.py install
</pre></div>
</div>
</div>
<div class="section" id="splitting-the-job-up">
<span id="inst-splitting-up"></span><h3>작업 분할하기<a class="headerlink" href="#splitting-the-job-up" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">setup.py</span> <span class="pre">install</span></code>을 실행하면 한 번의 실행으로 모든 모듈을 빌드하고 설치합니다. 점진적으로 작업하는 것을 선호하면---특히 빌드 프로세스를 사용자 정의하거나, 문제가 발생하면 특히 유용합니다---설정 스크립트를 사용하여 한 번에 한 가지 작업을 수행할 수 있습니다. 이는 빌드와 설치를 다른 사용자가 수행할 때 특히 유용합니다---예를 들어, 모듈 배포를 빌드하고 설치를 위해 시스템 관리자에게 넘겨주고 싶을 수 있습니다 (또는 슈퍼 유저 권한으로, 직접 수행합니다).</p>
<p>예를 들어, 설정 스크립트를 두 번 호출하여 한 단계에서 모든 것을 빌드한 다음, 두 번째 단계에서 모든 것을 설치할 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build
python setup.py install
</pre></div>
</div>
<p>이렇게 하면, <strong class="command">install</strong> 명령을 실행하면 먼저 <strong class="command">build</strong> 명령이 실행된다는 것을 알 수 있습니다. 이 경우 <code class="file docutils literal notranslate"><span class="pre">build</span></code> 디렉터리의 모든 내용이 최신 상태이므로 수행할 작업이 없음을 빠르게 알 수 있습니다.</p>
<p>'여러분이 하는 일이 넷에서 다운로드 한 모듈을 설치하는 것뿐이라면, 작업을 분할하는 이 기능이 자주 필요하지 않을 수 있지만, 고급 작업에는 매우 편리합니다. 여러분 자신의 파이썬 모듈과 확장을 배포한다면, 많은 개별 Distutils 명령을 실행하게 됩니다.</p>
</div>
<div class="section" id="how-building-works">
<span id="inst-how-build-works"></span><h3>빌드 작동 원리<a class="headerlink" href="#how-building-works" title="제목 주소">¶</a></h3>
<p>위에서 암시했듯이, <strong class="command">build</strong> 명령은 설치할 파일을 <em>빌드 디렉터리</em>에 넣는 역할을 합니다. 기본적으로, 이것은 배포 루트 아래의 <code class="file docutils literal notranslate"><span class="pre">build</span></code>입니다; 속도에 지나치게 신경을 쓰거나 소스 트리를 원래 상태로 유지하려면, <code class="xref std std-option docutils literal notranslate"><span class="pre">--build-base</span></code> 옵션을 사용하여 빌드 디렉터리를 변경할 수 있습니다. 예를 들면:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build --build-base=/path/to/pybuild/foo-1.0
</pre></div>
</div>
<p>(또는 시스템이나 개인 Distutils 구성 파일의 지시문을 사용하여 영구적으로 이렇게 만들 수 있습니다; 섹션 <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 구성 파일</span></a>을 참조하십시오.) 일반적으로, 이 작업은 필요하지 않습니다.</p>
<p>빌드 트리의 기본 레이아웃은 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- build/ --- lib/
or
--- build/ --- lib.&lt;plat&gt;/
               temp.&lt;plat&gt;/
</pre></div>
</div>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">&lt;plat&gt;</span></code>은 현재 OS/하드웨어 플랫폼과 파이썬 버전에 대한 간략한 설명으로 확장됩니다. <code class="file docutils literal notranslate"><span class="pre">lib</span></code> 디렉터리 만 있는 첫 번째 형식은 &quot;순수 모듈 배포&quot;(즉 순수한 파이썬 모듈만 포함하는 모듈 배포)에 사용됩니다. 모듈 배포가 확장(C/C++로 작성된 모듈)을 포함하면, 두 개의 <code class="docutils literal notranslate"><span class="pre">&lt;plat&gt;</span></code> 디렉터리가 있는 두 번째 형식이 사용됩니다. 이 경우, <code class="file docutils literal notranslate"><span class="pre">temp.</span><em><span class="pre">plat</span></em></code> 디렉터리는 실제로 설치되지 않는 컴파일/링크 프로세스에 의해 생성된 임시 파일을 보유합니다. 두 경우 모두, <code class="file docutils literal notranslate"><span class="pre">lib</span></code> (또는 <code class="file docutils literal notranslate"><span class="pre">lib.</span><em><span class="pre">plat</span></em></code>) 디렉터리에는 설치될 모든 파이썬 모듈(순수 파이썬과 확장)이 포함됩니다.</p>
<p>향후에는, 파이썬 스크립트, 설명서, 바이너리 실행 파일 및 파이썬 모듈과 응용 프로그램 설치 작업을 처리하는 데 필요한 모든 것을 처리하기 위해 더 많은 디렉터리가 추가될 것입니다.</p>
</div>
<div class="section" id="how-installation-works">
<span id="inst-how-install-works"></span><h3>설치 작동 원리<a class="headerlink" href="#how-installation-works" title="제목 주소">¶</a></h3>
<p><strong class="command">build</strong> 명령이 실행된 후 (명시적으로 실행하든, <strong class="command">install</strong> 명령이 자동으로 수행하든), <strong class="command">install</strong> 명령의 작업은 비교적 간단합니다; <code class="file docutils literal notranslate"><span class="pre">build/lib</span></code> (또는 <code class="file docutils literal notranslate"><span class="pre">build/lib.</span><em><span class="pre">plat</span></em></code>) 아래의 모든 것을 선택한 설치 디렉터리에 복사하기만 하면 됩니다.</p>
<p>설치 디렉터리를 선택하지 않으면---즉, <code class="docutils literal notranslate"><span class="pre">setup.py</span> <span class="pre">install</span></code>만 실행하면---<strong class="command">install</strong> 명령이 제삼자 파이썬 모듈의 표준 위치에 설치됩니다. 이 위치는 플랫폼과 파이썬 자체를 빌드/설치한 방법에 따라 다릅니다. 유닉스(그리고 Mac OS X, 이 역시 유닉스 기반입니다)에서는, 설치되는 모듈 배포판이 순수 파이썬인지 또는 확장(&quot;비순수&quot;)을 포함하는지에 따라 다릅니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 42%" />
<col style="width: 39%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>플랫폼</p></th>
<th class="head"><p>표준 설치 위치</p></th>
<th class="head"><p>기본값</p></th>
<th class="head"><p>노트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>유닉스 (순수)</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p>유닉스 (비순수)</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-even"><td><p>윈도우</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">C:\Python</span><em><span class="pre">XY</span></em><span class="pre">\Lib\site-packages</span></code></p></td>
<td><p>(2)</p></td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic simple">
<li><p>대부분의 리눅스 배포에는 파이썬이 시스템의 표준 부분으로 포함되어 있어서, <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>와 <code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em></code>는 일반적으로 리눅스에서 모두 <code class="file docutils literal notranslate"><span class="pre">/usr</span></code>입니다. 리눅스(또는 모든 유닉스 계열 시스템)에서 파이썬을 직접 빌드하면, 기본 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>와 <code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em></code>는 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>입니다.</p></li>
<li><p>윈도우의 기본 설치 디렉터리는 파이썬 1.6a1, 1.5.2 및 이전 버전에서 <code class="file docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></code>이었습니다.</p></li>
</ol>
<p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>와 <code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em></code>는 파이썬이 설치된 디렉터리와 실행 시간에 라이브러리를 찾는 위치를 나타냅니다. 윈도우에서는 항상 같으며, 유닉스와 Mac OS X에서도 아주 자주 같습니다. 대화 형 모드에서 파이썬을 실행하고 몇 가지 간단한 명령을 입력하여 파이썬 설치가 사용한 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>와 <code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em></code>를 확인할 수 있습니다. 유닉스에서는, 셸 프롬프트에서 <code class="docutils literal notranslate"><span class="pre">python</span></code>을 입력하기만 하면 됩니다. 윈도우에서는, <span class="menuselection">Start ‣ Programs ‣ Python X.Y ‣ Python (command line)</span>을 선택합니다. 일단 인터프리터가 시작되면, 프롬프트에 파이썬 코드를 입력합니다. 예를 들어, 제 리눅스 시스템에서, 저는 아래 표시된 세 개의 파이썬 문을 입력하고, 표시된 출력을 얻어서, 제 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>와 <code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em></code>를 찾습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">Python 2.4 (#26, Aug  7 2004, 17:19:02)</span>
<span class="go">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">prefix</span>
<span class="go">&#39;/usr&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">exec_prefix</span>
<span class="go">&#39;/usr&#39;</span>
</pre></div>
</div>
<p>이 설명서에는 몇 가지 다른 자리 표시자가 사용됩니다: <code class="file docutils literal notranslate"><em><span class="pre">X.Y</span></em></code>는 파이썬 버전을 나타냅니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">3.2</span></code>; <code class="file docutils literal notranslate"><em><span class="pre">abiflags</span></em></code>는 <a class="reference internal" href="../library/sys.html#sys.abiflags" title="sys.abiflags"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.abiflags</span></code></a> 값이나 ABI 플래그를 정의하지 않는 플랫폼에서는 빈 문자열로 대체됩니다; <code class="file docutils literal notranslate"><em><span class="pre">distname</span></em></code>은 설치 중인 모듈 배포의 이름으로 대체됩니다. 경로에서 점과 대문자는 중요합니다; 예를 들어, 유닉스에서 <code class="docutils literal notranslate"><span class="pre">python3.2</span></code>를 사용하는 값은 일반적으로 윈도우에서 <code class="docutils literal notranslate"><span class="pre">Python32</span></code>를 사용합니다.</p>
<p>표준 위치에 모듈을 설치하고 싶지 않거나, 거기에 쓸 권한이 없다면, <a class="reference internal" href="#inst-alt-install"><span class="std std-ref">대안 설치</span></a> 섹션에서 대안 설치에 대해 읽어야 합니다. 설치 디렉터리를 더 많이 사용자 정의하려면, 사용자 정의 설치에 대한 섹션 <a class="reference internal" href="#inst-custom-install"><span class="std std-ref">사용자 정의 설치</span></a>를 참조하십시오.</p>
</div>
</div>
<div class="section" id="alternate-installation">
<span id="inst-alt-install"></span><h2>대안 설치<a class="headerlink" href="#alternate-installation" title="제목 주소">¶</a></h2>
<p>종종, 제삼자 파이썬 모듈의 표준 위치가 아닌 다른 위치에 모듈을 설치하는 것이 필요하거나 바람직합니다. 예를 들어, 유닉스 시스템에서 표준 제삼자 모듈 디렉터리에 대해 쓰기 권한이 없을 수 있습니다. 또는 로컬 파이썬 설치의 표준 부분으로 만들기 전에 모듈을 시험해 보고 싶을 수도 있습니다. 이미 존재하는 배포판을 업그레이드할 때 특히 그렇습니다; 실제로 업그레이드하기 전에 기존 스크립트 기반이 새 버전에서 계속 작동하는지 확인하려고 합니다.</p>
<p>Distutils <strong class="command">install</strong> 명령은 모듈 배포를 대안 위치에 간단하고 쉽게 설치할 수 있도록 설계되었습니다. 기본 아이디어는 여러분이 설치를 위한 기본 디렉터리를 제공하고, <strong class="command">install</strong> 명령은 이 기본 디렉터리 아래에서 파일을 설치할 디렉터리 집합(<em>설치 체계(installation scheme)</em>라고 합니다)을 선택하는 것입니다. 세부 정보는 플랫폼에 따라 다르므로, 다음 섹션 중 자신에게 해당하는 항목을 읽으십시오.</p>
<p>다양한 대안 설치 체계는 상호 배타적입니다: <code class="docutils literal notranslate"><span class="pre">--user</span></code>, <code class="docutils literal notranslate"><span class="pre">--home</span></code>, <code class="docutils literal notranslate"><span class="pre">--prefix</span></code>와 <code class="docutils literal notranslate"><span class="pre">--exec-prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">--install-base</span></code> 및 <code class="docutils literal notranslate"><span class="pre">--install-platbase</span></code>를 전달할 수 있지만, 이러한 그룹에서 혼합할 수는 없습니다.</p>
<div class="section" id="alternate-installation-the-user-scheme">
<span id="inst-alt-install-user"></span><h3>대안 설치: 사용자 체계<a class="headerlink" href="#alternate-installation-the-user-scheme" title="제목 주소">¶</a></h3>
<p>이 체계는 전역 site-packages 디렉터리에 대해 쓰기 권한이 없거나, 그곳에 설치를 원하지 않는 사용자에게 가장 편리한 솔루션이 되도록 설계되었습니다. 다음과 같은 간단한 옵션으로 활성화됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --user
</pre></div>
</div>
<p>파일은 <a class="reference internal" href="../library/site.html#site.USER_BASE" title="site.USER_BASE"><code class="xref py py-data docutils literal notranslate"><span class="pre">site.USER_BASE</span></code></a>(이하 <code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em></code>로 씁니다)의 서브 디렉터리에 설치됩니다. 이 체계는 같은 위치(<a class="reference internal" href="../library/site.html#site.USER_SITE" title="site.USER_SITE"><code class="xref py py-data docutils literal notranslate"><span class="pre">site.USER_SITE</span></code></a>라고도 합니다)에 순수 파이썬 모듈과 확장 모듈을 설치합니다. 다음은 Mac OS X를 포함하는 유닉스의 값입니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>설치 디렉터리</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>모듈</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>스크립트</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">/bin</span></code></p></td>
</tr>
<tr class="row-even"><td><p>데이터</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em></code></p></td>
</tr>
<tr class="row-odd"><td><p>C 헤더</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em><em><span class="pre">abiflags</span></em><span class="pre">/</span><em><span class="pre">distname</span></em></code></p></td>
</tr>
</tbody>
</table>
<p>그리고 다음은 윈도우에서 사용되는 값입니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>설치 디렉터리</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>모듈</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\site-packages</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>스크립트</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\Scripts</span></code></p></td>
</tr>
<tr class="row-even"><td><p>데이터</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em></code></p></td>
</tr>
<tr class="row-odd"><td><p>C 헤더</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\Include{distname}</span></code></p></td>
</tr>
</tbody>
</table>
<p>아래에 설명된 다른 체계에 비해 이 체계를 사용하는 이점은 사용자 site-packages 디렉터리가 항상 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>에 포함되어있는 정상적인 조건에 있다는 것입니다 (자세한 내용은 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a>를 참조하십시오), 이는 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 스크립트를 실행한 후에 설치를 완료하기 위해 수행할 추가 단계가 없다는 뜻입니다.</p>
<p><strong class="command">build_ext</strong> 명령에도 <code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">/include</span></code>를 헤더 파일의 컴파일러 검색 경로에 추가하고 <code class="file docutils literal notranslate"><em><span class="pre">userbase</span></em><span class="pre">/lib</span></code>를 라이브러리의 컴파일러 검색 경로뿐만 아니라 공유 C 라이브러리의 실행 시간 검색 경로(rpath)에 추가하는 <code class="docutils literal notranslate"><span class="pre">--user</span></code> 옵션이 있습니다.</p>
</div>
<div class="section" id="alternate-installation-the-home-scheme">
<span id="inst-alt-install-home"></span><h3>대안 설치: 홈 체계<a class="headerlink" href="#alternate-installation-the-home-scheme" title="제목 주소">¶</a></h3>
<p>&quot;홈 체계&quot;의 배후에 있는 아이디어는 파이썬 모듈의 개인 보관함을 구축하고 유지하는 것입니다. 이 체계의 이름은 유닉스의 &quot;홈(home)&quot; 디렉터리의 아이디어에서 파생되었는데, 유닉스 사용자가 홈 디렉터리를 <code class="file docutils literal notranslate"><span class="pre">/usr/</span></code>이나 <code class="file docutils literal notranslate"><span class="pre">/usr/local/</span></code>과 유사한 배치로 만드는 것이 드문 일이 아니기 때문입니다. 이 체계는 설치하는 운영 체제와 관계없이 누구나 사용할 수 있습니다.</p>
<p>새 모듈 배포판을 설치하는 것은 다음과 같이 간단합니다</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --home=&lt;dir&gt;
</pre></div>
</div>
<p>여기서 <code class="xref std std-option docutils literal notranslate"><span class="pre">--home</span></code> 옵션에 원하는 디렉터리를 제공할 수 있습니다. 유닉스에서, 게으른 타이피스트는 물결표(<code class="docutils literal notranslate"><span class="pre">~</span></code>)만 입력할 수 있습니다; <strong class="command">install</strong> 명령은 이를 여러분의 홈 디렉터리로 확장합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --home=~
</pre></div>
</div>
<p>파이썬이 이 체계로 설치된 배포판을 찾도록 하려면, <a class="reference internal" href="#inst-search-path"><span class="std std-ref">파이썬의 검색 경로를 수정</span></a>하거나 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sitecustomize</span></code> (<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 참조)를 편집하여 <a class="reference internal" href="../library/site.html#site.addsitedir" title="site.addsitedir"><code class="xref py py-func docutils literal notranslate"><span class="pre">site.addsitedir()</span></code></a> 을 호출하거나 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>를 편집해야 합니다.</p>
<p><code class="xref std std-option docutils literal notranslate"><span class="pre">--home</span></code> 옵션은 설치 기본 디렉터리를 정의합니다. 파일은 다음과 같이 설치 기본 디렉터리 아래의 다음 디렉터리에 설치됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>설치 디렉터리</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>모듈</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">home</span></em><span class="pre">/lib/python</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>스크립트</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">home</span></em><span class="pre">/bin</span></code></p></td>
</tr>
<tr class="row-even"><td><p>데이터</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">home</span></em></code></p></td>
</tr>
<tr class="row-odd"><td><p>C 헤더</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">home</span></em><span class="pre">/include/python/</span><em><span class="pre">distname</span></em></code></p></td>
</tr>
</tbody>
</table>
<p>(윈도우를 사용하면 슬래시를 역 슬래시로 바꾸십시오.)</p>
</div>
<div class="section" id="alternate-installation-unix-the-prefix-scheme">
<span id="inst-alt-install-prefix-unix"></span><h3>대안 설치: 유닉스 (접두사 체계)<a class="headerlink" href="#alternate-installation-unix-the-prefix-scheme" title="제목 주소">¶</a></h3>
<p>&quot;접두사 체계(prefix scheme)&quot;는 하나의 파이썬 설치를 사용하여 빌드/설치(즉 설정 스크립트 실행)를 수행하지만, 다른 파이썬 설치(또는 다른 파이썬 설치처럼 보이는 무엇)의 제삼자 모듈 디렉터리로 모듈을 설치할 때 유용합니다. 이것이 다소 비정상적으로 들린다면, 실제로 그렇습니다--사용자와 홈 체계가 앞에 나온 이유입니다. 그러나, 접두사 체계가 유용하다고 알려진 사례가 적어도 두 개 있습니다.</p>
<p>첫째, 많은 리눅스 배포판에서 파이썬을 더 전통적인 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>이 아닌 <code class="file docutils literal notranslate"><span class="pre">/usr</span></code>에 넣는다는 점을 고려하십시오. 이 경우 파이썬은 로컬 애드온이 아닌 &quot;시스템&quot;의 일부이기 때문에, 전적으로 적절합니다. 그러나, 소스에서 파이썬 모듈을 설치하면, <code class="file docutils literal notranslate"><span class="pre">/usr/lib/python2.</span><em><span class="pre">X</span></em></code> 가 아닌 <code class="file docutils literal notranslate"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></code> 로 보내기를 원할 것입니다. 이것은 다음처럼 할 수 있습니다</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/bin/python setup.py install --prefix=/usr/local
</pre></div>
</div>
<p>또 다른 가능성은 원격 디렉터리에 쓰는 데 사용되는 이름이 이를 읽는 데 사용되는 이름과 다른 네트워크 파일 시스템입니다: 예를 들어, <code class="file docutils literal notranslate"><span class="pre">/usr/local/bin/python</span></code>으로 액세스한 파이썬 인터프리터는 <code class="file docutils literal notranslate"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></code> 에서 모듈을 검색하지만, 해당 모듈은 가령 <code class="file docutils literal notranslate"><span class="pre">/mnt/</span><em><span class="pre">&#64;server</span></em><span class="pre">/export/lib/python2.</span><em><span class="pre">X</span></em></code> 에 설치해야 합니다. 이것은 다음처럼 할 수 있습니다</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/local/bin/python setup.py install --prefix=/mnt/@server/export
</pre></div>
</div>
<p>두 경우 모두, <code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code> 옵션은 설치 기본 디렉터리를 정의하고, <code class="xref std std-option docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 옵션은 플랫폼별 파일에 사용되는 플랫폼별 설치 기본 디렉터리를 정의합니다. (현재, 이것은 단지 순수하지 않은 모듈 배포를 뜻하지만, C 라이브러리, 바이너리 실행 파일 등으로 확장 할 수 있습니다.) <code class="xref std std-option docutils literal notranslate"><span class="pre">--exec-prefix</span></code>가 제공되지 않으면, 기본값은 <code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code>입니다. 파일은 다음과 같이 설치됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>설치 디렉터리</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>파이썬 모듈</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>확장 모듈</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></p></td>
</tr>
<tr class="row-even"><td><p>스크립트</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">/bin</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>데이터</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code></p></td>
</tr>
<tr class="row-even"><td><p>C 헤더</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em><em><span class="pre">abiflags</span></em><span class="pre">/</span><em><span class="pre">distname</span></em></code></p></td>
</tr>
</tbody>
</table>
<p><code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code>나 <code class="xref std std-option docutils literal notranslate"><span class="pre">--exec-prefix</span></code>가 실제로 대안 파이썬 설치를 가리킬 필요는 없습니다; 위에 나열된 디렉터리가 아직 존재하지 않으면, 설치 시 만들어집니다.</p>
<p>덧붙여서, 접두사 체계가 중요한 진짜 이유는 단순히 표준 유닉스 설치가 파이썬 자체에서 <code class="docutils literal notranslate"><span class="pre">sys.prefix</span></code>와 <code class="docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code>로 제공되는 <code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code>와 <code class="xref std std-option docutils literal notranslate"><span class="pre">--exec-prefix</span></code>를 사용하는 접두사 체계를 사용하는 것입니다. 따라서, 여러분이 접두사 체계를 사용하지 않으리라 생각할 수 있지만, 다른 옵션 없이 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code>을 실행할 때마다 이를 사용하고 있는 것입니다.</p>
<p>대안 파이썬 설치에 확장을 설치하는 것은 해당 확장이 빌드되는 방식에 영향을 미치지 않음에 유의하십시오: 특히, 설치 스크립트를 실행하는 데 사용되는 파이썬 인터프리터와 함께 설치된 파이썬 헤더 파일(<code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>와 그 동료들)이 확장을 컴파일하는 데 사용됩니다. 이러한 방식으로 설치된 확장 프로그램을 실행하는 데 사용되는 인터프리터가 이를 빌드하는 데 사용된 인터프리터와 호환되는지 확인하는 것은 여러분의 책임입니다. 이를 수행하는 가장 좋은 방법은 두 인터프리터가 같은 파이썬 버전(다른 빌드 또는 같은 빌드의 복사본일 수 있습니다)인지 확인하는 것입니다. (물론, <code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code>와 <code class="xref std std-option docutils literal notranslate"><span class="pre">--exec-prefix</span></code>가 대안 파이썬 설치를 가리키지 않으면, 이는 중요하지 않습니다.)</p>
</div>
<div class="section" id="alternate-installation-windows-the-prefix-scheme">
<span id="inst-alt-install-prefix-windows"></span><h3>대안 설치: 윈도우 (접두사 체계)<a class="headerlink" href="#alternate-installation-windows-the-prefix-scheme" title="제목 주소">¶</a></h3>
<p>윈도우에는 사용자의 홈 디렉터리에 대한 개념이 없으며, 윈도우에서 표준 파이썬 설치가 유닉스보다 간단하기 때문에, 전통적으로 <code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code> 옵션은 윈도우의 별도 위치에 추가 패키지를 설치하는 데 사용되어 왔습니다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --prefix=&quot;\Temp\Python&quot;
</pre></div>
</div>
<p>이것은 현재 드라이브의 <code class="file docutils literal notranslate"><span class="pre">\Temp\Python</span></code> 디렉터리에 모듈을 설치합니다.</p>
<p>설치 기본 디렉터리는 <code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code> 옵션으로 정의됩니다; <code class="xref std std-option docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 옵션은 윈도우에서 지원되지 않습니다. 이는 순수 파이썬 모듈과 확장 모듈이 같은 위치에 설치됨을 뜻합니다. 파일은 다음과 같이 설치됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>설치 디렉터리</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>모듈</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>스크립트</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">\Scripts</span></code></p></td>
</tr>
<tr class="row-even"><td><p>데이터</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code></p></td>
</tr>
<tr class="row-odd"><td><p>C 헤더</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">\Include{distname}</span></code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="custom-installation">
<span id="inst-custom-install"></span><h2>사용자 정의 설치<a class="headerlink" href="#custom-installation" title="제목 주소">¶</a></h2>
<p>때에 따라, 섹션 <a class="reference internal" href="#inst-alt-install"><span class="std std-ref">대안 설치</span></a>에 설명된 대안 설치 체계는 여러분이 원하는 것을 수행하지 않습니다. 모든 것을 같은 기본 디렉터리 아래에 유지하면서 한두 개의 디렉터리만 조정하거나, 설치 체계를 완전히 재정의하고 싶을 수 있습니다. 두 경우 모두, <em>사용자 정의 설치 체계(custom installation scheme)</em>를 만들고 있는 것입니다.</p>
<p>사용자 정의 설치 체계를 만들려면, 대안 체계 중 하나로 시작하고 다음 옵션을 사용하여 다양한 유형의 파일에 사용되는 일부 설치 디렉터리를 재정의합니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>재정의 옵션</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>파이썬 모듈</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--install-purelib</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>확장 모듈</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--install-platlib</span></code></p></td>
</tr>
<tr class="row-even"><td><p>모든 모듈</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--install-lib</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>스크립트</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--install-scripts</span></code></p></td>
</tr>
<tr class="row-even"><td><p>데이터</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--install-data</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>C 헤더</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--install-headers</span></code></p></td>
</tr>
</tbody>
</table>
<p>이러한 재정의 옵션은 상대적이거나, 절대적이거나 또는 설치 기본 디렉터리 중 하나로 명시적으로 정의될 수 있습니다. (두 개의 설치 기본 디렉터리가 있으며, 일반적으로 같습니다---유닉스 &quot;접두사 체계&quot;를 사용하고 다른 <code class="docutils literal notranslate"><span class="pre">--prefix</span></code>와 <code class="docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 옵션을 제공할 때만 다릅니다; <code class="docutils literal notranslate"><span class="pre">--install-lib</span></code>를 사용하면 <code class="docutils literal notranslate"><span class="pre">--install-purelib</span></code>와 <code class="docutils literal notranslate"><span class="pre">--install-platlib</span></code>에 대해 계산되거나 제공된 값을 재정의합니다, 그리고 이는 파이썬과 확장 모듈 사이에 차이를 두지 않는 체계에 권장됩니다.)</p>
<p>예를 들어, 유닉스에서 홈 디렉터리에 모듈 배포를 설치한다고 합시다---하지만 스크립트가 <code class="file docutils literal notranslate"><span class="pre">~/bin</span></code>이 아닌 <code class="file docutils literal notranslate"><span class="pre">~/scripts</span></code>로 가기를 원합니다. 예상대로, 이 디렉터리를 <code class="xref std std-option docutils literal notranslate"><span class="pre">--install-scripts</span></code> 옵션으로 재정의할 수 있습니다; 이 경우, 상대 경로를 제공하는 것이 가장 합리적인데, 설치 기본 디렉터리(이 경우, 홈 디렉터리)에 상대적으로 해석됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --home=~ --install-scripts=scripts
</pre></div>
</div>
<p>또 다른 유닉스 예: 파이썬 설치가 <code class="file docutils literal notranslate"><span class="pre">/usr/local/python</span></code> 접두사로 빌드되고 설치되었다고 가정하면, 표준 설치 스크립트는 <code class="file docutils literal notranslate"><span class="pre">/usr/local/python/bin</span></code>으로 갑니다. 대신 <code class="file docutils literal notranslate"><span class="pre">/usr/local/bin</span></code>에 넣고 싶으면, <code class="xref std std-option docutils literal notranslate"><span class="pre">--install-scripts</span></code> 옵션에 대해 이렇게 절대 디렉터리를 제공합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --install-scripts=/usr/local/bin
</pre></div>
</div>
<p>(이는 &quot;접두사 체계&quot;를 사용하여 설치를 수행합니다, 여기서 접두사는 파이썬 인터프리터가 설치될 때 사용된 것입니다--- 이 경우 <code class="file docutils literal notranslate"><span class="pre">/usr/local/python</span></code>입니다.)</p>
<p>윈도우에서 파이썬을 유지하는 경우, 제삼자 모듈이 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code> 자체가 아닌 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>의 서브 디렉터리에 위치하기를 원할 수 있습니다. 이것은 거의 스크립트 설치 디렉터리를 사용자 정의하는 것만큼 쉽습니다---여러분은 단지 두 가지 유형의 모듈, 파이썬과 확장 모듈이 있다는 것만 신경 쓰면 되는데, 둘 다 하나의 옵션으로 편리하게 제어할 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --install-lib=Site
</pre></div>
</div>
<p>지정된 설치 디렉터리는 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em></code>에 상대적입니다. 물론, 가령 사이트 디렉터리에 <code class="file docutils literal notranslate"><span class="pre">.pth</span></code> 파일을 넣어서 이 디렉터리가 파이썬의 모듈 검색 경로에 있도록 해야 합니다 (<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a>를 참조하십시오). 파이썬의 검색 경로를 수정하는 방법은 섹션 <a class="reference internal" href="#inst-search-path"><span class="std std-ref">파이썬의 검색 경로 수정하기</span></a>를 참조하십시오.</p>
<p>전체 설치 체계를 정의하려면, 모든 설치 디렉터리 옵션을 제공하기만 하면 됩니다. 이를 수행하는 권장 방법은 상대 경로를 제공하는 것입니다; 예를 들어, 홈 디렉터리의 <code class="file docutils literal notranslate"><span class="pre">python</span></code> 아래에 모든 파이썬 모듈 관련 파일을 유지하고, 홈 디렉터리를 사용하는 각 플랫폼에 대해 별도의 디렉터리를 원하면, 다음 설치 체계를 정의할 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --home=~ \
                        --install-purelib=python/lib \
                        --install-platlib=python/lib.$PLAT \
                        --install-scripts=python/scripts
                        --install-data=python/data
</pre></div>
</div>
<p>또는, 동등하게,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --home=~/python \
                        --install-purelib=lib \
                        --install-platlib=&#39;lib.$PLAT&#39; \
                        --install-scripts=scripts
                        --install-data=data
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">$PLAT</span></code>은 환경 변수가 아닙니다---구성 파일을 구문 분석할 때와 마찬가지로 명령 줄 옵션을 구문 분석할 때 Distutils에 의해 확장됩니다.</p>
<p>분명히, 새로운 모듈 배포판을 설치할 때마다 전체 설치 체계를 지정하는 것은 매우 지루할 것입니다. 따라서, 이러한 옵션을 Distutils 구성 파일에 넣을 수 있습니다 (섹션 <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 구성 파일</span></a>을 참조하십시오):</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[install]</span>
<span class="na">install-base</span><span class="o">=</span><span class="s">$HOME</span>
<span class="na">install-purelib</span><span class="o">=</span><span class="s">python/lib</span>
<span class="na">install-platlib</span><span class="o">=</span><span class="s">python/lib.$PLAT</span>
<span class="na">install-scripts</span><span class="o">=</span><span class="s">python/scripts</span>
<span class="na">install-data</span><span class="o">=</span><span class="s">python/data</span>
</pre></div>
</div>
<p>또는, 동등하게,</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[install]</span>
<span class="na">install-base</span><span class="o">=</span><span class="s">$HOME/python</span>
<span class="na">install-purelib</span><span class="o">=</span><span class="s">lib</span>
<span class="na">install-platlib</span><span class="o">=</span><span class="s">lib.$PLAT</span>
<span class="na">install-scripts</span><span class="o">=</span><span class="s">scripts</span>
<span class="na">install-data</span><span class="o">=</span><span class="s">data</span>
</pre></div>
</div>
<p>설정 스크립트를 실행할 때 다른 설치 기본 디렉터리를 제공하면 이 두 가지는 동등하지 <em>않음에</em> 유의하십시오. 예를 들어,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py install --install-base=/tmp
</pre></div>
</div>
<p>은 첫 번째 경우에는 <code class="file docutils literal notranslate"><span class="pre">/tmp/python/lib</span></code>에, 두 번째 경우에는 <code class="file docutils literal notranslate"><span class="pre">/tmp/lib</span></code>에 순수 모듈을 설치합니다. (두 번째 경우에는, <code class="file docutils literal notranslate"><span class="pre">/tmp/python</span></code>으로 설치 기본 디렉터리를 제공하고 싶을 것입니다.)</p>
<p>아마도 샘플 구성 파일 입력에서 <code class="docutils literal notranslate"><span class="pre">$HOME</span></code>과 <code class="docutils literal notranslate"><span class="pre">$PLAT</span></code>을 사용하는 것을 눈치챘을 것입니다. 이들은 환경 변수와 매우 유사한 Distutils 구성 변수입니다. 실제로, 이러한 개념이 있는 플랫폼의 구성 파일에서 환경 변수를 사용할 수 있지만, Distutils는 <code class="docutils literal notranslate"><span class="pre">$PLAT</span></code>과 같이 사용자 환경에 없을 수 있는 몇 가지 추가 변수를 정의합니다. (그리고 물론, Mac OS 9와 같이 환경 변수가 없는 시스템에서는, Distutils가 제공하는 구성 변수만 사용할 수 있습니다.) 자세한 내용은 섹션 <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 구성 파일</span></a>을 참조하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="../library/venv.html#venv-def"><span class="std std-ref">가상 환경</span></a>이 활성화되면, 가상 환경 외부에 프로젝트를 실수로 설치하는 것을 방지하기 위해 모든 distutils 구성 파일에서 설치 경로를 변경하는 모든 옵션이 무시됩니다.</p>
</div>
<div class="section" id="modifying-python-s-search-path">
<span id="inst-search-path"></span><h3>파이썬의 검색 경로 수정하기<a class="headerlink" href="#modifying-python-s-search-path" title="제목 주소">¶</a></h3>
<p>파이썬 인터프리터가 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문을 실행할 때, 검색 경로를 따라 파이썬 코드와 확장 모듈을 모두 검색합니다. 경로의 기본값은 인터프리터가 빌드될 때 파이썬 바이너리에 구성됩니다. <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 모듈을 임포트 해서 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 값을 인쇄하여 경로를 파악할 수 있습니다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/usr/local/lib/python2.3&#39;, &#39;/usr/local/lib/python2.3/plat-linux2&#39;,
 &#39;/usr/local/lib/python2.3/lib-tk&#39;, &#39;/usr/local/lib/python2.3/lib-dynload&#39;,
 &#39;/usr/local/lib/python2.3/site-packages&#39;]
&gt;&gt;&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sys.path</span></code>의 빈 문자열은 현재 작업 디렉터리를 나타냅니다.</p>
<p>로컬에 설치된 패키지에 대해 기대되는 규칙은 패키지를 <code class="file docutils literal notranslate"><em><span class="pre">...</span></em><span class="pre">/site-packages/</span></code> 디렉터리에 넣는 것이지만, 파이썬 모듈을 임의의 디렉터리에 설치하고 싶을 수 있습니다. 예를 들어, 사이트에 웹 서버와 관련된 모든 소프트웨어를 <code class="file docutils literal notranslate"><span class="pre">/www</span></code>에 유지하는 규칙이 있을 수 있습니다. 그러면 애드온 파이썬 모듈은 <code class="file docutils literal notranslate"><span class="pre">/www/python</span></code>에 속할 수 있으며, 이를 임포트 하려면, 이 디렉터리를 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>에 추가해야 합니다. 디렉터리를 추가하는 방법은 여러 가지가 있습니다.</p>
<p>가장 편리한 방법은 이미 파이썬의 경로에 있는 디렉터리(일반적으로 <code class="file docutils literal notranslate"><span class="pre">.../site-packages/</span></code> 디렉터리)에 경로 구성 파일을 추가하는 것입니다. 경로 구성 파일의 확장자는 <code class="file docutils literal notranslate"><span class="pre">.pth</span></code>이며, 각 줄에는 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>에 추가될 단일 경로가 포함되어야 합니다. (새 경로가 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>에 추가되기 때문에, 추가된 디렉터리의 모듈은 표준 모듈을 재정의하지 않습니다. 이는 표준 모듈의 수정된 버전을 설치하는데 이 메커니즘을 사용할 수 없음을 의미합니다.)</p>
<p>경로는 절대나 상대일 수 있으며, 상대인 경우 <code class="file docutils literal notranslate"><span class="pre">.pth</span></code> 파일을 포함하는 디렉터리에 상대적입니다. 자세한 내용은 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 모듈 설명서를 참조하십시오.</p>
<p>약간 덜 편리한 방법은 파이썬의 표준 라이브러리에 있는 <code class="file docutils literal notranslate"><span class="pre">site.py</span></code> 파일을 편집하고, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>를 수정하는 것입니다. 이 동작을 억제하기 위해 <a class="reference internal" href="../using/cmdline.html#id3"><code class="xref std std-option docutils literal notranslate"><span class="pre">-S</span></code></a> 스위치가 제공되지 않는 한, 파이썬 인터프리터가 실행될 때 <code class="file docutils literal notranslate"><span class="pre">site.py</span></code>를 자동으로 임포트 합니다. 따라서 간단히 <code class="file docutils literal notranslate"><span class="pre">site.py</span></code>를 편집하여 두 줄을 추가할 수 있습니다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/www/python/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>그러나, 같은 주 버전의 파이썬을 다시 설치하면 (아마도 예를 들어 2.2에서 2.2.2로 업그레이드 할 때) <code class="file docutils literal notranslate"><span class="pre">site.py</span></code>가 기본 버전으로 덮어 쓰입니다. 설치하기 전에 수정된 것을 기억하고 사본을 저장해야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">sys.path</span></code>를 수정할 수 있는 두 가지 환경 변수가 있습니다. <span class="target" id="index-22"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a>은 파이썬 설치 접두사에 대한 대안 값을 설정합니다. 예를 들어, <span class="target" id="index-23"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 을 <code class="docutils literal notranslate"><span class="pre">/www/python</span></code>으로 설정하면, 검색 경로가 <code class="docutils literal notranslate"><span class="pre">['',</span> <span class="pre">'/www/python/lib/pythonX.Y/',</span> <span class="pre">'/www/python/lib/pythonX.Y/plat-linux2',</span> <span class="pre">...]</span></code>로 설정됩니다.</p>
<p><span class="target" id="index-24"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 변수는 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>의 시작 부분에 추가될 경로 목록으로 설정할 수 있습니다. 예를 들어, <span class="target" id="index-25"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">/www/python:/opt/py</span></code>로 설정되면, 검색 경로는 <code class="docutils literal notranslate"><span class="pre">['/www/python',</span> <span class="pre">'/opt/py']</span></code>로 시작합니다. (<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>에 추가되려면 디렉터리가 존재해야 함에 유의하십시오; <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 모듈은 존재하지 않는 경로를 제거합니다.)</p>
<p>마지막으로, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>는 일반적인 파이썬 리스트이므로, 모든 파이썬 응용 프로그램은 항목을 추가하거나 제거하여 수정할 수 있습니다.</p>
</div>
</div>
<div class="section" id="distutils-configuration-files">
<span id="inst-config-files"></span><h2>Distutils 구성 파일<a class="headerlink" href="#distutils-configuration-files" title="제목 주소">¶</a></h2>
<p>위에서 언급했듯이, Distutils 구성 파일을 사용하여 모든 Distutils 옵션에 대한 개인이나 사이트 기본 설정을 기록할 수 있습니다. 즉, 모든 명령에 대한 모든 옵션이 2개나 3개의 (플랫폼에 따라 다릅니다) 구성 파일 중 하나에 저장될 수 있으며, 명령 줄이 구문 분석되기 전에 참조됩니다. 이는 구성 파일이 기본값을 재정의하고, 명령 줄이 그 후에 구성 파일을 재정의함을 의미합니다. 또한, 여러 구성 파일이 적용되는 경우, &quot;이전&quot; 파일의 값이 &quot;나중&quot; 파일에 의해 재정의됩니다.</p>
<div class="section" id="location-and-names-of-config-files">
<span id="inst-config-filenames"></span><h3>구성 파일의 위치와 이름<a class="headerlink" href="#location-and-names-of-config-files" title="제목 주소">¶</a></h3>
<p>구성 파일의 이름과 위치는 플랫폼에 따라 약간씩 다릅니다. 유닉스와 Mac OS X에서, 세 가지 구성 파일(처리되는 순서에 따라)은 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 73%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>위치와 파일명</p></th>
<th class="head"><p>노트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>시스템</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">ver</span></em><span class="pre">/distutils/distutils.cfg</span></code></p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p>개인</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">$HOME/.pydistutils.cfg</span></code></p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p>로컬</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">setup.cfg</span></code></p></td>
<td><p>(3)</p></td>
</tr>
</tbody>
</table>
<p>그리고 윈도우에서, 구성 파일은 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 70%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파일 유형</p></th>
<th class="head"><p>위치와 파일명</p></th>
<th class="head"><p>노트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>시스템</p></td>
<td><p><code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">\Lib\distutils\distutils.cfg</span></code></p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p>개인</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">%HOME%\pydistutils.cfg</span></code></p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-even"><td><p>로컬</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">setup.cfg</span></code></p></td>
<td><p>(3)</p></td>
</tr>
</tbody>
</table>
<p>모든 플랫폼에서, &quot;개인&quot; 파일은 <cite>--no-user-cfg</cite> 옵션을 전달하여 일시적으로 비활성화 할 수 있습니다.</p>
<p>노트:</p>
<ol class="arabic simple">
<li><p>엄밀히 말하면, 시스템 전체 구성 파일은 Distutils가 설치된 디렉터리에 있습니다; 유닉스의 파이썬 1.6 이상에서는, 표시된 것과 같습니다. 파이썬 1.5.2의 경우, Distutils는 일반적으로 <code class="file docutils literal notranslate"><em><span class="pre">prefix</span></em><span class="pre">/lib/python1.5/site-packages/distutils</span></code>에 설치되므로, 시스템 구성 파일은 파이썬 1.5.2 에서는 그곳에 넣어야 합니다.</p></li>
<li><p>유닉스에서, <span class="target" id="index-26"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code> 환경 변수가 정의되지 않으면, 사용자의 홈 디렉터리는 표준 <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pwd</span></code></a> 모듈의 <code class="xref py py-func docutils literal notranslate"><span class="pre">getpwuid()</span></code> 함수로 결정됩니다. 이것은 Distutils에서 사용하는 <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.expanduser()</span></code></a> 함수에 의해 수행됩니다.</p></li>
<li><p>즉, 현재 디렉터리에 (일반적으로 설정 스크립트의 위치).</p></li>
<li><p>(노트 (1)도 참조하십시오.) 파이썬 1.6 이상에서, 파이썬의 기본 &quot;설치 접두사&quot;는 <code class="file docutils literal notranslate"><span class="pre">C:\Python</span></code>이므로, 시스템 구성 파일은 일반적으로 <code class="file docutils literal notranslate"><span class="pre">C:\Python\Lib\distutils\distutils.cfg</span></code>입니다. 파이썬 1.5.2에서, 기본 접두사는 <code class="file docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></code>였고, Distutils는 표준 라이브러리의 일부가 아니었습니다---따라서 시스템 구성 파일은 윈도우의 표준 파이썬 1.5.2 설치에서 <code class="file docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Python\distutils\distutils.cfg</span></code>입니다.</p></li>
<li><p>윈도우에서, <span class="target" id="index-27"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code> 환경 변수가 정의되지 않으면, <span class="target" id="index-28"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">USERPROFILE</span></code> 다음에 <span class="target" id="index-29"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOMEDRIVE</span></code>와 <span class="target" id="index-30"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOMEPATH</span></code>가 시도됩니다. 이것은 Distutils에서 사용하는 <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.expanduser()</span></code></a> 함수에 의해 수행됩니다.</p></li>
</ol>
</div>
<div class="section" id="syntax-of-config-files">
<span id="inst-config-syntax"></span><h3>구성 파일 문법<a class="headerlink" href="#syntax-of-config-files" title="제목 주소">¶</a></h3>
<p>Distutils 구성 파일은 모두 같은 문법을 갖습니다. 구성 파일은 섹션으로 그룹화됩니다. Distutils 명령마다 하나의 섹션이 있고, 여기에 더해 모든 명령에 영향을 미치는 전역 옵션에 대한 <code class="docutils literal notranslate"><span class="pre">global</span></code> 섹션이 있습니다. 각 섹션은 <code class="docutils literal notranslate"><span class="pre">option=value</span></code>로 지정되는 줄당 하나의 옵션으로 구성됩니다.</p>
<p>예를 들어, 다음은 모든 명령이 기본적으로 조용히 실행되도록 하는 완전한 구성 파일입니다:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[global]</span>
<span class="na">verbose</span><span class="o">=</span><span class="s">0</span>
</pre></div>
</div>
<p>이것이 시스템 구성 파일로 설치되면, 현재 시스템의 모든 사용자에 의한 모든 파이썬 모듈 배포 처리에 영향을 줍니다. 개인 구성 파일로 설치되면 (지원하는 시스템에서), 사용자가 처리하는 모듈 배포에만 영향을 줍니다. 그리고 특정 모듈 배포에 대한 <code class="file docutils literal notranslate"><span class="pre">setup.cfg</span></code>로 사용되면, 해당 배포에만 영향을 줍니다.</p>
<p>다음을 사용하여 기본 &quot;빌드 기본(build base)&quot; 디렉터리를 재정의하고 <strong class="command">build*</strong> 명령이 항상 모든 파일을 강제로 다시 빌드하도록 할 수 있습니다:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[build]</span>
<span class="na">build-base</span><span class="o">=</span><span class="s">blib</span>
<span class="na">force</span><span class="o">=</span><span class="s">1</span>
</pre></div>
</div>
<p>이는 다음과 같은 명령 줄 인자에 해당합니다</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build --build-base=blib --force
</pre></div>
</div>
<p>명령 줄에 <strong class="command">build</strong> 명령을 포함하는 것은 명령이 실행된다는 것을 의미한다는 점만 다릅니다. 구성 파일에 특정 명령을 포함하는 것은 그러한 의미가 없습니다; 명령이 실행된다면, 구성 파일의 옵션이 적용된다는 의미일 뿐입니다. (또는 그것에서 값을 파생하는 다른 명령이 실행되면, 그들은 구성 파일의 값을 사용합니다.)</p>
<p><code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code> 옵션을 사용해서 모든 명령에 대한 전체 옵션 목록을 찾을 수 있습니다. 예를 들어:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build --help
</pre></div>
</div>
<p>그리고 명령 없이 <code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code>를 사용하여 전역 옵션의 전체 목록을 찾을 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py --help
</pre></div>
</div>
<p>&quot;파이썬 모듈 배포&quot; 매뉴얼의 &quot;레퍼런스&quot; 섹션도 참조하십시오.</p>
</div>
</div>
<div class="section" id="building-extensions-tips-and-tricks">
<span id="inst-building-ext"></span><h2>확장 빌드하기: 팁과 요령<a class="headerlink" href="#building-extensions-tips-and-tricks" title="제목 주소">¶</a></h2>
<p>가능하면, Distutils는 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 스크립트를 실행하는 데 사용되는 파이썬 인터프리터에서 제공하는 구성 정보를 사용하려고 합니다. 예를 들어, 파이썬을 컴파일하는 데 사용된 같은 컴파일러와 링커 플래그가 확장 컴파일에도 사용됩니다. 일반적으로 이것은 잘 작동하지만, 복잡한 상황에서는 부적절 할 수 있습니다. 이 섹션에서는 일반적인 Distutils 동작을 재정의하는 방법에 관해 설명합니다.</p>
<div class="section" id="tweaking-compiler-linker-flags">
<span id="inst-tweak-flags"></span><h3>컴파일러/링커 플래그 조정하기<a class="headerlink" href="#tweaking-compiler-linker-flags" title="제목 주소">¶</a></h3>
<p>C나 C++로 작성된 파이썬 확장을 컴파일하려면 특정 라이브러리를 사용하거나 특별한 종류의 오브젝트 코드를 생성하기 위해 컴파일러와 링커에 대해 사용자 지정 플래그를 지정해야 하는 경우가 있습니다. 확장이 플랫폼에서 테스트 되지 않았거나, 파이썬을 크로스 컴파일하려는 경우 특히 그렇습니다.</p>
<p>가장 일반적일 때, 확장 저자는 확장을 컴파일하는 것이 복잡할 것이라고 예상하고, 편집할 <code class="file docutils literal notranslate"><span class="pre">Setup</span></code> 파일을 제공했을 수 있습니다. 이는 모듈 배포에 많은 개별 확장 모듈이 포함되어 있거나, 이들이 작동하기 위해 종종 정교한 컴파일러 플래그 집합이 필요한 경우에만 수행됩니다.</p>
<p>존재한다면, <code class="file docutils literal notranslate"><span class="pre">Setup</span></code> 파일은 빌드할 확장 목록을 얻기 위해 구문 분석됩니다. <code class="file docutils literal notranslate"><span class="pre">Setup</span></code>의 각 줄은 단일 모듈을 설명합니다. 줄의 구조는 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module ... [sourcefile ...] [cpparg ...] [library ...]
</pre></div>
</div>
<p>각 필드를 차례로 살펴보겠습니다.</p>
<ul class="simple">
<li><p><em>module</em>은 빌드할 확장 모듈의 이름이며, 유효한 파이썬 식별자여야 합니다. 모듈의 이름을 변경하기 위해 단순히 이것을 변경할 수는 없습니다 (소스 코드에 대한 편집도 필요합니다), 따라서 이것은 그대로 두어야 합니다.</p></li>
<li><p><em>sourcefile</em>은 최소한 파일 이름으로 판단할 때 소스 코드 파일일 가능성이 있는 모든 것입니다. <code class="file docutils literal notranslate"><span class="pre">.c</span></code>로 끝나는 파일명은 C로, <code class="file docutils literal notranslate"><span class="pre">.C</span></code>, <code class="file docutils literal notranslate"><span class="pre">.cc</span></code> 및 <code class="file docutils literal notranslate"><span class="pre">.c++</span></code>로 끝나는 파일명은 C++로, <code class="file docutils literal notranslate"><span class="pre">.m</span></code>이나 <code class="file docutils literal notranslate"><span class="pre">.mm</span></code>으로 끝나는 파일명은 Objective C로 작성되었다고 간주합니다.</p></li>
<li><p><em>cpparg</em>는 C 전처리기에 대한 인자이며, <code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code>, <code class="xref std std-option docutils literal notranslate"><span class="pre">-D</span></code>, <code class="xref std std-option docutils literal notranslate"><span class="pre">-U</span></code> 또는 <code class="xref std std-option docutils literal notranslate"><span class="pre">-C</span></code>로 시작하는 모든 것입니다.</p></li>
<li><p><em>library</em>는 <code class="file docutils literal notranslate"><span class="pre">.a</span></code>로 끝나거나 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>이나 <code class="xref std std-option docutils literal notranslate"><span class="pre">-L</span></code>로 시작하는 모든 것입니다.</p></li>
</ul>
<p>특정 플랫폼에 플랫폼의 특수 라이브러리가 필요하면, <code class="file docutils literal notranslate"><span class="pre">Setup</span></code> 파일을 편집하고 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">build</span></code>를 실행하여 추가 할 수 있습니다. 예를 들어, 다음 줄로 정의된 모듈이</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo foomodule.c
</pre></div>
</div>
<p>플랫폼의 수학 라이브러리 <code class="file docutils literal notranslate"><span class="pre">libm.a</span></code>와 연결되어야 하면, 간단히 <code class="xref std std-option docutils literal notranslate"><span class="pre">-lm</span></code>을 줄에 추가하면 됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo foomodule.c -lm
</pre></div>
</div>
<p>컴파일러나 링커 용인 임의의 스위치는 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Xcompiler</span></code> <em>arg</em>와 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Xlinker</span></code> <em>arg</em> 옵션으로 제공될 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm
</pre></div>
</div>
<p><code class="xref std std-option docutils literal notranslate"><span class="pre">-Xcompiler</span></code>과 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Xlinker</span></code> 다음 옵션은 적절한 명령 줄에 추가되므로, 위의 예에서 컴파일러로는 <code class="xref std std-option docutils literal notranslate"><span class="pre">-o32</span></code> 옵션을 전달하고, 링커로는 <code class="xref std std-option docutils literal notranslate"><span class="pre">-shared</span></code>를 전달합니다. 컴파일러 옵션에 인자가 필요하면, 여러 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Xcompiler</span></code> 옵션을 제공해야 합니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">c++</span></code>를 전달하려면 <code class="file docutils literal notranslate"><span class="pre">Setup</span></code> 파일에 <code class="docutils literal notranslate"><span class="pre">-Xcompiler</span> <span class="pre">-x</span> <span class="pre">-Xcompiler</span> <span class="pre">c++</span></code>가 포함되어야 합니다.</p>
<p><span class="target" id="index-31"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CFLAGS</span></code> 환경 변수 설정을 통해 컴파일러 플래그를 제공할 수도 있습니다. 설정되면, <span class="target" id="index-32"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CFLAGS</span></code>의 내용이 <code class="file docutils literal notranslate"><span class="pre">Setup</span></code> 파일에 지정된 컴파일러 플래그에 추가됩니다.</p>
</div>
<div class="section" id="using-non-microsoft-compilers-on-windows">
<span id="inst-non-ms-compilers"></span><h3>윈도우에서 비 Microsoft 컴파일러 사용하기<a class="headerlink" href="#using-non-microsoft-compilers-on-windows" title="제목 주소">¶</a></h3>
<div class="section" id="borland-codegear-c">
<h4>Borland/CodeGear C++<a class="headerlink" href="#borland-codegear-c" title="제목 주소">¶</a></h4>
<p>이 서브 섹션에서는 Borland C++ 컴파일러 버전 5.5로 Distutils를 사용하는 데 필요한 단계를 설명합니다. 먼저 Borland의 오브젝트 파일 형식(OMF)이 파이썬이나 ActiveState 웹 사이트에서 다운로드할 수 있는 파이썬 버전에서 사용하는 형식과 다르다는 것을 알아야 합니다. (파이썬은 오브젝트 파일 형식으로 COFF를 사용하는 Microsoft Visual C++로 빌드되었습니다.) 이러한 이유로 파이썬의 라이브러리 <code class="file docutils literal notranslate"><span class="pre">python25.lib</span></code>를 Borland 형식으로 변환해야 합니다. 다음과 같이 할 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>coff2omf python25.lib python25_bcpp.lib
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">coff2omf</span></code> 프로그램은 Borland 컴파일러와 함께 제공됩니다. <code class="file docutils literal notranslate"><span class="pre">python25.lib</span></code> 파일은 파이썬 설치의 <code class="file docutils literal notranslate"><span class="pre">Libs</span></code> 디렉터리에 있습니다. 확장이 다른 라이브러리(zlib, ...)를 사용하면, 그것들도 변환해야 합니다.</p>
<p>변환된 파일은 일반 라이브러리와 같은 디렉터리에 있어야 합니다.</p>
<p>Distutils는 변경된 이름으로 이러한 라이브러리를 어떻게 사용할까요? 확장에 라이브러리(예를 들어 <code class="file docutils literal notranslate"><span class="pre">foo</span></code>)가 필요하면 Distutils는 접미사가 <code class="file docutils literal notranslate"><span class="pre">_bcpp</span></code>(예를 들어 <code class="file docutils literal notranslate"><span class="pre">foo_bcpp.lib</span></code>)인 라이브러리를 먼저 찾아서 이 라이브러리를 사용합니다. 이러한 특수 라이브러리를 찾지 못하면 기본 이름(<code class="file docutils literal notranslate"><span class="pre">foo.lib</span></code>)을 사용합니다. <a class="footnote-reference brackets" href="#id4" id="id1">1</a></p>
<p>Distutils가 Borland C++로 확장을 컴파일하도록 하려면 다음을 입력해야 합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build --compiler=bcpp
</pre></div>
</div>
<p>Borland C++ 컴파일러를 기본값으로 사용하려면, Distutils에 대한 개인이나 시스템 전체 구성 파일에 이를 지정할 수 있습니다 (섹션 <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 구성 파일</span></a>을 참조하십시오).</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference external" href="https://www.embarcadero.com/products">C++Builder Compiler</a></dt><dd><p>Borland의 무료 C++ 컴파일러에 대한 정보, 다운로드 페이지에 대한 링크를 포함합니다.</p>
</dd>
<dt><a class="reference external" href="http://www.cyberus.ca/~g_will/pyExtenDL.shtml">Creating Python Extensions Using Borland's Free Compiler</a></dt><dd><p>Borland의 무료 명령 줄 C++ 컴파일러를 사용하여 파이썬을 빌드하는 방법을 설명하는 문서.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="gnu-c-cygwin-mingw">
<h4>GNU C / Cygwin / MinGW<a class="headerlink" href="#gnu-c-cygwin-mingw" title="제목 주소">¶</a></h4>
<p>이 섹션에서는 Cygwin과 MinGW 배포판에 있는 GNU C/C++ 컴파일러로 Distutils를 사용하는 데 필요한 단계를 설명합니다. <a class="footnote-reference brackets" href="#id5" id="id2">2</a> Cygwin으로 빌드된 파이썬 인터프리터의 경우, 다음 단계 없이 모든 것이 작동해야 합니다.</p>
<p>모든 확장이 MinGW나 Cygwin으로 빌드될 수 있는 것은 아니지만, 많은 것들이 가능합니다. 작동하지 않을 가능성이 가장 높은 확장은 C++를 사용하거나 Microsoft Visual C 확장에 의존하는 확장입니다.</p>
<p>Distutils가 Cygwin으로 확장을 컴파일하도록 하려면 다음을 입력해야 합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build --compiler=cygwin
</pre></div>
</div>
<p>그리고 no-cygwin 모드의 Cygwin <a class="footnote-reference brackets" href="#id6" id="id3">3</a> 또는 MinGW의 경우 다음을 입력합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python setup.py build --compiler=mingw32
</pre></div>
</div>
<p>이러한 옵션/컴파일러를 기본값으로 사용하려면, Distutils에 대한 개인이나 시스템 전체 구성 파일에 작성하는 것을 고려해야 합니다 (섹션 <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 구성 파일</span></a>을 참조하십시오).</p>
<div class="section" id="older-versions-of-python-and-mingw">
<h5>이전 버전의 파이썬과 MinGW<a class="headerlink" href="#older-versions-of-python-and-mingw" title="제목 주소">¶</a></h5>
<p>다음 지침은 3.0.0(binutils-2.13.90-20030111-1 사용)보다 낮은 MinGW와 함께 2.4.1보다 낮은 파이썬 버전을 사용하는 경우에만 적용됩니다.</p>
<p>이러한 컴파일러에는 몇 가지 특수 라이브러리가 필요합니다. 라이브러리를 변환할 프로그램이 없기 때문에, 이 작업은 Borland의 C++보다 더 복잡합니다. 먼저 파이썬 DLL이 내보내는 심볼 목록을 만들어야 합니다. (<a class="reference external" href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/">https://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/</a> 에서 이 작업에 적합한 프로그램을 찾을 수 있습니다.)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pexports python25.dll &gt;python25.def
</pre></div>
</div>
<p>설치된 <code class="file docutils literal notranslate"><span class="pre">python25.dll</span></code>의 위치는 설치 옵션과 윈도우 버전 및 언어에 따라 다릅니다. &quot;나만을 위한&quot; 설치에서는, 설치 디렉터리의 루트에 나타납니다. 공유 설치에서는, 시스템 디렉터리에 있습니다.</p>
<p>그런 다음 이러한 정보로 gcc 용 임포트 라이브러리를 만들 수 있습니다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/cygwin/bin/dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a
</pre></div>
</div>
<p>결과 라이브러리는 <code class="file docutils literal notranslate"><span class="pre">python25.lib</span></code>와 같은 디렉터리에 있어야 합니다. (파이썬 설치 디렉터리 아래의 <code class="file docutils literal notranslate"><span class="pre">libs</span></code> 디렉터리여야 합니다.)</p>
<p>확장이 다른 라이브러리(zlib, ...)를 사용하면, 그것들도 변환해야 할 수 있습니다. 변환된 파일은 일반 라이브러리와 같은 디렉터리에 있어야 합니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference external" href="http://old.zope.org/Members/als/tips/win32_mingw_modules">Building Python modules on MS Windows platform with MinGW</a></dt><dd><p>MinGW 환경에서 필요한 라이브러리를 빌드하는 방법에 대한 정보.</p>
</dd>
</dl>
</div>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>이는 또한 기존의 모든 COFF 라이브러리를 같은 이름의 OMF 라이브러리로 바꿀 수 있음을 의미합니다.</p>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>자세한 내용은 <a class="reference external" href="https://www.sourceware.org/cygwin/">https://www.sourceware.org/cygwin/</a> 및 <a class="reference external" href="http://www.mingw.org/">http://www.mingw.org/</a> 를 확인하십시오.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>그러면 POSIX 에뮬레이션을 사용할 수 없지만, <code class="file docutils literal notranslate"><span class="pre">cygwin1.dll</span></code>도 필요하지 않습니다.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">파이썬 모듈 설치 (레거시 버전)</a><ul>
<li><a class="reference internal" href="#introduction">소개</a><ul>
<li><a class="reference internal" href="#distutils-based-source-distributions">Distutils 기반 소스 배포</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-build-and-install">표준 빌드와 설치</a><ul>
<li><a class="reference internal" href="#platform-variations">플랫폼 변형</a></li>
<li><a class="reference internal" href="#splitting-the-job-up">작업 분할하기</a></li>
<li><a class="reference internal" href="#how-building-works">빌드 작동 원리</a></li>
<li><a class="reference internal" href="#how-installation-works">설치 작동 원리</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-installation">대안 설치</a><ul>
<li><a class="reference internal" href="#alternate-installation-the-user-scheme">대안 설치: 사용자 체계</a></li>
<li><a class="reference internal" href="#alternate-installation-the-home-scheme">대안 설치: 홈 체계</a></li>
<li><a class="reference internal" href="#alternate-installation-unix-the-prefix-scheme">대안 설치: 유닉스 (접두사 체계)</a></li>
<li><a class="reference internal" href="#alternate-installation-windows-the-prefix-scheme">대안 설치: 윈도우 (접두사 체계)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-installation">사용자 정의 설치</a><ul>
<li><a class="reference internal" href="#modifying-python-s-search-path">파이썬의 검색 경로 수정하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#distutils-configuration-files">Distutils 구성 파일</a><ul>
<li><a class="reference internal" href="#location-and-names-of-config-files">구성 파일의 위치와 이름</a></li>
<li><a class="reference internal" href="#syntax-of-config-files">구성 파일 문법</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-extensions-tips-and-tricks">확장 빌드하기: 팁과 요령</a><ul>
<li><a class="reference internal" href="#tweaking-compiler-linker-flags">컴파일러/링커 플래그 조정하기</a></li>
<li><a class="reference internal" href="#using-non-microsoft-compilers-on-windows">윈도우에서 비 Microsoft 컴파일러 사용하기</a><ul>
<li><a class="reference internal" href="#borland-codegear-c">Borland/CodeGear C++</a></li>
<li><a class="reference internal" href="#gnu-c-cygwin-mingw">GNU C / Cygwin / MinGW</a><ul>
<li><a class="reference internal" href="#older-versions-of-python-and-mingw">이전 버전의 파이썬과 MinGW</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="../distutils/apiref.html"
                        title="이전 장"><span class="section-number">9. </span>API 레퍼런스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="../distutils/apiref.html" title="9. API 레퍼런스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>