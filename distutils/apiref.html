
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>9. API 레퍼런스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파이썬 모듈 설치 (레거시 버전)" href="../install/index.html" />
    <link rel="prev" title="8. 명령 레퍼런스" href="commandref.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/distutils/apiref.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="../install/index.html" title="파이썬 모듈 설치 (레거시 버전)"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="commandref.html" title="8. 명령 레퍼런스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 모듈 배포 (레거시 버전)</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="api-reference">
<span id="id1"></span><h1><span class="section-number">9. </span>API 레퍼런스<a class="headerlink" href="#api-reference" title="제목 주소">¶</a></h1>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#new-and-changed-setup-keywords">setuptools의 신규 및 변경된 setup.py 인자</a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 프로젝트는 <code class="docutils literal notranslate"><span class="pre">setup</span></code> 함수와 기타 API에 새로운 기능을 추가하고, API를 여러 파이썬 버전에서 일관되게 만들어서, <code class="docutils literal notranslate"><span class="pre">distutils</span></code>를 직접 사용하는 것보다 권장됩니다.</p>
</dd>
</dl>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 문서는 <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html">https://setuptools.readthedocs.io/en/latest/setuptools.html</a> 의 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 설명서가 현재 여기에 포함된 모든 관련 정보를 독립적으로 다루기 전까지만 보존됩니다.</p>
</div>
<div class="section" id="module-distutils.core">
<span id="distutils-core-core-distutils-functionality"></span><h2><span class="section-number">9.1. </span><a class="reference internal" href="#module-distutils.core" title="distutils.core: The core Distutils functionality"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.core</span></code></a> --- 핵심 Distutils 기능<a class="headerlink" href="#module-distutils.core" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-distutils.core" title="distutils.core: The core Distutils functionality"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.core</span></code></a> 모듈은 Distutils를 사용하기 위해 설치해야 하는 유일한 모듈입니다. <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>(설치 스크립트에서 호출됩니다)을 제공합니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.dist.Distribution</span></code>과 <a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.cmd.Command</span></code></a> 클래스를 간접적으로 제공합니다.</p>
<dl class="function">
<dt id="distutils.core.setup">
<code class="sig-prename descclassname">distutils.core.</code><code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.core.setup" title="정의 주소">¶</a></dt>
<dd><p>Distutils 메서드에서 요청할 수 있는 대부분의 작업을 수행하는 기본 만능 함수.</p>
<p>setup 함수는 많은 수의 인자를 취합니다. 이는 다음 표에 나와 있습니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 28%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>인자 이름</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>형</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>name</em></p></td>
<td><p>패키지 이름</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>version</em></p></td>
<td><p>패키지의 버전 번호; <a class="reference internal" href="#module-distutils.version" title="distutils.version: Implements classes that represent module version numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.version</span></code></a>을 참조하십시오</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>description</em></p></td>
<td><p>패키지를 설명하는 한 줄</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>long_description</em></p></td>
<td><p>패키지에 대한 자세한 설명</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>author</em></p></td>
<td><p>패키지 저자의 이름</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>author_email</em></p></td>
<td><p>패키지 저자의 이메일 주소</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>maintainer</em></p></td>
<td><p>저자와 다르다면, 현재 관리자의 이름. 관리자가 제공되면 distutils는, 이것을 <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code>에서 저자로 사용함에 유의하십시오.</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>maintainer_email</em></p></td>
<td><p>작성자와 다르다면, 현재 관리자의 이메일 주소</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>url</em></p></td>
<td><p>패키지의 URL (홈페이지)</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>download_url</em></p></td>
<td><p>패키지를 다운로드하기 위한 URL</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>packages</em></p></td>
<td><p>distutils가 다룰 파이썬 패키지 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>py_modules</em></p></td>
<td><p>distutils가 다룰 파이썬 모듈 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>scripts</em></p></td>
<td><p>빌드하고 설치할 독립 실행형 스크립트 파일 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>ext_modules</em></p></td>
<td><p>빌드할 파이썬 확장 리스트</p></td>
<td><p><a class="reference internal" href="#distutils.core.Extension" title="distutils.core.Extension"><code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.core.Extension</span></code></a>의 인스턴스 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>classifiers</em></p></td>
<td><p>패키지 범주 리스트</p></td>
<td><p>문자열 리스트; 유효한 분류자는 <a class="reference external" href="https://pypi.org/classifiers">PyPI</a>에 나열됩니다.</p></td>
</tr>
<tr class="row-odd"><td><p><em>distclass</em></p></td>
<td><p>사용할 <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a> 클래스</p></td>
<td><p><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.core.Distribution</span></code></a>의 서브 클래스</p></td>
</tr>
<tr class="row-even"><td><p><em>script_name</em></p></td>
<td><p>setup.py 스크립트의 이름 - 기본값은 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code></p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>script_args</em></p></td>
<td><p>설정 스크립트에 제공할 인자</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>options</em></p></td>
<td><p>설정 스크립트의 기본 옵션</p></td>
<td><p>딕셔너리</p></td>
</tr>
<tr class="row-odd"><td><p><em>license</em></p></td>
<td><p>패키지 라이선스</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>keywords</em></p></td>
<td><p>설명 메타 데이터, <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0314"><strong>PEP 314</strong></a>를 참조하십시오</p></td>
<td><p>문자열 리스트나 쉼표로 구분된 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>platforms</em></p></td>
<td></td>
<td><p>문자열 리스트나 쉼표로 구분된 문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>cmdclass</em></p></td>
<td><p>명령 이름에서 <a class="reference internal" href="#distutils.core.Command" title="distutils.core.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code></a> 서브 클래스로의 매핑</p></td>
<td><p>딕셔너리</p></td>
</tr>
<tr class="row-odd"><td><p><em>data_files</em></p></td>
<td><p>설치할 데이터 파일 리스트</p></td>
<td><p>리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>package_dir</em></p></td>
<td><p>패키지에서 디렉터리 이름으로의 매핑</p></td>
<td><p>딕셔너리</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="distutils.core.run_setup">
<code class="sig-prename descclassname">distutils.core.</code><code class="sig-name descname">run_setup</code><span class="sig-paren">(</span><em class="sig-param">script_name</em><span class="optional">[</span>, <em class="sig-param">script_args=None</em>, <em class="sig-param">stop_after='run'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.core.run_setup" title="정의 주소">¶</a></dt>
<dd><p>다소 통제된 환경에서 설정 스크립트를 실행하고, 작업을 구동하는 <code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.dist.Distribution</span></code> 인스턴스를 반환합니다. 이는 (<em>script</em>에서 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>으로 키워드 인자로 전달된) 배포 메타 데이터나, 구성 파일이나 명령 줄의 내용을 찾아야 하는 경우 유용합니다.</p>
<p><em>script_name</em>은 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a>로 읽고 실행할 파일입니다. 호출 기간에 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code>은 <em>script</em>로 대체됩니다. <em>script_args</em>는 문자열 리스트입니다; 제공되면 <code class="docutils literal notranslate"><span class="pre">sys.argv[1:]</span></code>은 호출 기간에 <em>script_args</em>로 대체됩니다.</p>
<p><em>stop_after</em>는 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>에게 처리 중지 시기를 알려줍니다. 가능한 값:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>init</em></p></td>
<td><p><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a> 인스턴스가 생성되고 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>에 대한 키워드 인자로 채워진 후 중지합니다</p></td>
</tr>
<tr class="row-odd"><td><p><em>config</em></p></td>
<td><p>구성 파일이 구문 분석된 (그리고 해당 데이터가 <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a> 인스턴스에 저장된) 후 중지합니다</p></td>
</tr>
<tr class="row-even"><td><p><em>commandline</em></p></td>
<td><p>명령 줄(<code class="docutils literal notranslate"><span class="pre">sys.argv[1:]</span></code>이나 <em>script_args</em>)이 구문 분석된 (그리고 데이터가 <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a> 인스턴스에 저장된) 후 중지합니다</p></td>
</tr>
<tr class="row-odd"><td><p><em>run</em></p></td>
<td><p>모든 명령이 실행된 후 중지합니다 (<a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>이 일반적인 방법으로 호출된 것과 같습니다). 이것이 기본값입니다.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<p>또한, <a class="reference internal" href="#module-distutils.core" title="distutils.core: The core Distutils functionality"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.core</span></code></a> 모듈은 다른 곳에 있는 여러 클래스를 노출합니다.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-distutils.extension" title="distutils.extension: Provides the Extension class, used to describe C/C++ extension modules in setup scripts"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.extension</span></code></a>의 <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code></p></li>
<li><p><a class="reference internal" href="#module-distutils.cmd" title="distutils.cmd: Provides the abstract base class :class:`~distutils.cmd.Command`. This class is subclassed by the modules in the distutils.command subpackage."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.cmd</span></code></a>의 <a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-distutils.dist" title="distutils.dist: Provides the Distribution class, which represents the module distribution being built/installed/distributed"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dist</span></code></a>의 <code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></p></li>
</ul>
<p>이들 각각에 대한 간략한 설명은 다음과 같지만, 전체 레퍼런스는 관련 모듈을 참조하십시오.</p>
<dl class="class">
<dt id="distutils.core.Extension">
<em class="property">class </em><code class="sig-prename descclassname">distutils.core.</code><code class="sig-name descname">Extension</code><a class="headerlink" href="#distutils.core.Extension" title="정의 주소">¶</a></dt>
<dd><p>Extension 클래스는 설정 스크립트의 단일 C나 C++ 확장 모듈을 기술합니다. 생성자에서 다음 키워드 인자를 받아들입니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 39%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>인자 이름</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>형</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>name</em></p></td>
<td><p>모든 패키지를 포함하여, 확장의 전체 이름 --- 즉 파일명이나 경로명이 <em>아니라</em>, 점으로 구분된 파이썬 이름</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-odd"><td><p><em>sources</em></p></td>
<td><p>이식성을 위해 유닉스 형식의 (슬래시로 구분된), 배포 루트(설치 스크립트가 있는 위치)에 상대적인, 소스 파일명 리스트. 소스 파일은 C, C++, SWIG (.i), 플랫폼별 리소스 파일 또는 <strong class="command">build_ext</strong> 명령이 파이썬 확장의 소스로 인식하는 다른 모든 것일 수 있습니다.</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>include_dirs</em></p></td>
<td><p>C/C++ 헤더 파일을 검색할 디렉터리 리스트 (이식성을 위해 유닉스 형식으로)</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>define_macros</em></p></td>
<td><p>정의할 매크로 리스트; 각 매크로는 2-튜플 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code>를 사용하여 정의됩니다, 여기서 <em>value</em>는 정의할 문자열이거나 특정 값없이 정의하는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다 (소스의 <code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">FOO</span></code>나 유닉스 C 컴파일러 명령 줄의 <code class="xref std std-option docutils literal notranslate"><span class="pre">-DFOO</span></code>와 동등합니다).</p></td>
<td><p>튜플 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>undef_macros</em></p></td>
<td><p>명시적으로 정의 해제(undef)할 매크로 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>library_dirs</em></p></td>
<td><p>링크 시점에 C/C++ 라이브러리를 검색할 디렉터리 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>libraries</em></p></td>
<td><p>링크할 라이브러리 이름 (파일명이나 경로가 아닙니다) 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>runtime_library_dirs</em></p></td>
<td><p>실행 시점에 C/C++ 라이브러리를 검색할 디렉터리 리스트 (공유 확장의 경우, 확장이 로드될 때입니다)</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>extra_objects</em></p></td>
<td><p>링크할 추가 파일 리스트 (예를 들어 'sources'가 암시하지 않는 오브젝트 파일, 명시적으로 지정해야 하는 정적 라이브러리, 바이너리 리소스 파일 등)</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>extra_compile_args</em></p></td>
<td><p>'sources'에 있는 소스 파일을 컴파일할 때 사용할 추가 플랫폼과 컴파일러별 정보. 명령 줄이 의미가 있는 플랫폼과 컴파일러의 경우, 일반적으로 명령 줄 인자 리스트이지만, 다른 플랫폼의 경우 어떤 것이 든 될 수 있습니다.</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>extra_link_args</em></p></td>
<td><p>확장을 만들기 위해 (또는 새로운 정적 파이썬 인터프리터를 만들기 위해) 오브젝트 파일을 함께 링크할 때 사용할 추가 플랫폼과 컴파일러별 정보. 'extra_compile_args'와 유사한 해석.</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>export_symbols</em></p></td>
<td><p>공유 확장에서 내보낼 심볼 리스트. 모든 플랫폼에서 사용되지는 않으며, 일반적으로 정확히 하나의 심볼(<code class="docutils literal notranslate"><span class="pre">init</span></code> + 확장 이름)을 내보내는 파이썬 확장에는 필요하지 않습니다.</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-even"><td><p><em>depends</em></p></td>
<td><p>확장이 의존하는 파일 리스트</p></td>
<td><p>문자열 리스트</p></td>
</tr>
<tr class="row-odd"><td><p><em>language</em></p></td>
<td><p>확장 언어(즉 <code class="docutils literal notranslate"><span class="pre">'c'</span></code>, <code class="docutils literal notranslate"><span class="pre">'c++'</span></code>, <code class="docutils literal notranslate"><span class="pre">'objc'</span></code>). 제공되지 않으면 소스 확장자에서 감지됩니다.</p></td>
<td><p>문자열</p></td>
</tr>
<tr class="row-even"><td><p><em>optional</em></p></td>
<td><p>확장의 빌드 실패가 빌드 프로세스를 중단하지 않고, 단순히 확장을 건너뛰도록 지정합니다.</p></td>
<td><p>불리언</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>유닉스에서, 안드로이드와 Cygwin을 제외하고 C 확장은 더는 libpython에 링크되지 않습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="distutils.core.Distribution">
<em class="property">class </em><code class="sig-prename descclassname">distutils.core.</code><code class="sig-name descname">Distribution</code><a class="headerlink" href="#distutils.core.Distribution" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a>은 파이썬 소프트웨어 패키지를 빌드, 설치 및 패키징하는 방법을 기술합니다.</p>
<p>Distribution 생성자에서 허용되는 키워드 인자 리스트는 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a> 함수를 참조하십시오. <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>은 Distribution 인스턴스를 만듭니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">classifiers</span></code>, <code class="docutils literal notranslate"><span class="pre">keywords</span></code> 및 <code class="docutils literal notranslate"><span class="pre">platforms</span></code> 필드가 리스트나 문자열로 지정되지 않으면 경고합니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="distutils.core.Command">
<em class="property">class </em><code class="sig-prename descclassname">distutils.core.</code><code class="sig-name descname">Command</code><a class="headerlink" href="#distutils.core.Command" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.core.Command" title="distutils.core.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code></a> 클래스(또는 서브 클래스 중 하나의 인스턴스)는 단일 distutils 명령을 구현합니다.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.ccompiler">
<span id="distutils-ccompiler-ccompiler-base-class"></span><h2><span class="section-number">9.2. </span><a class="reference internal" href="#module-distutils.ccompiler" title="distutils.ccompiler: Abstract CCompiler class"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.ccompiler</span></code></a> --- CCompiler 베이스 클래스<a class="headerlink" href="#module-distutils.ccompiler" title="제목 주소">¶</a></h2>
<p>이 모듈은 <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code></a> 클래스를 위한 추상 베이스 클래스를 제공합니다. <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code></a> 인스턴스는 단일 프로젝트를 빌드하는 데 필요한 모든 컴파일과 링크 단계에 사용할 수 있습니다. 컴파일러 옵션을 설정하는 메서드가 제공됩니다 --- 매크로 정의, 인클루드 디렉터리, 링크 경로, 라이브러리 등.</p>
<p>이 모듈은 다음과 같은 함수를 제공합니다.</p>
<dl class="function">
<dt id="distutils.ccompiler.gen_lib_options">
<code class="sig-prename descclassname">distutils.ccompiler.</code><code class="sig-name descname">gen_lib_options</code><span class="sig-paren">(</span><em class="sig-param">compiler</em>, <em class="sig-param">library_dirs</em>, <em class="sig-param">runtime_library_dirs</em>, <em class="sig-param">libraries</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.gen_lib_options" title="정의 주소">¶</a></dt>
<dd><p>라이브러리 디렉터리를 검색하고 특정 라이브러리와 링크하기 위한 링커 옵션을 생성합니다. <em>libraries</em>와 <em>library_dirs</em>는 각각 라이브러리 이름(파일명이 아닙니다)과 검색 디렉터리 리스트입니다. 일부 컴파일러에서 사용하기에 적합한 명령 줄 옵션 리스트를 반환합니다 (전달된 두 포맷 문자열에 따라 다릅니다).</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.gen_preprocess_options">
<code class="sig-prename descclassname">distutils.ccompiler.</code><code class="sig-name descname">gen_preprocess_options</code><span class="sig-paren">(</span><em class="sig-param">macros</em>, <em class="sig-param">include_dirs</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.gen_preprocess_options" title="정의 주소">¶</a></dt>
<dd><p>최소 두 가지 유형의 컴파일러에서 사용되는 C 전처리기 옵션(<code class="xref std std-option docutils literal notranslate"><span class="pre">-D</span></code>, <code class="xref std std-option docutils literal notranslate"><span class="pre">-U</span></code>, <code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code>)을 생성합니다: 일반적인 유닉스 컴파일러와 Visual C++. <em>macros</em>는 일반적으로 1-튜플 또는 2-튜플 리스트입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">(name,)</span></code>은 정의 해제 (<code class="xref std std-option docutils literal notranslate"><span class="pre">-U</span></code>) 매크로 <em>name</em>을 의미하고, <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code>는 <em>name</em>을 <em>value</em>로 정의하는 (<code class="xref std std-option docutils literal notranslate"><span class="pre">-D</span></code>) 매크로를 의미합니다. <em>include_dirs</em>는 헤더 파일 검색 경로에 추가할 디렉터리 이름 리스트입니다 (<code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code>). 유닉스 컴파일러나 Visual C++에 적합한 명령 줄 옵션 리스트를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.get_default_compiler">
<code class="sig-prename descclassname">distutils.ccompiler.</code><code class="sig-name descname">get_default_compiler</code><span class="sig-paren">(</span><em class="sig-param">osname</em>, <em class="sig-param">platform</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.get_default_compiler" title="정의 주소">¶</a></dt>
<dd><p>주어진 플랫폼에 사용할 기본 컴파일러를 파악합니다.</p>
<p><em>osname</em>은 표준 파이썬 OS 이름 (즉, <code class="docutils literal notranslate"><span class="pre">os.name</span></code>에서 반환된 이름) 중 하나여야 하며 <em>platform</em>은 해당 플랫폼에서 <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code>이 반환하는 일반 값이어야 합니다.</p>
<p>매개 변수가 제공되지 않으면 기본값은 <code class="docutils literal notranslate"><span class="pre">os.name</span></code>과 <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code>입니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.new_compiler">
<code class="sig-prename descclassname">distutils.ccompiler.</code><code class="sig-name descname">new_compiler</code><span class="sig-paren">(</span><em class="sig-param">plat=None</em>, <em class="sig-param">compiler=None</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em>, <em class="sig-param">force=0</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.new_compiler" title="정의 주소">¶</a></dt>
<dd><p>제공된 플랫폼/컴파일러 조합에 대한 어떤 CCompiler 서브 클래스의 인스턴스를 생성하는 팩토리 함수. <em>plat</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">os.name</span></code>이고 (예를 들어 <code class="docutils literal notranslate"><span class="pre">'posix'</span></code>, <code class="docutils literal notranslate"><span class="pre">'nt'</span></code>), <em>compiler</em>의 기본값은 해당 플랫폼의 기본 컴파일러입니다. 현재 <code class="docutils literal notranslate"><span class="pre">'posix'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'nt'</span></code> 만 지원되며, 기본 컴파일러는 &quot;전통적인 유닉스 인터페이스&quot;(<code class="xref py py-class docutils literal notranslate"><span class="pre">UnixCCompiler</span></code> 클래스)와 Visual C++(<code class="xref py py-class docutils literal notranslate"><span class="pre">MSVCCompiler</span></code> 클래스)입니다. 윈도우에서 유닉스 컴파일러 객체를, 유닉스에서 Microsoft 컴파일러 객체를 요청하는 것도 완벽히 가능함에 유의하십시오 --- <em>compiler</em>에 대한 값을 제공하면, <em>plat</em>은 무시됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.show_compilers">
<code class="sig-prename descclassname">distutils.ccompiler.</code><code class="sig-name descname">show_compilers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.show_compilers" title="정의 주소">¶</a></dt>
<dd><p>사용 가능한 컴파일러 리스트를 인쇄합니다 (<strong class="command">build</strong>, <strong class="command">build_ext</strong>, <strong class="command">build_clib</strong>에 대한 <code class="xref std std-option docutils literal notranslate"><span class="pre">--help-compiler</span></code> 옵션에서 사용됩니다).</p>
</dd></dl>

<dl class="class">
<dt id="distutils.ccompiler.CCompiler">
<em class="property">class </em><code class="sig-prename descclassname">distutils.ccompiler.</code><code class="sig-name descname">CCompiler</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em>, <em class="sig-param">force=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler" title="정의 주소">¶</a></dt>
<dd><p>추상 베이스 클래스 <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code></a>는 실제 컴파일러 클래스에서 구현해야 하는 인터페이스를 정의합니다. 이 클래스에는 여러 컴파일러 클래스에서 사용하는 유틸리티 메서드도 있습니다.</p>
<p>컴파일러 추상화 클래스의 기본 개념은 단일 프로젝트를 빌드하는 모든 컴파일/링크 단계에 각 인스턴스를 사용할 수 있다는 것입니다. 따라서, 모든 컴파일과 링크 단계에 공통적인 어트리뷰트는 컴파일러 인스턴스의 어트리뷰트입니다 --- 인클루드 디렉터리, 정의할 매크로, 링크할 라이브러리 등. 개별 파일이 처리되는 방식의 가변성을 허용하기 위해, 이러한 어트리뷰트의 대부분은 컴파일 별 또는 링크 별로 달라질 수 있습니다.</p>
<p>각 서브 클래스의 생성자는 Compiler 객체의 인스턴스를 만듭니다. 플래그는 <em>verbose</em> (상세한 출력을 표시합니다), <em>dry_run</em> (실제로 단계를 실행하지 않습니다) 및 <em>force</em>(종속성과 관계없이, 모든 것을 다시 빌드합니다)입니다. 이러한 모든 플래그의 기본값은 <code class="docutils literal notranslate"><span class="pre">0</span></code>(꺼짐)입니다. <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code></a>나 서브 클래스 중 하나를 직접 인스턴스 화하고 싶지는 않을 것임에 유의하십시오 - 대신 <code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.CCompiler.new_compiler()</span></code> 팩토리 함수를 사용하십시오.</p>
<p>다음 메서드를 사용하면 Compiler 클래스의 인스턴스에 대한 컴파일러 옵션을 수동으로 변경할 수 있습니다.</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_include_dir">
<code class="sig-name descname">add_include_dir</code><span class="sig-paren">(</span><em class="sig-param">dir</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_include_dir" title="정의 주소">¶</a></dt>
<dd><p>헤더 파일을 검색할 디렉터리 리스트에 <em>dir</em>을 추가합니다. 컴파일러는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_include_dir()</span></code></a>에 대한 연속적인 호출에 의해 제공되는 순서대로 디렉터리를 검색하도록 지시받습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_include_dirs">
<code class="sig-name descname">set_include_dirs</code><span class="sig-paren">(</span><em class="sig-param">dirs</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_include_dirs" title="정의 주소">¶</a></dt>
<dd><p>검색할 디렉터리 리스트를 <em>dirs</em>(문자열 리스트)로 설정합니다. <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_include_dir()</span></code></a>에 대한 이전 호출을 무시합니다; <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_include_dir()</span></code></a>에 대한 후속 호출은 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_include_dirs" title="distutils.ccompiler.CCompiler.set_include_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_include_dirs()</span></code></a>에 전달된 리스트에 추가됩니다. 이는 컴파일러가 기본적으로 검색할 수 있는 표준 인클루드 디렉터리 리스트에 영향을 주지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_library">
<code class="sig-name descname">add_library</code><span class="sig-paren">(</span><em class="sig-param">libname</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_library" title="정의 주소">¶</a></dt>
<dd><p>이 컴파일러 객체에 의해 구동되는 모든 링크에 포함될 라이브러리 리스트에 <em>libname</em>을 추가합니다. <em>libname</em>은 라이브러리를 포함하는 파일의 이름이 *아니라*, 라이브러리 자체의 이름이어야 합니다: 실제 파일명은 링커, 컴파일러 또는 컴파일러 클래스(플랫폼에 따라 다릅니다)에 의해 유추됩니다.</p>
<p>링커는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library" title="distutils.ccompiler.CCompiler.add_library"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_library()</span></code></a> 및/또는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_libraries" title="distutils.ccompiler.CCompiler.set_libraries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_libraries()</span></code></a>에 제공된 순서대로 라이브러리에 링크하도록 지시받습니다. 라이브러리 이름을 중복하는 것은 완벽하게 유효합니다; 링커는 언급된 횟수만큼 라이브러리에 링크하도록 지시받습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_libraries">
<code class="sig-name descname">set_libraries</code><span class="sig-paren">(</span><em class="sig-param">libnames</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_libraries" title="정의 주소">¶</a></dt>
<dd><p>이 컴파일러 객체에 의해 구동되는 모든 링크에 포함될 라이브러리 리스트를 <em>libnames</em>(문자열 리스트)로 설정합니다. 이것은 링커가 기본적으로 포함할 수 있는 표준 시스템 라이브러리에 영향을 주지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_library_dir">
<code class="sig-name descname">add_library_dir</code><span class="sig-paren">(</span><em class="sig-param">dir</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_library_dir" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library" title="distutils.ccompiler.CCompiler.add_library"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_library()</span></code></a>와 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_libraries" title="distutils.ccompiler.CCompiler.set_libraries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_libraries()</span></code></a>에 지정된 라이브러리를 검색할 디렉터리 리스트에 <em>dir</em>을 추가합니다. 링커는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library_dir" title="distutils.ccompiler.CCompiler.add_library_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_library_dir()</span></code></a> 및/또는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_library_dirs" title="distutils.ccompiler.CCompiler.set_library_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_library_dirs()</span></code></a>에 제공된 순서대로 라이브러리를 검색하도록 지시받습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_library_dirs">
<code class="sig-name descname">set_library_dirs</code><span class="sig-paren">(</span><em class="sig-param">dirs</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_library_dirs" title="정의 주소">¶</a></dt>
<dd><p>라이브러리 검색 디렉터리 리스트를 <em>dirs</em>(문자열 리스트)로 설정합니다. 이것은 링커가 기본적으로 검색할 수 있는 표준 라이브러리 검색 경로에 영향을 주지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_runtime_library_dir">
<code class="sig-name descname">add_runtime_library_dir</code><span class="sig-paren">(</span><em class="sig-param">dir</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_runtime_library_dir" title="정의 주소">¶</a></dt>
<dd><p>실행 시간에 공유 라이브러리를 검색할 디렉터리 리스트에 <em>dir</em>을 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_runtime_library_dirs">
<code class="sig-name descname">set_runtime_library_dirs</code><span class="sig-paren">(</span><em class="sig-param">dirs</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_runtime_library_dirs" title="정의 주소">¶</a></dt>
<dd><p>실행 시간에 공유 라이브러리를 검색할 디렉터리 리스트를 <em>dirs</em>(문자열 리스트)로 설정합니다. 이는 실행 시간 링커가 기본적으로 검색할 수 있는 표준 검색 경로에 영향을 주지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.define_macro">
<code class="sig-name descname">define_macro</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="optional">[</span>, <em class="sig-param">value=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.define_macro" title="정의 주소">¶</a></dt>
<dd><p>이 컴파일러 객체에 의해 구동되는 모든 컴파일에 대한 전처리기 매크로를 정의합니다. 선택적 매개 변수 <em>value</em>는 문자열이어야 합니다; 제공되지 않으면, 매크로는 명시적 값없이 정의되며 정확한 결과는 사용된 컴파일러에 따라 다릅니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.undefine_macro">
<code class="sig-name descname">undefine_macro</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.undefine_macro" title="정의 주소">¶</a></dt>
<dd><p>이 컴파일러 객체에 의해 구동되는 모든 컴파일에 대한 전처리기 매크로를 정의 해제합니다. 같은 매크로가 <a class="reference internal" href="#distutils.ccompiler.CCompiler.define_macro" title="distutils.ccompiler.CCompiler.define_macro"><code class="xref py py-meth docutils literal notranslate"><span class="pre">define_macro()</span></code></a>에 의해 정의되고 <a class="reference internal" href="#distutils.ccompiler.CCompiler.undefine_macro" title="distutils.ccompiler.CCompiler.undefine_macro"><code class="xref py py-meth docutils literal notranslate"><span class="pre">undefine_macro()</span></code></a>에 의해 정의 해제되면 마지막 호출이 우선합니다 (여러 재정의나 정의 해제를 포함합니다). 매크로가 컴파일 별로 (즉, <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compile()</span></code></a> 호출에서) 재정의/정의 해제되면, 이것이 우선합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_link_object">
<code class="sig-name descname">add_link_object</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_link_object" title="정의 주소">¶</a></dt>
<dd><p>이 컴파일러 객체에 의해 구동되는 모든 링크에 포함될 오브젝트 파일(또는 유사물들, 가령 명시적으로 명명된 라이브러리 파일이나 &quot;리소스 컴파일러&quot;의 출력) 리스트에 <em>object</em>를 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_link_objects">
<code class="sig-name descname">set_link_objects</code><span class="sig-paren">(</span><em class="sig-param">objects</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_link_objects" title="정의 주소">¶</a></dt>
<dd><p><em>objects</em>에 대한 모든 링크에 포함될 오브젝트 파일(또는 유사물들) 리스트를 설정합니다. 이는 링커가 기본적으로 포함할 수 있는 표준 오브젝트 파일에는 영향을 주지 않습니다 (가령 시스템 라이브러리).</p>
</dd></dl>

<p>다음 메서드는 GNU <strong class="program">autoconf</strong>와 유사한 일부 기능을 제공하는 컴파일러 옵션의 자동 감지 방법을 구현합니다.</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.detect_language">
<code class="sig-name descname">detect_language</code><span class="sig-paren">(</span><em class="sig-param">sources</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.detect_language" title="정의 주소">¶</a></dt>
<dd><p>주어진 파일이나 파일 리스트의 언어를 감지합니다. 인스턴스 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">language_map</span></code>(딕셔너리)과 <code class="xref py py-attr docutils literal notranslate"><span class="pre">language_order</span></code>(리스트)를 사용하여 작업을 수행합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.find_library_file">
<code class="sig-name descname">find_library_file</code><span class="sig-paren">(</span><em class="sig-param">dirs</em>, <em class="sig-param">lib</em><span class="optional">[</span>, <em class="sig-param">debug=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.find_library_file" title="정의 주소">¶</a></dt>
<dd><p>지정된 디렉터리 리스트에서 정적 또는 공유 라이브러리 파일 <em>lib</em>를 검색하고 해당 파일의 전체 경로를 반환합니다. <em>debug</em>가 참이면, 디버깅 버전을 찾습니다 (현재 플랫폼에서 의미가 있다면). 지정된 디렉터리 어디에서도 <em>lib</em>를 찾을 수 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.has_function">
<code class="sig-name descname">has_function</code><span class="sig-paren">(</span><em class="sig-param">funcname</em><span class="optional">[</span>, <em class="sig-param">includes=None</em>, <em class="sig-param">include_dirs=None</em>, <em class="sig-param">libraries=None</em>, <em class="sig-param">library_dirs=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.has_function" title="정의 주소">¶</a></dt>
<dd><p>현재 플랫폼에서 <em>funcname</em>이 지원되는지를 나타내는 불리언을 반환합니다. 선택적 인자는 추가 인클루드 파일과 경로 및 라이브러리와 경로를 제공하여 컴파일 환경을 보강하는 데 사용할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.library_dir_option">
<code class="sig-name descname">library_dir_option</code><span class="sig-paren">(</span><em class="sig-param">dir</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.library_dir_option" title="정의 주소">¶</a></dt>
<dd><p>라이브러리 검색 디렉터리 리스트에 <em>dir</em>을 추가하는 컴파일러 옵션을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.library_option">
<code class="sig-name descname">library_option</code><span class="sig-paren">(</span><em class="sig-param">lib</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.library_option" title="정의 주소">¶</a></dt>
<dd><p>공유 라이브러리나 실행 파일에 링크되는 라이브러리 리스트에 <em>lib</em>를 추가하는 컴파일러 옵션을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.runtime_library_dir_option">
<code class="sig-name descname">runtime_library_dir_option</code><span class="sig-paren">(</span><em class="sig-param">dir</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.runtime_library_dir_option" title="정의 주소">¶</a></dt>
<dd><p>실행 시간 라이브러리 검색 디렉터리 리스트에 <em>dir</em>을 추가하는 컴파일러 옵션을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_executables">
<code class="sig-name descname">set_executables</code><span class="sig-paren">(</span><em class="sig-param">**args</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_executables" title="정의 주소">¶</a></dt>
<dd><p>다양한 컴파일 단계를 수행하기 위해 실행할 실행 파일(및 옵션)을 정의합니다. 여기에 지정할 수 있는 정확한 실행 파일 집합은 컴파일러 클래스('executables' 클래스 어트리뷰트를 통해)에 따라 다르지만, 대부분은 다음을 갖습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>compiler</em></p></td>
<td><p>C/C++ 컴파일러</p></td>
</tr>
<tr class="row-odd"><td><p><em>linker_so</em></p></td>
<td><p>공유 오브젝트와 라이브러리를 만드는 데 사용되는 링커</p></td>
</tr>
<tr class="row-even"><td><p><em>linker_exe</em></p></td>
<td><p>바이너리 실행 파일을 만드는 데 사용되는 링커</p></td>
</tr>
<tr class="row-odd"><td><p><em>archiver</em></p></td>
<td><p>정적 라이브러리 생성기</p></td>
</tr>
</tbody>
</table>
<p>명령 줄이 있는 플랫폼(유닉스, DOS/윈도우)에서, 이들 각각은 실행 파일 이름과 (선택적인) 인자 리스트로 분할될 문자열입니다. (문자열 분할은 유닉스 셸이 작동하는 방식과 유사하게 수행됩니다: 단어는 스페이스로 구분되지만, 따옴표와 역 슬래시는 이를 무시할 수 있습니다. <a class="reference internal" href="#distutils.util.split_quoted" title="distutils.util.split_quoted"><code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.util.split_quoted()</span></code></a>를 참조하십시오.)</p>
</dd></dl>

<p>다음 메서드는 빌드 프로세스의 단계를 호출합니다.</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.compile">
<code class="sig-name descname">compile</code><span class="sig-paren">(</span><em class="sig-param">sources</em><span class="optional">[</span>, <em class="sig-param">output_dir=None</em>, <em class="sig-param">macros=None</em>, <em class="sig-param">include_dirs=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">extra_preargs=None</em>, <em class="sig-param">extra_postargs=None</em>, <em class="sig-param">depends=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.compile" title="정의 주소">¶</a></dt>
<dd><p>하나 이상의 소스 파일을 컴파일합니다. 오브젝트 파일을 생성합니다 (예를 들어 <code class="file docutils literal notranslate"><span class="pre">.c</span></code> 파일을 <code class="file docutils literal notranslate"><span class="pre">.o</span></code> 파일로 변환합니다).</p>
<p><em>sources</em>는 C/C++ 파일과 같은 파일명 리스트이어야 하지만, 실제로는 특정 컴파일러와 컴파일러 클래스에서 처리할 수 있는 모든 것입니다 (예를 들어 <code class="xref py py-class docutils literal notranslate"><span class="pre">MSVCCompiler</span></code>는 <em>sources</em>에 있는 리소스 파일을 처리할 수 있습니다). <em>sources</em>의 소스 파일명 당 하나씩 오브젝트 파일명 리스트를 반환합니다. 구현에 따라, 모든 소스 파일이 반드시 컴파일되는 것은 아니지만, 해당하는 모든 오브젝트 파일명이 반환됩니다.</p>
<p><em>output_dir</em>이 제공되면, 원래 경로 구성 요소를 유지하면서 오브젝트 파일이 그 아래에 배치됩니다. 즉, <code class="file docutils literal notranslate"><span class="pre">foo/bar.c</span></code>는 일반적으로 <code class="file docutils literal notranslate"><span class="pre">foo/bar.o</span></code>로 컴파일됩니다 (유닉스 구현의 경우); <em>output_dir</em>이 <em>build</em>이면, <code class="file docutils literal notranslate"><span class="pre">build/foo/bar.o</span></code>로 컴파일됩니다.</p>
<p>주어지면, <em>macros</em>는 매크로 정의 리스트이어야 합니다. 매크로 정의는 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 2-튜플이나 <code class="docutils literal notranslate"><span class="pre">(name,)</span></code> 1-튜플입니다. 전자는 매크로를 정의합니다; 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 매크로는 명시적 값없이 정의됩니다. 1-튜플인 경우는 매크로 정의를 해제합니다. 나중에 오는 정의/재정의/정의 해제가 우선합니다.</p>
<p>주어지면, <em>include_dirs</em>는 문자열 리스트이어야 하며, 이 컴파일에 대해서만 기본 인클루드 파일 검색 경로에 추가할 디렉터리입니다.</p>
<p><em>debug</em>는 불리언입니다; 참이면 컴파일러는 오브젝트 파일 내에 (또는 함께) 디버그 심볼을 출력하도록 지시받습니다.</p>
<p><em>extra_preargs</em>와 <em>extra_postargs</em>는 구현에 따라 다릅니다. 명령 줄 개념이 있는 플랫폼(예를 들어 유닉스, DOS/윈도우)에서는, 대부분 문자열 리스트일 가능성이 높습니다: 컴파일러 명령 줄 앞에 추가하거나 뒤에 붙일 추가 명령 줄 인자. 다른 플랫폼에서는, 구현 클래스 설명서를 참조하십시오. 어쨌든, 그것들은 추상 컴파일러 프레임워크가 바라는 대로 되지 않는 경우를 위한 탈출용 비상구로 의도되었습니다.</p>
<p>주어지면, <em>depends</em>는 모든 대상이 의존하는 파일명 리스트입니다. 소스 파일이 의존하는 파일보다 오래되었으면, 소스 파일이 다시 컴파일됩니다. 이는 종속성 추적을 지원하지만, 대략적인 세분성으로만 가능합니다.</p>
<p>실패 시 <code class="xref py py-exc docutils literal notranslate"><span class="pre">CompileError</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.create_static_lib">
<code class="sig-name descname">create_static_lib</code><span class="sig-paren">(</span><em class="sig-param">objects</em>, <em class="sig-param">output_libname</em><span class="optional">[</span>, <em class="sig-param">output_dir=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">target_lang=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.create_static_lib" title="정의 주소">¶</a></dt>
<dd><p>여러 가지를 함께 링크하여 정적 라이브러리 파일을 만듭니다. &quot;여러 가지&quot;는 <em>objects</em>로 제공되는 오브젝트 파일 리스트, <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_link_object" title="distutils.ccompiler.CCompiler.add_link_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_link_object()</span></code></a> 및/또는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_link_objects" title="distutils.ccompiler.CCompiler.set_link_objects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_link_objects()</span></code></a>에 제공되는 추가 오브젝트 파일, <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library" title="distutils.ccompiler.CCompiler.add_library"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_library()</span></code></a> 및/또는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_libraries" title="distutils.ccompiler.CCompiler.set_libraries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_libraries()</span></code></a>에 제공되는 라이브러리, <em>libraries</em>(있다면)로 제공되는 라이브러리로 구성됩니다.</p>
<p><em>output_libname</em>은 파일명이 아닌 라이브러리 이름이어야 합니다; 파일명은 라이브러리 이름에서 유추됩니다. <em>output_dir</em>은 라이브러리 파일이 저장될 디렉터리입니다.</p>
<p><em>debug</em>는 불리언입니다; 참이면, 디버깅 정보가 라이브러리에 포함됩니다 (대부분의 플랫폼에서, 이것이 중요한 곳은 컴파일 단계임에 유의하십시오: 단지 일관성을 위해 <em>debug</em> 플래그가 여기에 포함됩니다).</p>
<p><em>target_lang</em>은 주어진 오브젝트가 컴파일된 대상 언어입니다. 이를 통해 특정 언어의 특정 링크 시간 처리가 가능합니다.</p>
<p>실패 시 <code class="xref py py-exc docutils literal notranslate"><span class="pre">LibError</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link">
<code class="sig-name descname">link</code><span class="sig-paren">(</span><em class="sig-param">target_desc</em>, <em class="sig-param">objects</em>, <em class="sig-param">output_filename</em><span class="optional">[</span>, <em class="sig-param">output_dir=None</em>, <em class="sig-param">libraries=None</em>, <em class="sig-param">library_dirs=None</em>, <em class="sig-param">runtime_library_dirs=None</em>, <em class="sig-param">export_symbols=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">extra_preargs=None</em>, <em class="sig-param">extra_postargs=None</em>, <em class="sig-param">build_temp=None</em>, <em class="sig-param">target_lang=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.link" title="정의 주소">¶</a></dt>
<dd><p>여러 가지를 함께 링크하여 실행 파일이나 공유 라이브러리 파일을 만듭니다.</p>
<p>&quot;여러 가지&quot;는 <em>objects</em>로 제공되는 오브젝트 파일 리스트로 구성됩니다. <em>output_filename</em>은 파일명이어야 합니다. <em>output_dir</em>이 제공되면, <em>output_filename</em>은 이에 상대적입니다 (즉 <em>output_filename</em>은 필요하면 디렉터리 구성 요소를 제공할 수 있습니다).</p>
<p><em>libraries</em>는 링크할 라이브러리 리스트입니다. 이는 파일명이 아니라 라이브러리 이름입니다. 플랫폼에 특정한 방식으로 파일명으로 변환되기 때문입니다 (예를 들어 <em>foo</em>는 유닉스에서는 <code class="file docutils literal notranslate"><span class="pre">libfoo.a</span></code>가 되고 DOS/윈도우에서는 <code class="file docutils literal notranslate"><span class="pre">foo.lib</span></code>가 됩니다). 그러나, 이들은 디렉터리 구성 요소를 포함할 수 있습니다. 이는 링커가 모든 정상적인 위치를 검색하지 않고 특정 디렉터리를 찾는다는 의미입니다.</p>
<p>제공되면, <em>library_dirs</em>는 맨 라이브러리 이름으로 지정된 라이브러리를 검색하기 위한 디렉터리 리스트이어야 합니다 (즉, 디렉터리 구성 요소가 없습니다). 이는 시스템 기본값과 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library_dir" title="distutils.ccompiler.CCompiler.add_library_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_library_dir()</span></code></a> 및/또는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_library_dirs" title="distutils.ccompiler.CCompiler.set_library_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_library_dirs()</span></code></a>에 제공된 것 위에 있습니다. <em>runtime_library_dirs</em>는 공유 라이브러리에 내장되고, *그것*이 실행 시간에 의존하는 다른 공유 라이브러리를 검색하는 데 사용되는 디렉터리 리스트입니다. (이것은 유닉스에서만 의미 있을 수 있습니다.)</p>
<p><em>export_symbols</em>는 공유 라이브러리가 내보낼 심볼 리스트입니다. (이것은 윈도우에서만 의미 있는 것으로 보입니다.)</p>
<p><em>debug</em>는 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compile()</span></code></a>과 <a class="reference internal" href="#distutils.ccompiler.CCompiler.create_static_lib" title="distutils.ccompiler.CCompiler.create_static_lib"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_static_lib()</span></code></a>와 같지만, 대부분의 플랫폼에서 실제로 중요하다는 약간의 차이가 있습니다 (대부분 형식을 위해 <em>debug</em> 플래그를 포함하는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.create_static_lib" title="distutils.ccompiler.CCompiler.create_static_lib"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_static_lib()</span></code></a>와 대조적입니다).</p>
<p><em>extra_preargs</em>와 <em>extra_postargs</em>는 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compile()</span></code></a>와 같습니다 (물론 사용 중인 특정 링커에 대한 명령 줄 인자를 제공한다는 점은 제외합니다).</p>
<p><em>target_lang</em>은 주어진 오브젝트가 컴파일된 대상 언어입니다. 이를 통해 특정 언어의 특정 링크 시간 처리가 가능합니다.</p>
<p>실패 시 <code class="xref py py-exc docutils literal notranslate"><span class="pre">LinkError</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link_executable">
<code class="sig-name descname">link_executable</code><span class="sig-paren">(</span><em class="sig-param">objects</em>, <em class="sig-param">output_progname</em><span class="optional">[</span>, <em class="sig-param">output_dir=None</em>, <em class="sig-param">libraries=None</em>, <em class="sig-param">library_dirs=None</em>, <em class="sig-param">runtime_library_dirs=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">extra_preargs=None</em>, <em class="sig-param">extra_postargs=None</em>, <em class="sig-param">target_lang=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.link_executable" title="정의 주소">¶</a></dt>
<dd><p>실행 파일을 링크합니다. <em>output_progname</em>은 실행 파일의 이름이고, <em>objects</em>는 링크할 오브젝트 파일명 리스트입니다. 다른 인자는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.link" title="distutils.ccompiler.CCompiler.link"><code class="xref py py-meth docutils literal notranslate"><span class="pre">link()</span></code></a> 메서드와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link_shared_lib">
<code class="sig-name descname">link_shared_lib</code><span class="sig-paren">(</span><em class="sig-param">objects</em>, <em class="sig-param">output_libname</em><span class="optional">[</span>, <em class="sig-param">output_dir=None</em>, <em class="sig-param">libraries=None</em>, <em class="sig-param">library_dirs=None</em>, <em class="sig-param">runtime_library_dirs=None</em>, <em class="sig-param">export_symbols=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">extra_preargs=None</em>, <em class="sig-param">extra_postargs=None</em>, <em class="sig-param">build_temp=None</em>, <em class="sig-param">target_lang=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.link_shared_lib" title="정의 주소">¶</a></dt>
<dd><p>공유 라이브러리를 링크합니다. <em>output_libname</em>은 출력 라이브러리의 이름이고, <em>objects</em>는 링크할 오브젝트 파일명 리스트입니다. 다른 인자는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.link" title="distutils.ccompiler.CCompiler.link"><code class="xref py py-meth docutils literal notranslate"><span class="pre">link()</span></code></a> 메서드와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link_shared_object">
<code class="sig-name descname">link_shared_object</code><span class="sig-paren">(</span><em class="sig-param">objects</em>, <em class="sig-param">output_filename</em><span class="optional">[</span>, <em class="sig-param">output_dir=None</em>, <em class="sig-param">libraries=None</em>, <em class="sig-param">library_dirs=None</em>, <em class="sig-param">runtime_library_dirs=None</em>, <em class="sig-param">export_symbols=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">extra_preargs=None</em>, <em class="sig-param">extra_postargs=None</em>, <em class="sig-param">build_temp=None</em>, <em class="sig-param">target_lang=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.link_shared_object" title="정의 주소">¶</a></dt>
<dd><p>공유 오브젝트를 링크합니다. <em>output_filename</em>은 생성될 공유 오브젝트의 이름이고, <em>objects</em>는 링크할 오브젝트 파일명 리스트입니다. 다른 인자는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.link" title="distutils.ccompiler.CCompiler.link"><code class="xref py py-meth docutils literal notranslate"><span class="pre">link()</span></code></a> 메서드와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.preprocess">
<code class="sig-name descname">preprocess</code><span class="sig-paren">(</span><em class="sig-param">source</em><span class="optional">[</span>, <em class="sig-param">output_file=None</em>, <em class="sig-param">macros=None</em>, <em class="sig-param">include_dirs=None</em>, <em class="sig-param">extra_preargs=None</em>, <em class="sig-param">extra_postargs=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.preprocess" title="정의 주소">¶</a></dt>
<dd><p><em>source</em>로 명명된 단일 C/C++ 소스 파일을 전처리합니다. 출력은 <em>output_file</em>이나, 또는 <em>output_file</em>이 제공되지 않으면 <em>stdout</em>으로 기록됩니다. <em>macros</em>는 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compile()</span></code></a>에서와 같은 매크로 정의 리스트로, <a class="reference internal" href="#distutils.ccompiler.CCompiler.define_macro" title="distutils.ccompiler.CCompiler.define_macro"><code class="xref py py-meth docutils literal notranslate"><span class="pre">define_macro()</span></code></a>와 <a class="reference internal" href="#distutils.ccompiler.CCompiler.undefine_macro" title="distutils.ccompiler.CCompiler.undefine_macro"><code class="xref py py-meth docutils literal notranslate"><span class="pre">undefine_macro()</span></code></a>로 설정된 매크로 집합을 확장합니다. <em>include_dirs</em>는 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_include_dir()</span></code></a>과 같은 방식으로 기본 리스트에 추가될 디렉터리 이름 리스트입니다.</p>
<p>실패 시 <code class="xref py py-exc docutils literal notranslate"><span class="pre">PreprocessError</span></code>를 발생시킵니다.</p>
</dd></dl>

<p>다음 유틸리티 메서드는 다양한 구상 서브 클래스에서 사용하기 위해 <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code></a> 클래스에 의해 정의됩니다.</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.executable_filename">
<code class="sig-name descname">executable_filename</code><span class="sig-paren">(</span><em class="sig-param">basename</em><span class="optional">[</span>, <em class="sig-param">strip_dir=0</em>, <em class="sig-param">output_dir=''</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.executable_filename" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>basename</em>에 대한 실행 파일의 파일명을 반환합니다. 일반적으로 윈도우가 아닌 플랫폼의 경우 basename과 같지만, 윈도우에서는 <code class="file docutils literal notranslate"><span class="pre">.exe</span></code>가 추가됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.library_filename">
<code class="sig-name descname">library_filename</code><span class="sig-paren">(</span><em class="sig-param">libname</em><span class="optional">[</span>, <em class="sig-param">lib_type='static'</em>, <em class="sig-param">strip_dir=0</em>, <em class="sig-param">output_dir=''</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.library_filename" title="정의 주소">¶</a></dt>
<dd><p>현재 플랫폼에서 주어진 라이브러리 이름에 대한 파일명을 반환합니다. 유닉스에서 <em>lib_type</em>이 <code class="docutils literal notranslate"><span class="pre">'static'</span></code>인 라이브러리는 일반적으로 <code class="file docutils literal notranslate"><span class="pre">liblibname.a</span></code> 형식이고, <em>lib_type</em>이 <code class="docutils literal notranslate"><span class="pre">'dynamic'</span></code> 인 라이브러리는 <code class="file docutils literal notranslate"><span class="pre">liblibname.so</span></code> 형식입니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.object_filenames">
<code class="sig-name descname">object_filenames</code><span class="sig-paren">(</span><em class="sig-param">source_filenames</em><span class="optional">[</span>, <em class="sig-param">strip_dir=0</em>, <em class="sig-param">output_dir=''</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.object_filenames" title="정의 주소">¶</a></dt>
<dd><p>주어진 소스 파일에 대한 오브젝트 파일의 이름을 반환합니다. <em>source_filenames</em>는 파일명 리스트이어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.shared_object_filename">
<code class="sig-name descname">shared_object_filename</code><span class="sig-paren">(</span><em class="sig-param">basename</em><span class="optional">[</span>, <em class="sig-param">strip_dir=0</em>, <em class="sig-param">output_dir=''</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.shared_object_filename" title="정의 주소">¶</a></dt>
<dd><p>주어진 파일 이름 <em>basename</em>에 대한 공유 오브젝트 파일의 이름을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.execute">
<code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">args</em><span class="optional">[</span>, <em class="sig-param">msg=None</em>, <em class="sig-param">level=1</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.execute" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.util.execute" title="distutils.util.execute"><code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.util.execute()</span></code></a>를 호출합니다. 이 메서드는 <em>dry_run</em> 플래그를 로깅하고 고려한 후, 주어진 인자 <em>args</em>로 파이썬 함수 <em>func</em>를 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.spawn">
<code class="sig-name descname">spawn</code><span class="sig-paren">(</span><em class="sig-param">cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.spawn" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.util.spawn()</span></code>을 호출합니다. 이것은 주어진 명령을 실행하기 위해 외부 프로세스를 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.mkpath">
<code class="sig-name descname">mkpath</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="optional">[</span>, <em class="sig-param">mode=511</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.mkpath" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.dir_util.mkpath" title="distutils.dir_util.mkpath"><code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.dir_util.mkpath()</span></code></a>를 호출합니다. 그러면 디렉터리와 누락된 조상 디렉터리를 만듭니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.move_file">
<code class="sig-name descname">move_file</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.move_file" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.file_util.move_file" title="distutils.file_util.move_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distutils.file_util.move_file()</span></code></a>을 호출합니다. <em>src</em>를 <em>dst</em>로 이름을 바꿉니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.announce">
<code class="sig-name descname">announce</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="optional">[</span>, <em class="sig-param">level=1</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.announce" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.log.debug()</span></code>를 사용하여 메시지를 작성합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.warn">
<code class="sig-name descname">warn</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.warn" title="정의 주소">¶</a></dt>
<dd><p>표준 에러에 경고 메시지 <em>msg</em>를 씁니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.debug_print">
<code class="sig-name descname">debug_print</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.ccompiler.CCompiler.debug_print" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code></a> 인스턴스에 <em>debug</em> 플래그가 설정되어 있으면, <em>msg</em>를 표준 출력으로 인쇄하고, 그렇지 않으면 아무 작업도 수행하지 않습니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-distutils.unixccompiler">
<span id="distutils-unixccompiler-unix-c-compiler"></span><h2><span class="section-number">9.3. </span><a class="reference internal" href="#module-distutils.unixccompiler" title="distutils.unixccompiler: UNIX C Compiler"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.unixccompiler</span></code></a> --- 유닉스 C 컴파일러<a class="headerlink" href="#module-distutils.unixccompiler" title="제목 주소">¶</a></h2>
<p>이 모듈은 일반적인 유닉스 스타일 명령 줄 C 컴파일러를 다루는 <code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code>의 서브 클래스인 <code class="xref py py-class docutils literal notranslate"><span class="pre">UnixCCompiler</span></code> 클래스를 제공합니다:</p>
<ul class="simple">
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">-Dname[=value]</span></code>로 정의된 매크로</p></li>
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">-Uname</span></code>으로 정의 해제된 매크로</p></li>
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">-Idir</span></code>로 지정된 인클루드 검색 디렉터리</p></li>
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">-llib</span></code>로 지정된 라이브러리</p></li>
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">-Ldir</span></code>로 지정된 라이브러리 검색 디렉터리</p></li>
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code> 옵션을 사용하여 <strong class="program">cc</strong> (또는 이와 유사한) 실행 파일로 처리되는 컴파일: <code class="file docutils literal notranslate"><span class="pre">.c</span></code>를 <code class="file docutils literal notranslate"><span class="pre">.o</span></code>로 컴파일합니다.</p></li>
<li><p><strong class="program">ar</strong> 명령으로 처리되는 정적 라이브러리 링크 (<strong class="program">ranlib</strong> 사용 가능)</p></li>
<li><p><strong class="program">cc</strong> <code class="xref std std-option docutils literal notranslate"><span class="pre">-shared</span></code>로 처리되는 공유 라이브러리 링크</p></li>
</ul>
</div>
<div class="section" id="module-distutils.msvccompiler">
<span id="distutils-msvccompiler-microsoft-compiler"></span><h2><span class="section-number">9.4. </span><a class="reference internal" href="#module-distutils.msvccompiler" title="distutils.msvccompiler: Microsoft Compiler"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.msvccompiler</span></code></a> --- Microsoft 컴파일러<a class="headerlink" href="#module-distutils.msvccompiler" title="제목 주소">¶</a></h2>
<p>이 모듈은 Microsoft Visual Studio 용 추상 <code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code> 클래스의 구현인, <code class="xref py py-class docutils literal notranslate"><span class="pre">MSVCCompiler</span></code>를 제공합니다. 일반적으로, 확장 모듈은 파이썬을 컴파일하는 데 사용된 것과 같은 컴파일러로 컴파일해야 합니다. 파이썬 2.3과 이전 버전의 경우, 컴파일러는 Visual Studio 6이었습니다. 파이썬 2.4와 2.5의 경우, 컴파일러는 Visual Studio .NET 2003입니다.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">MSVCCompiler</span></code>는 일반적으로 자체적으로 올바른 컴파일러, 링커 등을 선택합니다. 이 선택을 재정의하려면, 환경 변수 <em>DISTUTILS_USE_SDK</em>와 <em>MSSdk</em>를 모두 설정해야 합니다. <em>MSSdk</em>는 현재 환경이 SDK의 <code class="docutils literal notranslate"><span class="pre">SetEnv.Cmd</span></code> 스크립트에 의해 설정되었거나, SDK가 설치될 때 환경 변수가 등록되었음을 나타냅니다. <em>DISTUTILS_USE_SDK</em>는 distutils 사용자가 <code class="xref py py-class docutils literal notranslate"><span class="pre">MSVCCompiler</span></code>의 컴파일러 선택을 재정의하도록 명시적으로 선택했음을 나타냅니다.</p>
</div>
<div class="section" id="module-distutils.bcppcompiler">
<span id="distutils-bcppcompiler-borland-compiler"></span><h2><span class="section-number">9.5. </span><a class="reference internal" href="#module-distutils.bcppcompiler" title="distutils.bcppcompiler"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.bcppcompiler</span></code></a> --- Borland 컴파일러<a class="headerlink" href="#module-distutils.bcppcompiler" title="제목 주소">¶</a></h2>
<p>이 모듈은 Borland C++ 컴파일러용 추상 <code class="xref py py-class docutils literal notranslate"><span class="pre">CCompiler</span></code> 클래스의 서브 클래스인 <code class="xref py py-class docutils literal notranslate"><span class="pre">BorlandCCompiler</span></code>를 제공합니다.</p>
</div>
<div class="section" id="module-distutils.cygwinccompiler">
<span id="distutils-cygwincompiler-cygwin-compiler"></span><h2><span class="section-number">9.6. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.cygwincompiler</span></code> --- Cygwin 컴파일러<a class="headerlink" href="#module-distutils.cygwinccompiler" title="제목 주소">¶</a></h2>
<p>이 모듈은 윈도우로의 GNU C 컴파일러의 Cygwin 이식을 다루는 <code class="xref py py-class docutils literal notranslate"><span class="pre">UnixCCompiler</span></code>의 서브 클래스인 <code class="xref py py-class docutils literal notranslate"><span class="pre">CygwinCCompiler</span></code> 클래스를 제공합니다. 또한 GCC의 mingw32 이식을 다루는 Mingw32CCompiler 클래스도 포함합니다 (no-cygwin 모드의 cygwin과 같습니다).</p>
</div>
<div class="section" id="module-distutils.archive_util">
<span id="distutils-archive-util-archiving-utilities"></span><h2><span class="section-number">9.7. </span><a class="reference internal" href="#module-distutils.archive_util" title="distutils.archive_util: Utility functions for creating archive files (tarballs, zip files, ...)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.archive_util</span></code></a> --- 아카이브 유틸리티<a class="headerlink" href="#module-distutils.archive_util" title="제목 주소">¶</a></h2>
<p>이 모듈은 tar나 zip 파일과 같은 아카이브 파일을 만들기 위한 몇 가지 함수를 제공합니다.</p>
<dl class="function">
<dt id="distutils.archive_util.make_archive">
<code class="sig-prename descclassname">distutils.archive_util.</code><code class="sig-name descname">make_archive</code><span class="sig-paren">(</span><em class="sig-param">base_name</em>, <em class="sig-param">format</em><span class="optional">[</span>, <em class="sig-param">root_dir=None</em>, <em class="sig-param">base_dir=None</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.archive_util.make_archive" title="정의 주소">¶</a></dt>
<dd><p>아카이브 파일(예를 들어 <code class="docutils literal notranslate"><span class="pre">zip</span></code>이나 <code class="docutils literal notranslate"><span class="pre">tar</span></code>)을 만듭니다. <em>base_name</em>은 만들 파일의 이름에서 형식별 확장자를 뺀 것입니다; <em>format</em>은 아카이브 형식입니다: <code class="docutils literal notranslate"><span class="pre">zip</span></code>, <code class="docutils literal notranslate"><span class="pre">tar</span></code>, <code class="docutils literal notranslate"><span class="pre">gztar</span></code>, <code class="docutils literal notranslate"><span class="pre">bztar</span></code>, <code class="docutils literal notranslate"><span class="pre">xztar</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">ztar</span></code> 중 하나입니다. <em>root_dir</em>은 아카이브의 루트 디렉터리가 될 디렉터리입니다; 즉, 일반적으로 아카이브를 만들기 전에 <em>root_dir</em>로 <code class="docutils literal notranslate"><span class="pre">chdir</span></code> 합니다. <em>base_dir</em>은 아카이빙을 시작하는 디렉터리입니다; 즉. <em>base_dir</em>은 아카이브에 있는 모든 파일과 디렉터리의 공통 접두사입니다. <em>root_dir</em>과 <em>base_dir</em> 모두 기본값은 현재 디렉터리입니다. 아카이브 파일의 이름을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">xztar</span></code> 형식에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.archive_util.make_tarball">
<code class="sig-prename descclassname">distutils.archive_util.</code><code class="sig-name descname">make_tarball</code><span class="sig-paren">(</span><em class="sig-param">base_name</em>, <em class="sig-param">base_dir</em><span class="optional">[</span>, <em class="sig-param">compress='gzip'</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.archive_util.make_tarball" title="정의 주소">¶</a></dt>
<dd><p>'<em>base_dir</em>과 그 밑의 모든 파일로 구성된 tar 파일로 (선택적으로 압축된) 아카이브를 만듭니다. <em>compress</em>는 <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code> (기본값), <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'compress'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. <code class="docutils literal notranslate"><span class="pre">'compress'</span></code> 방법의 경우 <strong class="program">compress</strong>라는 이름의 압축 유틸리티가 기본 프로그램 검색 경로에 있어야 하므로, 이는 유닉스에 한정된 것일 수 있습니다. 출력 tar 파일의 이름은 <code class="file docutils literal notranslate"><span class="pre">base_dir.tar</span></code>이며, 적절한 압축 확장자 (<code class="docutils literal notranslate"><span class="pre">.gz</span></code>, <code class="docutils literal notranslate"><span class="pre">.bz2</span></code>, <code class="docutils literal notranslate"><span class="pre">.xz</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">.Z</span></code>)가 추가될 수 있습니다. 출력 파일명을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">xz</span></code> 압축에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.archive_util.make_zipfile">
<code class="sig-prename descclassname">distutils.archive_util.</code><code class="sig-name descname">make_zipfile</code><span class="sig-paren">(</span><em class="sig-param">base_name</em>, <em class="sig-param">base_dir</em><span class="optional">[</span>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.archive_util.make_zipfile" title="정의 주소">¶</a></dt>
<dd><p><em>base_dir</em>과 그 밑의 모든 파일로 zip 파일을 만듭니다. 출력 zip 파일의 이름은 <em>base_name</em> + <code class="file docutils literal notranslate"><span class="pre">.zip</span></code>입니다. (사용할 수 있으면) <a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 파이썬 모듈이나 (설치되어 기본 검색 경로에 있으면) InfoZIP <code class="file docutils literal notranslate"><span class="pre">zip</span></code> 유틸리티를 사용합니다. 두 도구를 모두 사용할 수 없으면, <code class="xref py py-exc docutils literal notranslate"><span class="pre">DistutilsExecError</span></code>를 발생시킵니다. 출력 zip 파일의 이름을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.dep_util">
<span id="distutils-dep-util-dependency-checking"></span><h2><span class="section-number">9.8. </span><a class="reference internal" href="#module-distutils.dep_util" title="distutils.dep_util: Utility functions for simple dependency checking"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dep_util</span></code></a> --- 종속성 검사<a class="headerlink" href="#module-distutils.dep_util" title="제목 주소">¶</a></h2>
<p>이 모듈은 파일과 파일 그룹의 간단한 타임 스탬프 기반 종속성을 수행하는 함수를 제공합니다; 또한, 이러한 타임 스탬프 종속성 분석에 전적으로 기반하는 함수를 제공합니다.</p>
<dl class="function">
<dt id="distutils.dep_util.newer">
<code class="sig-prename descclassname">distutils.dep_util.</code><code class="sig-name descname">newer</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dep_util.newer" title="정의 주소">¶</a></dt>
<dd><p><em>source</em>가 존재하고 <em>target</em>보다 최근에 수정되었거나, <em>source</em>가 존재하고 <em>target</em>이 존재하지 않으면 참을 반환합니다. 둘 다 존재하고 <em>target</em>이 같은 연령이거나 <em>source</em>보다 새로우면 거짓을 반환합니다. <em>source</em>가 없으면 <code class="xref py py-exc docutils literal notranslate"><span class="pre">DistutilsFileError</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dep_util.newer_pairwise">
<code class="sig-prename descclassname">distutils.dep_util.</code><code class="sig-name descname">newer_pairwise</code><span class="sig-paren">(</span><em class="sig-param">sources</em>, <em class="sig-param">targets</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dep_util.newer_pairwise" title="정의 주소">¶</a></dt>
<dd><p>두 개의 파일명 리스트를 병렬로 탐색하여, 각 소스가 해당 대상보다 최신인지 테스트합니다. <a class="reference internal" href="#distutils.dep_util.newer" title="distutils.dep_util.newer"><code class="xref py py-func docutils literal notranslate"><span class="pre">newer()</span></code></a>의 의미에 따라 소스가 대상보다 최신인 리스트 쌍 (<em>sources</em>, <em>targets</em>)를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dep_util.newer_group">
<code class="sig-prename descclassname">distutils.dep_util.</code><code class="sig-name descname">newer_group</code><span class="sig-paren">(</span><em class="sig-param">sources</em>, <em class="sig-param">target</em><span class="optional">[</span>, <em class="sig-param">missing='error'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dep_util.newer_group" title="정의 주소">¶</a></dt>
<dd><p><em>sources</em>에 나열된 파일과 관련하여 <em>target</em>이 오래되었으면 참을 반환합니다. 즉, <em>target</em>이 존재하고 <em>sources</em>의 모든 파일보다 최신이면 거짓을 반환합니다; 그렇지 않으면 참을 반환합니다. <em>missing</em>은 소스 파일이 누락되었을 때 수행하는 작업을 제어합니다; 기본값(<code class="docutils literal notranslate"><span class="pre">'error'</span></code>)은 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 내부에서 오는 <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>로 터뜨리는 것입니다; <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>이면, 누락된 소스 파일을 조용히 무시합니다; <code class="docutils literal notranslate"><span class="pre">'newer'</span></code>이면, 누락된 소스 파일은 <em>target</em>이 최신이 아니라고 가정하도록 합니다 (&quot;dry_run&quot; 모드에서 편리합니다: 입력이 누락되어 작동하지 않는 명령을 수행하는 척합니다만, 실제로 명령을 실행하지 않기 때문에 중요하지 않습니다.)</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.dir_util">
<span id="distutils-dir-util-directory-tree-operations"></span><h2><span class="section-number">9.9. </span><a class="reference internal" href="#module-distutils.dir_util" title="distutils.dir_util: Utility functions for operating on directories and directory trees"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dir_util</span></code></a> --- 디렉터리 트리 연산<a class="headerlink" href="#module-distutils.dir_util" title="제목 주소">¶</a></h2>
<p>이 모듈은 디렉터리와 디렉터리 트리에서 작동하는 함수를 제공합니다.</p>
<dl class="function">
<dt id="distutils.dir_util.mkpath">
<code class="sig-prename descclassname">distutils.dir_util.</code><code class="sig-name descname">mkpath</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="optional">[</span>, <em class="sig-param">mode=0o777</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dir_util.mkpath" title="정의 주소">¶</a></dt>
<dd><p>디렉터리와 누락된 모든 조상 디렉터리를 만듭니다. 디렉터리가 이미 존재하면 (또는 <em>name</em>이 현재 디렉터리를 의미하는 빈 문자열이면, 물론 당연히 존재합니다), 아무 작업도 수행하지 않습니다. 도중에 일부 디렉터리를 만들 수 없으면 <code class="xref py py-exc docutils literal notranslate"><span class="pre">DistutilsFileError</span></code>를 발생시킵니다 (예를 들어 일부 하위 경로가 있지만, 디렉터리가 아니라 파일이면). <em>verbose</em>가 참이면, 각 mkdir의 한 줄 요약을 stdout에 인쇄합니다. 실제로 만들어진 디렉터리 리스트를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dir_util.create_tree">
<code class="sig-prename descclassname">distutils.dir_util.</code><code class="sig-name descname">create_tree</code><span class="sig-paren">(</span><em class="sig-param">base_dir</em>, <em class="sig-param">files</em><span class="optional">[</span>, <em class="sig-param">mode=0o777</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dir_util.create_tree" title="정의 주소">¶</a></dt>
<dd><p><em>base_dir</em> 아래에 <em>files</em>를 넣는 데 필요한 모든 빈 디렉터리를 만듭니다. <em>base_dir</em>은 아직 존재할 필요는 없는 디렉터리의 이름일 뿐입니다; <em>files</em>는 <em>base_dir</em>에 상대적으로 해석할 파일명 리스트입니다. <em>base_dir</em> + <em>files</em>에 있는 모든 파일의 디렉터리 부분이 아직 존재하지 않는다면 만들어집니다. <em>mode</em>, <em>verbose</em> 및 <em>dry_run</em> 플래그는 <a class="reference internal" href="#distutils.dir_util.mkpath" title="distutils.dir_util.mkpath"><code class="xref py py-func docutils literal notranslate"><span class="pre">mkpath()</span></code></a>와 같습니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dir_util.copy_tree">
<code class="sig-prename descclassname">distutils.dir_util.</code><code class="sig-name descname">copy_tree</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="optional">[</span>, <em class="sig-param">preserve_mode=1</em>, <em class="sig-param">preserve_times=1</em>, <em class="sig-param">preserve_symlinks=0</em>, <em class="sig-param">update=0</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dir_util.copy_tree" title="정의 주소">¶</a></dt>
<dd><p>전체 디렉터리 트리 <em>src</em>를 새 위치 <em>dst</em>로 복사합니다. <em>src</em>와 <em>dst</em>는 모두 디렉터리 이름이어야 합니다. <em>src</em>가 디렉터리가 아니면, <code class="xref py py-exc docutils literal notranslate"><span class="pre">DistutilsFileError</span></code>를 발생시킵니다. <em>dst</em>가 없으면, <a class="reference internal" href="#distutils.dir_util.mkpath" title="distutils.dir_util.mkpath"><code class="xref py py-func docutils literal notranslate"><span class="pre">mkpath()</span></code></a>로 만들어집니다. 복사의 최종 결과는 <em>src</em>의 모든 파일이 <em>dst</em>로 복사되고, <em>src</em> 아래의 디렉터리가 재귀적으로 <em>dst</em>로 복사된다는 것입니다. 출력 이름을 사용하여, 복사되었거나 복사되었어야 할 파일 리스트를 반환합니다. 반환 값은 <em>update</em>나 <em>dry_run</em>의 영향을 받지 않습니다: 단순히 <em>src</em> 아래의 모든 파일 리스트이며, 이름이 <em>dst</em> 아래로 변경된 것입니다.</p>
<p><em>preserve_mode</em>와 <em>preserve_times</em>는 <a class="reference internal" href="#distutils.file_util.copy_file" title="distutils.file_util.copy_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">distutils.file_util.copy_file()</span></code></a>과 같습니다; 디렉터리가 아닌 일반 파일에만 적용됨에 유의하십시오. <em>preserve_symlinks</em>가 참이면, 심볼릭 링크가 심볼릭 링크로 복사됩니다 (지원하는 플랫폼에서!); 그렇지 않으면 (기본값), 심볼릭 링크의 대상이 복사됩니다. <em>update</em>와 <em>verbose</em>는 <code class="xref py py-func docutils literal notranslate"><span class="pre">copy_file()</span></code>과 같습니다.</p>
<p><code class="file docutils literal notranslate"><span class="pre">.nfs</span></code>로 시작하는 <em>src</em>의 파일은 건너뜁니다 (이러한 파일에 대한 자세한 내용은 <a class="reference external" href="http://nfs.sourceforge.net/#section_d">NFS FAQ page</a>의 답변 D2에서 볼 수 있습니다).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3.1에서 변경: </span>NFS 파일은 무시됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.dir_util.remove_tree">
<code class="sig-prename descclassname">distutils.dir_util.</code><code class="sig-name descname">remove_tree</code><span class="sig-paren">(</span><em class="sig-param">directory</em><span class="optional">[</span>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.dir_util.remove_tree" title="정의 주소">¶</a></dt>
<dd><p><em>directory</em>와 그 아래의 모든 파일과 디렉터리를 재귀적으로 제거합니다. 모든 에러는 무시됩니다 (<em>verbose</em>가 참이면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>에 보고되는 것은 제외하고).</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.file_util">
<span id="distutils-file-util-single-file-operations"></span><h2><span class="section-number">9.10. </span><a class="reference internal" href="#module-distutils.file_util" title="distutils.file_util: Utility functions for operating on single files"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.file_util</span></code></a> --- 단일 파일 연산<a class="headerlink" href="#module-distutils.file_util" title="제목 주소">¶</a></h2>
<p>이 모듈에는 개별 파일에서 작동하는 몇 가지 유틸리티 함수가 포함되어 있습니다.</p>
<dl class="function">
<dt id="distutils.file_util.copy_file">
<code class="sig-prename descclassname">distutils.file_util.</code><code class="sig-name descname">copy_file</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="optional">[</span>, <em class="sig-param">preserve_mode=1</em>, <em class="sig-param">preserve_times=1</em>, <em class="sig-param">update=0</em>, <em class="sig-param">link=None</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.file_util.copy_file" title="정의 주소">¶</a></dt>
<dd><p><em>src</em> 파일을 <em>dst</em>로 복사합니다. <em>dst</em>가 디렉터리이면, <em>src</em>는 같은 이름으로 거기에 복사됩니다; 그렇지 않으면, 파일명이어야 합니다. (파일이 존재하면, 무자비하게 파괴될 것입니다.) <em>preserve_mode</em>가 참(기본값)이면, 파일의 모드(유형과 권한 비트, 또는 현재 플랫폼에서 유사한 무엇이건)가 복사됩니다. <em>preserve_times</em>가 참(기본값)이면, 마지막 수정과 마지막 액세스 시간도 복사됩니다. <em>update</em>가 참이면, <em>dst</em>가 존재하지 않거나, <em>dst</em>가 존재하지만 <em>src</em>보다 오래된 경우에만 <em>src</em>가 복사됩니다.</p>
<p><em>link</em>를 사용하면 복사하는 대신 하드 링크(<a class="reference internal" href="../library/os.html#os.link" title="os.link"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.link()</span></code></a> 사용)나 심볼릭 링크(<a class="reference internal" href="../library/os.html#os.symlink" title="os.symlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.symlink()</span></code></a> 사용)를 만들 수 있습니다: <code class="docutils literal notranslate"><span class="pre">'hard'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'sym'</span></code>으로 설정하십시오; <code class="docutils literal notranslate"><span class="pre">None</span></code>(기본값)이면, 파일이 복사됩니다. 지원하지 않는 시스템에서는 <em>link</em>를 설정하지 마십시오: <a class="reference internal" href="#distutils.file_util.copy_file" title="distutils.file_util.copy_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy_file()</span></code></a>은 하드나 심볼릭 링크를 사용할 수 있는지 확인하지 않습니다. <code class="xref py py-func docutils literal notranslate"><span class="pre">_copy_file_contents()</span></code>를 사용하여 파일 내용을 복사합니다.</p>
<p>튜플 <code class="docutils literal notranslate"><span class="pre">(dest_name,</span> <span class="pre">copied)</span></code>를 반환합니다: <em>dest_name</em>은 출력 파일의 실제 이름이고, 파일이 복사되었으면 (또는 <em>dry_run</em>이 참이면, 복사했어야 할 것이면) <em>copied</em>는 참입니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.file_util.move_file">
<code class="sig-prename descclassname">distutils.file_util.</code><code class="sig-name descname">move_file</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="optional">[</span>, <em class="sig-param">verbose</em>, <em class="sig-param">dry_run</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.file_util.move_file" title="정의 주소">¶</a></dt>
<dd><p><em>src</em> 파일을 <em>dst</em>로 이동합니다. <em>dst</em>가 디렉터리이면, 파일은 같은 이름으로 거기에 이동됩니다; 그렇지 않으면, <em>src</em>는 단지 <em>dst</em>로 이름이 바뀝니다. 파일의 새로운 전체 이름을 반환합니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="#distutils.file_util.copy_file" title="distutils.file_util.copy_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy_file()</span></code></a>을 사용하여 유닉스에서 장치 간 이동을 처리합니다. 다른 시스템은 어떻습니까?</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.file_util.write_file">
<code class="sig-prename descclassname">distutils.file_util.</code><code class="sig-name descname">write_file</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">contents</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.file_util.write_file" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>이라는 파일을 만들고 그곳에 <em>contents</em>(줄 종결자가 없는 문자열 시퀀스)를 씁니다.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.util">
<span id="distutils-util-miscellaneous-other-utility-functions"></span><h2><span class="section-number">9.11. </span><a class="reference internal" href="#module-distutils.util" title="distutils.util: Miscellaneous other utility functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.util</span></code></a> --- 기타 유틸리티 함수<a class="headerlink" href="#module-distutils.util" title="제목 주소">¶</a></h2>
<p>이 모듈에는 다른 유틸리티 모듈에 맞지 않는 잡동사니가 포함되어 있습니다.</p>
<dl class="function">
<dt id="distutils.util.get_platform">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">get_platform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.get_platform" title="정의 주소">¶</a></dt>
<dd><p>현재 플랫폼을 식별하는 문자열을 반환합니다. 주로 플랫폼별 빌드 디렉터리와 플랫폼별 빌드 배포판을 구분하는 데 사용됩니다. 포함된 정확한 정보는 OS에 따라 다르지만, 일반적으로 OS 이름과 버전 및 아키텍처를 포함합니다 ('os.uname()'에서 제공되는); 예를 들어, 리눅스에서는 커널 버전이 특별히 중요하지 않습니다.</p>
<p>반환된 값의 예:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">linux-i586</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">linux-alpha</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solaris-2.6-sun4u</span></code></p></li>
</ul>
<p>POSIX가 아닌 플랫폼의 경우, 현재는 <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> 만 반환합니다.</p>
<p>Mac OS X 시스템의 경우 OS 버전은 현재 시스템의 OS 버전이 아니라, 바이너리가 실행될 최소 버전(즉, 파이썬 빌드 중 <code class="docutils literal notranslate"><span class="pre">MACOSX_DEPLOYMENT_TARGET</span></code>의 값)을 반영합니다.</p>
<p>Mac OS X의 유니버설 바이너리 빌드의 경우 아키텍처값은 현재 프로세서의 아키텍처 대신 유니버설 바이너리 상태를 반영합니다. 32비트 유니버설 바이너리의 경우 아키텍처는 <code class="docutils literal notranslate"><span class="pre">fat</span></code>, 64비트 유니버설 바이너리의 경우 아키텍처는 <code class="docutils literal notranslate"><span class="pre">fat64</span></code>, 4방향 유니버설 바이너리(4-way universal binaries)의 경우 아키텍처는 <code class="docutils literal notranslate"><span class="pre">universal</span></code>입니다. 파이썬 2.7과 파이썬 3.2부터 아키텍처 <code class="docutils literal notranslate"><span class="pre">fat3</span></code>은 3방향 유니버설 빌드 (ppc, i386, x86_64)에 사용되고 <code class="docutils literal notranslate"><span class="pre">intel</span></code>은 i386과 x86_64 아키텍처의 유니버설 빌드에 사용됩니다.</p>
<p>Mac OS X에서 반환되는 값의 예:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">macosx-10.3-ppc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macosx-10.3-fat</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macosx-10.5-universal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macosx-10.6-intel</span></code></p></li>
</ul>
<p>AIX의 경우, 파이썬 3.9 이상은 &quot;aix&quot;로 시작하고, 그 뒤에 (<code class="docutils literal notranslate"><span class="pre">'-'</span></code>로 구분된) 추가 필드가 따라오는 문자열을 반환합니다. 추가 필드는 AIX 버전, 릴리스 및 기술 수준 (첫 번째 필드), 빌드 날짜 (두 번째 필드) 및 비트 크기(세 번째 필드)의 결합한 값을 나타냅니다. 파이썬 3.8과 이전 버전에서는 AIX 버전과 릴리스를 갖는 단일 추가 필드만 반환했습니다.</p>
<p>AIX에서 반환되는 값의 예:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">aix-5307-0747-32</span></code> # AIX <code class="docutils literal notranslate"><span class="pre">oslevel</span> <span class="pre">-s</span></code>: 5300-07-00-0000 에서 32비트 빌드</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">aix-7105-1731-64</span></code> # AIX <code class="docutils literal notranslate"><span class="pre">oslevel</span> <span class="pre">-s</span></code>: 7100-05-01-1731 에서 64비트 빌드</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">aix-7.2</span></code>          # 파이썬 3.8과 이전 버전에서 보고된 레거시 형식</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이제 AIX 플랫폼 문자열 형식에는 기술 수준, 빌드 날짜 및 ABI 비트 크기도 포함됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.util.convert_path">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">convert_path</code><span class="sig-paren">(</span><em class="sig-param">pathname</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.convert_path" title="정의 주소">¶</a></dt>
<dd><p>'pathname'을 네이티브 파일 시스템에서 작동할 이름으로 반환합니다, 즉 '/'로 분할하고 현재 디렉터리 구분자를 사용하여 다시 합칩니다. 설정 스크립트의 파일명은 항상 유닉스 스타일로 제공되고, 파일 시스템에서 실제로 사용하기 전에 로컬 규칙으로 변환해야 해서 필요합니다. <em>pathname</em>이 슬래시로 시작하거나 끝나면 유닉스가 아닌 시스템에서 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.change_root">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">change_root</code><span class="sig-paren">(</span><em class="sig-param">new_root</em>, <em class="sig-param">pathname</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.change_root" title="정의 주소">¶</a></dt>
<dd><p><em>new_root</em>가 앞에 추가된 <em>pathname</em>을 반환합니다. <em>pathname</em>이 상대적이면, <code class="docutils literal notranslate"><span class="pre">os.path.join(new_root,pathname)</span></code>과 동등합니다. 그렇지 않으면, <em>pathname</em>을 상대적으로 만든 다음 두 개를 결합해야 하는데, 이는 DOS/윈도우에서는 까다롭습니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.check_environ">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">check_environ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.check_environ" title="정의 주소">¶</a></dt>
<dd><p>사용자가 구성 파일, 명령 줄 옵션 등에서 사용할 수 있도록 보장하는 모든 환경 변수가 'os.environ'에 있도록 합니다. 현재 여기에는 다음이 포함됩니다:</p>
<ul class="simple">
<li><p><span class="target" id="index-19"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code> - 사용자의 홈 디렉터리 (유닉스 전용)</p></li>
<li><p><span class="target" id="index-20"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PLAT</span></code> - 하드웨어와 OS를 포함한, 현재 플랫폼에 대한 설명 (<a class="reference internal" href="#distutils.util.get_platform" title="distutils.util.get_platform"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_platform()</span></code></a>을 참조하십시오)</p></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="distutils.util.subst_vars">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">subst_vars</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">local_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.subst_vars" title="정의 주소">¶</a></dt>
<dd><p><em>s</em>에서 셸/Perl 스타일 변수 치환을 수행합니다. <code class="docutils literal notranslate"><span class="pre">$</span></code> 다음에 이름이 오는 모든 항목은 변수로 간주하며, 변수는 <em>local_vars</em> 딕셔너리에 있는 값으로 치환되거나, <em>local_vars</em>에 없으면 <code class="docutils literal notranslate"><span class="pre">os.environ</span></code>에 있는 값으로 치환됩니다. <em>os.environ</em>은 특정 값들이 포함되어 있도록 보장하기 위해 먼저 확인/보강됩니다: <a class="reference internal" href="#distutils.util.check_environ" title="distutils.util.check_environ"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_environ()</span></code></a>을 참조하십시오. <em>local_vars</em>나 <code class="docutils literal notranslate"><span class="pre">os.environ</span></code>에서 찾을 수 없는 변수에 대해 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
<p>이것은 완전한 문자열 보간 함수가 아님에 유의하십시오. 유효한 <code class="docutils literal notranslate"><span class="pre">$variable</span></code>은 대문자와 소문자, 숫자와 밑줄로만 구성될 수 있습니다. { } 또는 ( ) 스타일 인용을 사용할 수 없습니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.split_quoted">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">split_quoted</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.split_quoted" title="정의 주소">¶</a></dt>
<dd><p>따옴표와 역 슬래시에 대한 유닉스 셸과 유사한 규칙에 따라 문자열을 분할합니다. 간단히 말해서: 단어는 스페이스가 역 슬래시로 이스케이프 되거나 따옴표로 묶인 문자열 안에 있지 않은 한 스페이스로 구분됩니다. 작은따옴표와 큰따옴표는 동등하며, 따옴표 문자는 역 슬래시 이스케이프 될 수 있습니다. 역 슬래시는 두 문자 이스케이프 시퀀스에서 제거되어, 이스케이프 된 문자만 남깁니다. 따옴표 문자는 따옴표로 묶인 문자열에서 제거됩니다. 단어 리스트를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.execute">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">args</em><span class="optional">[</span>, <em class="sig-param">msg=None</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">dry_run=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.execute" title="정의 주소">¶</a></dt>
<dd><p>외부 세계에 영향을 미치는 어떤 작업을 수행합니다 (예를 들어, 파일 시스템에 쓰기). 이러한 작업은 <em>dry_run</em> 플래그에 의해 비활성화되기 때문에 특별합니다. 이 메서드는 당신을 위해 모든 관료적 절차를 관리합니다; 여러분은 호출할 함수와 이를 위한 인자 튜플(수행되는 &quot;외부 작업&quot;을 내재하기 위해) 및 인쇄할 선택적 메시지를 제공하기만 하면 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.strtobool">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">strtobool</code><span class="sig-paren">(</span><em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.strtobool" title="정의 주소">¶</a></dt>
<dd><p>논릿값의 문자열 표현을 true (1) 또는 false (0) 로 변환합니다.</p>
<p>참값은 <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">yes</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">on</span></code> 및 <code class="docutils literal notranslate"><span class="pre">1</span></code>입니다; 거짓 값은 <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">no</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code>, <code class="docutils literal notranslate"><span class="pre">off</span></code> 및 <code class="docutils literal notranslate"><span class="pre">0</span></code>입니다. <em>val</em>이 다른 값이면 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.byte_compile">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">byte_compile</code><span class="sig-paren">(</span><em class="sig-param">py_files</em><span class="optional">[</span>, <em class="sig-param">optimize=0</em>, <em class="sig-param">force=0</em>, <em class="sig-param">prefix=None</em>, <em class="sig-param">base_dir=None</em>, <em class="sig-param">verbose=1</em>, <em class="sig-param">dry_run=0</em>, <em class="sig-param">direct=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.byte_compile" title="정의 주소">¶</a></dt>
<dd><p>파이썬 소스 파일 모음을 <code class="file docutils literal notranslate"><span class="pre">__pycache__</span></code> 하위 디렉터리의 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 파일로 바이트 컴파일합니다 (<span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>과 <span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a>을 참조하십시오). <em>py_files</em>는 컴파일할 파일 리스트입니다; <code class="file docutils literal notranslate"><span class="pre">.py</span></code>로 끝나지 않는 모든 파일은 조용히 건너뜁니다. <em>optimize</em>는 다음 중 하나여야 합니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - 최적화하지 않습니다</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - 일반 최적화 (<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-O</span></code>처럼)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> - 추가 최적화 (<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-OO</span></code>처럼)</p></li>
</ul>
<p><em>force</em>가 참이면, 타임 스탬프와 관계없이 모든 파일이 다시 컴파일됩니다.</p>
<p>각 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 파일에 인코딩된 소스 파일명은 기본적으로 <em>py_files</em>에 나열된 파일명입니다; <em>prefix</em>와 <em>basedir</em>로 수정할 수 있습니다. <em>prefix</em>는 각 소스 파일명에서 제거되는 문자열이고, <em>base_dir</em>은 (<em>prefix</em>가 제거된 후) 앞에 추가되는 디렉터리 이름입니다. 원하는 대로, <em>prefix</em>와 <em>base_dir</em> 중 하나나 둘 다 제공 할 수 있습니다 (또는 아무것도 제공하지 않아도 됩니다).</p>
<p><em>dry_run</em>이 참이면, 파일 시스템에 영향을 미치는 작업을 실제로 수행하지 않습니다.</p>
<p>바이트 컴파일은 표준 <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a> 모듈을 사용하여 이 인터프리터 프로세스에서 직접 수행되거나, 임시 스크립트를 작성하고 실행하여 간접적으로 수행됩니다. 일반적으로, <a class="reference internal" href="#distutils.util.byte_compile" title="distutils.util.byte_compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">byte_compile()</span></code></a>이 직접 컴파일을 사용할지를 파악하도록 해야 합니다 (자세한 내용은 소스를 참조하십시오). <em>direct</em> 플래그는 간접 모드에서 생성된 스크립트에서 사용됩니다; 무엇을 하고 있는지 모른다면, <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 그냥 두십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2.3에서 변경: </span>현재 디렉터리에 태그가 없는 파일 대신 <code class="file docutils literal notranslate"><span class="pre">__pycache__</span></code> 하위 디렉터리에, 이름에 <a class="reference internal" href="../library/imp.html#imp.get_tag" title="imp.get_tag"><code class="xref py py-func docutils literal notranslate"><span class="pre">임포트</span> <span class="pre">매직</span> <span class="pre">태그</span></code></a>가 있는 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 만듭니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a>에 따라 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 만듭니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.util.rfc822_escape">
<code class="sig-prename descclassname">distutils.util.</code><code class="sig-name descname">rfc822_escape</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.util.rfc822_escape" title="정의 주소">¶</a></dt>
<dd><p>각 줄 바꿈 뒤에 8개의 스페이스가 있도록 하여, <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> 헤더에 포함하기 위한 이스케이프 된 <em>header</em> 버전을 반환합니다. 문자열의 다른 수정은 하지 않음에 유의하십시오.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.dist">
<span id="distutils-dist-the-distribution-class"></span><h2><span class="section-number">9.12. </span><a class="reference internal" href="#module-distutils.dist" title="distutils.dist: Provides the Distribution class, which represents the module distribution being built/installed/distributed"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dist</span></code></a> --- Distribution 클래스<a class="headerlink" href="#module-distutils.dist" title="제목 주소">¶</a></h2>
<p>이 모듈은 빌드/설치/배포 중인 모듈 배포를 나타내는 <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a> 클래스를 제공합니다.</p>
</div>
<div class="section" id="module-distutils.extension">
<span id="distutils-extension-the-extension-class"></span><h2><span class="section-number">9.13. </span><a class="reference internal" href="#module-distutils.extension" title="distutils.extension: Provides the Extension class, used to describe C/C++ extension modules in setup scripts"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.extension</span></code></a> --- Extension 클래스<a class="headerlink" href="#module-distutils.extension" title="제목 주소">¶</a></h2>
<p>이 모듈은 설정 스크립트에서 C/C++ 확장 모듈을 기술하는 데 사용되는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> 클래스를 제공합니다.</p>
</div>
<div class="section" id="module-distutils.debug">
<span id="distutils-debug-distutils-debug-mode"></span><h2><span class="section-number">9.14. </span><a class="reference internal" href="#module-distutils.debug" title="distutils.debug: Provides the debug flag for distutils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.debug</span></code></a> --- Distutils 디버그 모드<a class="headerlink" href="#module-distutils.debug" title="제목 주소">¶</a></h2>
<p>이 모듈은 DEBUG 플래그를 제공합니다.</p>
</div>
<div class="section" id="module-distutils.errors">
<span id="distutils-errors-distutils-exceptions"></span><h2><span class="section-number">9.15. </span><a class="reference internal" href="#module-distutils.errors" title="distutils.errors: Provides standard distutils exceptions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.errors</span></code></a> --- Distutils 예외<a class="headerlink" href="#module-distutils.errors" title="제목 주소">¶</a></h2>
<p>Distutils 모듈에서 사용하는 예외를 제공합니다. Distutils 모듈은 표준 예외를 발생시킬 수 있음에 유의하십시오; 특히 명백히 최종 사용자의 잘못인 에러(예를 들어 잘못된 명령 줄 인자)에 대해 일반적으로 SystemExit가 발생합니다.</p>
<p>이 모듈은 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">*</span></code> 모드에서 사용하기에 안전합니다; 이름이 <code class="docutils literal notranslate"><span class="pre">Distutils</span></code>로 시작하고 <code class="docutils literal notranslate"><span class="pre">Error</span></code>로 끝나는 심볼만 내보냅니다.</p>
</div>
<div class="section" id="module-distutils.fancy_getopt">
<span id="distutils-fancy-getopt-wrapper-around-the-standard-getopt-module"></span><h2><span class="section-number">9.16. </span><a class="reference internal" href="#module-distutils.fancy_getopt" title="distutils.fancy_getopt: Additional getopt functionality"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.fancy_getopt</span></code></a> --- 표준 getopt 모듈을 감싸는 래퍼<a class="headerlink" href="#module-distutils.fancy_getopt" title="제목 주소">¶</a></h2>
<p>이 모듈은 다음과 같은 추가 기능을 제공하는 표준 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> 모듈에 대한 래퍼를 제공합니다:</p>
<ul class="simple">
<li><p>짧고 긴 옵션이 함께 묶입니다</p></li>
<li><p>옵션에는 도움말 문자열이 있어서, <a class="reference internal" href="#distutils.fancy_getopt.fancy_getopt" title="distutils.fancy_getopt.fancy_getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">fancy_getopt()</span></code></a>는 잠재적으로 완전한 사용법 요약을 만들 수 있습니다</p></li>
<li><p>옵션은 전달된 객체의 어트리뷰트를 설정합니다</p></li>
<li><p>불리언 옵션은 &quot;부의 별칭&quot;을 가질 수 있습니다 --- 예를 들어 <code class="xref std std-option docutils literal notranslate"><span class="pre">--quiet</span></code>가 <code class="xref std std-option docutils literal notranslate"><span class="pre">--verbose</span></code>의 &quot;부의 별칭&quot;이면, 명령 줄의 <code class="xref std std-option docutils literal notranslate"><span class="pre">--quiet</span></code>는 <em>verbose</em>를 거짓으로 설정합니다.</p></li>
</ul>
<dl class="function">
<dt id="distutils.fancy_getopt.fancy_getopt">
<code class="sig-prename descclassname">distutils.fancy_getopt.</code><code class="sig-name descname">fancy_getopt</code><span class="sig-paren">(</span><em class="sig-param">options</em>, <em class="sig-param">negative_opt</em>, <em class="sig-param">object</em>, <em class="sig-param">args</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.fancy_getopt.fancy_getopt" title="정의 주소">¶</a></dt>
<dd><p>래퍼 함수. <em>options</em>는 <a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyGetopt</span></code></a>의 생성자에 설명된 대로 <code class="docutils literal notranslate"><span class="pre">(long_option,</span> <span class="pre">short_option,</span> <span class="pre">help_string)</span></code> 3-튜플의 리스트입니다. <em>negative_opt</em>는 옵션 이름을 옵션 이름에 매핑하는 딕셔너리이어야 하며, 키와 값은 모두 <em>options</em> 리스트에 있어야 합니다. <em>object</em>는 값을 저장하는 데 사용되는 객체입니다 (<a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyGetopt</span></code></a> 클래스의 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-meth docutils literal notranslate"><span class="pre">getopt()</span></code></a> 메서드를 참조하십시오). <em>args</em>는 인자 리스트입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>을 <em>args</em>로 전달하면 <code class="docutils literal notranslate"><span class="pre">sys.argv[1:]</span></code>을 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.fancy_getopt.wrap_text">
<code class="sig-prename descclassname">distutils.fancy_getopt.</code><code class="sig-name descname">wrap_text</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">width</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.fancy_getopt.wrap_text" title="정의 주소">¶</a></dt>
<dd><p><em>text</em>를 <em>width</em> 너비 미만으로 래핑합니다.</p>
</dd></dl>

<dl class="class">
<dt id="distutils.fancy_getopt.FancyGetopt">
<em class="property">class </em><code class="sig-prename descclassname">distutils.fancy_getopt.</code><code class="sig-name descname">FancyGetopt</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">option_table=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt" title="정의 주소">¶</a></dt>
<dd><p>option_table은 3-튜플 리스트입니다: <code class="docutils literal notranslate"><span class="pre">(long_option,</span> <span class="pre">short_option,</span> <span class="pre">help_string)</span></code></p>
<p>옵션이 인자를 취하면, <em>long_option</em>에 <code class="docutils literal notranslate"><span class="pre">'='</span></code>가 추가되어야 합니다; <em>short_option</em>은 단일 문자여야 하며, 어떤 경우에도 <code class="docutils literal notranslate"><span class="pre">':'</span></code>이 아니어야 합니다. <em>long_option</em>에 대응하는 <em>short_option</em>이 없으면 <em>short_option</em>은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 모든 옵션 튜플에는 긴 옵션이 있어야 합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyGetopt</span></code></a> 클래스는 다음 메서드를 제공합니다:</p>
<dl class="method">
<dt id="distutils.fancy_getopt.FancyGetopt.getopt">
<code class="sig-prename descclassname">FancyGetopt.</code><code class="sig-name descname">getopt</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">args=None</em>, <em class="sig-param">object=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt.getopt" title="정의 주소">¶</a></dt>
<dd><p>args에서 명령 줄 옵션을 구문 분석합니다. <em>object</em>에 어트리뷰트로 저장합니다.</p>
<p><em>args</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이거나 제공되지 않으면, <code class="docutils literal notranslate"><span class="pre">sys.argv[1:]</span></code>을 사용합니다. <em>object</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이거나 제공되지 않으면, 새 <code class="xref py py-class docutils literal notranslate"><span class="pre">OptionDummy</span></code> 인스턴스를 만들고, 여기에 옵션값을 저장하고, 튜플 <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">object)</span></code>를 반환합니다. <em>object</em>가 제공되면, 제자리에서 수정되고 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a>는 <em>args</em> 만 반환합니다; 두 경우 모두, 반환된 <em>args</em>는 전달된 <em>args</em> 리스트의 수정된 복사본이며, 전달된 <em>args</em>는 그대로 유지됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.fancy_getopt.FancyGetopt.get_option_order">
<code class="sig-prename descclassname">FancyGetopt.</code><code class="sig-name descname">get_option_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt.get_option_order" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-meth docutils literal notranslate"><span class="pre">getopt()</span></code></a>의 이전 실행에서 처리한 <code class="docutils literal notranslate"><span class="pre">(option,</span> <span class="pre">value)</span></code> 튜플 리스트를 반환합니다. <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-meth docutils literal notranslate"><span class="pre">getopt()</span></code></a>가 아직 호출되지 않았으면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.fancy_getopt.FancyGetopt.generate_help">
<code class="sig-prename descclassname">FancyGetopt.</code><code class="sig-name descname">generate_help</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">header=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt.generate_help" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyGetopt</span></code></a> 객체에 대한 옵션 테이블에서 도움말 텍스트(문자열 리스트, 제안된 출력 줄 당 하나씩)를 생성합니다.</p>
<p>제공되면, 도움말 맨 위에 제공된 <em>header</em>를 인쇄합니다.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.filelist">
<span id="distutils-filelist-the-filelist-class"></span><h2><span class="section-number">9.17. </span><a class="reference internal" href="#module-distutils.filelist" title="distutils.filelist: The FileList class, used for poking about the file system and building lists of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.filelist</span></code></a> --- FileList 클래스<a class="headerlink" href="#module-distutils.filelist" title="제목 주소">¶</a></h2>
<p>이 모듈은 <code class="xref py py-class docutils literal notranslate"><span class="pre">FileList</span></code> 클래스를 제공하며, 파일 시스템에 대한 정보를 확인하고 파일 리스트를 구축하는 데 사용됩니다.</p>
</div>
<div class="section" id="module-distutils.log">
<span id="distutils-log-simple-pep-282-style-logging"></span><h2><span class="section-number">9.18. </span><a class="reference internal" href="#module-distutils.log" title="distutils.log: A simple logging mechanism, :pep:`282`-style"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.log</span></code></a> --- 간단한 <span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a> 스타일 로깅<a class="headerlink" href="#module-distutils.log" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.spawn">
<span id="distutils-spawn-spawn-a-sub-process"></span><h2><span class="section-number">9.19. </span><a class="reference internal" href="#module-distutils.spawn" title="distutils.spawn: Provides the spawn() function"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.spawn</span></code></a> --- 서브 프로세스 스폰<a class="headerlink" href="#module-distutils.spawn" title="제목 주소">¶</a></h2>
<p>이 모듈은 서브 프로세스에서 다른 프로그램을 시작하기 위한 다양한 플랫폼별 함수의 프런트엔드인 <code class="xref py py-func docutils literal notranslate"><span class="pre">spawn()</span></code> 함수를 제공합니다. 또한 주어진 실행 파일 이름을 경로에서 검색하는 <code class="xref py py-func docutils literal notranslate"><span class="pre">find_executable()</span></code>을 제공합니다.</p>
</div>
<div class="section" id="module-distutils.sysconfig">
<span id="distutils-sysconfig-system-configuration-information"></span><h2><span class="section-number">9.20. </span><a class="reference internal" href="#module-distutils.sysconfig" title="distutils.sysconfig: Low-level access to configuration information of the Python interpreter."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.sysconfig</span></code></a> --- 시스템 구성 정보<a class="headerlink" href="#module-distutils.sysconfig" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-distutils.sysconfig" title="distutils.sysconfig: Low-level access to configuration information of the Python interpreter."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.sysconfig</span></code></a> 모듈은 파이썬의 저수준 구성 정보에 대한 액세스를 제공합니다. 사용 가능한 특정 구성 변수는 플랫폼과 구성에 따라 크게 달라집니다. 특정 변수는 실행 중인 파이썬의 특정 버전에 대한 빌드 프로세스에 따라 다릅니다; 변수는 유닉스 시스템에서 파이썬과 함께 설치되는 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>과 구성 헤더에 있는 변수입니다. 구성 헤더는 파이썬 버전 2.2부터 <code class="file docutils literal notranslate"><span class="pre">pyconfig.h</span></code>이고, 이전 버전의 파이썬에서는 <code class="file docutils literal notranslate"><span class="pre">config.h</span></code>입니다.</p>
<p><a class="reference internal" href="../library/distutils.html#module-distutils" title="distutils: Support for building and installing Python modules into an existing Python installation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils</span></code></a> 패키지의 다른 부분에 대해 유용한 조작을 수행하는 몇 가지 추가 함수가 제공됩니다.</p>
<dl class="data">
<dt id="distutils.sysconfig.PREFIX">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">PREFIX</code><a class="headerlink" href="#distutils.sysconfig.PREFIX" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">os.path.normpath(sys.prefix)</span></code>의 결과.</p>
</dd></dl>

<dl class="data">
<dt id="distutils.sysconfig.EXEC_PREFIX">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">EXEC_PREFIX</code><a class="headerlink" href="#distutils.sysconfig.EXEC_PREFIX" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">os.path.normpath(sys.exec_prefix)</span></code>의 결과.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_config_var">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">get_config_var</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.get_config_var" title="정의 주소">¶</a></dt>
<dd><p>단일 변수의 값을 반환합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">get_config_vars().get(name)</span></code>과 동등합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_config_vars">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">get_config_vars</code><span class="sig-paren">(</span><em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.get_config_vars" title="정의 주소">¶</a></dt>
<dd><p>변수 정의 집합을 반환합니다. 인자가 없으면, 구성 변수의 이름을 값에 매핑하는 딕셔너리를 반환합니다. 인자가 제공되면, 해당 인자는 문자열이어야 하며, 반환 값은 관련 값을 제공하는 시퀀스가 됩니다. 주어진 이름에 해당 값이 없으면, 해당 변수에 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 포함됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_config_h_filename">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">get_config_h_filename</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.get_config_h_filename" title="정의 주소">¶</a></dt>
<dd><p>구성 헤더의 전체 경로 이름을 반환합니다. 유닉스의 경우, 이것은 <strong class="program">configure</strong> 스크립트에 의해 생성된 헤더입니다; 다른 플랫폼의 경우 헤더는 파이썬 소스 배포에서 직접 제공됩니다. 이 파일은 플랫폼별 텍스트 파일입니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_makefile_filename">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">get_makefile_filename</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.get_makefile_filename" title="정의 주소">¶</a></dt>
<dd><p>파이썬을 빌드하는 데 사용된 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>의 전체 경로 이름을 반환합니다. 유닉스의 경우, 이것은 <strong class="program">configure</strong> 스크립트에 의해 생성된 파일입니다; 다른 플랫폼의 경우 의미는 다양합니다. 존재한다면, 이 파일은 플랫폼별 텍스트 파일입니다. 이 함수는 POSIX 플랫폼에서만 유용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_python_inc">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">get_python_inc</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">plat_specific</em><span class="optional">[</span>, <em class="sig-param">prefix</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.get_python_inc" title="정의 주소">¶</a></dt>
<dd><p>일반이나 플랫폼 종속 C 인클루드 파일에 대한 디렉터리를 반환합니다. <em>plat_specific</em>이 참이면, 플랫폼 종속 인클루드 디렉터리가 반환됩니다; 거짓이거나 생략되면, 플랫폼 독립적인 디렉터리가 반환됩니다. <em>prefix</em>가 주어지면, <a class="reference internal" href="#distutils.sysconfig.PREFIX" title="distutils.sysconfig.PREFIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">PREFIX</span></code></a> 대신 prefix로 사용되거나, <em>plat_specific</em>이 참이면 <a class="reference internal" href="#distutils.sysconfig.EXEC_PREFIX" title="distutils.sysconfig.EXEC_PREFIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">EXEC_PREFIX</span></code></a> 대신 exec-prefix로 사용됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_python_lib">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">get_python_lib</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">plat_specific</em><span class="optional">[</span>, <em class="sig-param">standard_lib</em><span class="optional">[</span>, <em class="sig-param">prefix</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.get_python_lib" title="정의 주소">¶</a></dt>
<dd><p>일반이나 플랫폼 종속 라이브러리 설치를 위한 디렉터리를 반환합니다. <em>plat_specific</em>이 참이면, 플랫폼 종속 라이브러리 디렉터리가 반환됩니다; 거짓이거나 생략되면, 플랫폼 독립적인 디렉터리가 반환됩니다. <em>prefix</em>가 주어지면, <a class="reference internal" href="#distutils.sysconfig.PREFIX" title="distutils.sysconfig.PREFIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">PREFIX</span></code></a> 대신 prefix로 사용되거나, <em>plat_specific</em>이 참이면 <a class="reference internal" href="#distutils.sysconfig.EXEC_PREFIX" title="distutils.sysconfig.EXEC_PREFIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">EXEC_PREFIX</span></code></a> 대신 exec-prefix로 사용됩니다. <em>standard_lib</em>가 참이면, 제삼자 확장을 설치하기 위한 디렉터리가 아니라 표준 라이브러리의 디렉터리가 반환됩니다.</p>
</dd></dl>

<p>다음 함수는 <a class="reference internal" href="../library/distutils.html#module-distutils" title="distutils: Support for building and installing Python modules into an existing Python installation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils</span></code></a> 패키지 내에서만 사용하려는 것입니다.</p>
<dl class="function">
<dt id="distutils.sysconfig.customize_compiler">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">customize_compiler</code><span class="sig-paren">(</span><em class="sig-param">compiler</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.customize_compiler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.ccompiler.CCompiler</span></code></a> 인스턴스의 모든 플랫폼별 사용자 정의를 수행합니다.</p>
<p>이 함수는 현재 유닉스에서만 필요하지만, 미래 호환성을 지원하기 위해 일관되게 호출되어야 합니다. 유닉스 버전에 따라 다른 정보를 삽입하고 파이썬의 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>에 저장됩니다. 이 정보에는 선택한 컴파일러, 컴파일러와 링커 옵션, 링커에서 공유 객체에 사용하는 확장이 포함됩니다.</p>
</dd></dl>

<p>이 함수는 훨씬 더 특수한 용도이며, 파이썬 자체 빌드 절차에서만 사용해야 합니다.</p>
<dl class="function">
<dt id="distutils.sysconfig.set_python_build">
<code class="sig-prename descclassname">distutils.sysconfig.</code><code class="sig-name descname">set_python_build</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.sysconfig.set_python_build" title="정의 주소">¶</a></dt>
<dd><p>파이썬을 위한 빌드 프로세스의 일부로 사용되고 있음을 <a class="reference internal" href="#module-distutils.sysconfig" title="distutils.sysconfig: Low-level access to configuration information of the Python interpreter."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.sysconfig</span></code></a> 모듈에 알립니다. 이렇게 하면 파일의 상대적 위치가 많이 변경되어, 설치된 파이썬이 아닌 빌드 영역에 위치 할 수 있도록 합니다.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.text_file">
<span id="distutils-text-file-the-textfile-class"></span><h2><span class="section-number">9.21. </span><a class="reference internal" href="#module-distutils.text_file" title="distutils.text_file: Provides the TextFile class, a simple interface to text files"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.text_file</span></code></a> --- TextFile 클래스<a class="headerlink" href="#module-distutils.text_file" title="제목 주소">¶</a></h2>
<p>이 모듈은 <a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextFile</span></code></a> 클래스를 제공합니다. 이 클래스는 (선택적으로) 주석 제거, 빈 줄 무시 및 역 슬래시 된 줄의 결합을 처리하는 텍스트 파일에 대한 인터페이스를 제공합니다.</p>
<dl class="class">
<dt id="distutils.text_file.TextFile">
<em class="property">class </em><code class="sig-prename descclassname">distutils.text_file.</code><code class="sig-name descname">TextFile</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">filename=None</em>, <em class="sig-param">file=None</em>, <em class="sig-param">**options</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 줄 단위 문법을 갖는 텍스트 파일을 처리할 때 일반적으로 수행하려는 모든 작업을 처리하는 파일류 객체를 제공합니다: 주석 제거 (<code class="docutils literal notranslate"><span class="pre">#</span></code>가 주석 문자라면), 빈 줄 무시, 줄 바꿈을 이스케이프 한 인접 줄을 연결하기 (즉, 줄 끝의 역 슬래시), 선행 및/또는 후행 공백 제거. 이들 모두는 선택적이고 독립적으로 제어할 수 있습니다.</p>
<p>이 클래스는 <a class="reference internal" href="#distutils.text_file.TextFile.warn" title="distutils.text_file.TextFile.warn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warn()</span></code></a> 메서드를 제공해서 문제의 논리적 줄이 여러 물리적 줄에 걸쳐있는 경우에도 물리적 줄 번호를 보고하는 경고 메시지를 생성할 수 있습니다. 또한 한 번에 한 줄씩 미리 보기를 구현하기 위한 <a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unreadline()</span></code></a>을 제공합니다.</p>
<p><a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextFile</span></code></a> 인스턴스는 <em>filename</em>, <em>file</em> 또는 둘 모두로 만들어집니다. 둘 다 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다. <em>filename</em>은 문자열이어야 하며, <em>file</em>은 파일 객체(또는 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>과 <a class="reference internal" href="#distutils.text_file.TextFile.close" title="distutils.text_file.TextFile.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드를 제공하는 것)여야 합니다. <a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextFile</span></code></a>이 경고 메시지에 포함할 수 있도록, 최소한 <em>filename</em>을 제공하는 것이 좋습니다. <em>file</em>이 제공되지 않으면, <a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextFile</span></code></a>은 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 내장 함수를 사용하여 스스로 만듭니다.</p>
<p>옵션은 모두 불리언이며, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>이 반환하는 값에 영향을 줍니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 54%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>옵션 이름</p></th>
<th class="head"><p>설명</p></th>
<th class="head"><p>기본값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>strip_comments</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'#'</span></code>에서 줄 끝까지 제거할 뿐만 아니라, <code class="docutils literal notranslate"><span class="pre">'#'</span></code> 앞까지 이어지는 모든 공백을 제거합니다 --- 역 슬래시로 이스케이프 되지 않는 한</p></td>
<td><p>참</p></td>
</tr>
<tr class="row-odd"><td><p><em>lstrip_ws</em></p></td>
<td><p>반환하기 전에 각 줄에서 선행 공백을 제거합니다</p></td>
<td><p>거짓</p></td>
</tr>
<tr class="row-even"><td><p><em>rstrip_ws</em></p></td>
<td><p>반환하기 전에 각 줄에서 후행 공백(줄 종결자 포함!)을 제거합니다.</p></td>
<td><p>참</p></td>
</tr>
<tr class="row-odd"><td><p><em>skip_blanks</em></p></td>
<td><p>주석과 공백을 제거한 *후에* 빈 줄을 건너뜁니다. (lstrip_ws와 rstrip_ws가 모두 거짓이면, 일부 행은 공백으로만 구성될 수 있습니다: 이것은 <em>skip_blanks</em>가 참인 경우에도 건너뛰지 *않습니다*.)</p></td>
<td><p>참</p></td>
</tr>
<tr class="row-even"><td><p><em>join_lines</em></p></td>
<td><p>주석과 공백을 제거한 후 역 슬래시가 줄 넘김이 아닌 줄의 마지막 문자이면, 다음 줄을 결합하여 하나의 논리적 줄을 만듭니다; N개의 연속된 줄이 역 슬래시로 끝나면, N+1개의 물리적 줄이 결합하여 하나의 논리적 줄을 형성합니다.</p></td>
<td><p>거짓</p></td>
</tr>
<tr class="row-odd"><td><p><em>collapse_join</em></p></td>
<td><p>앞줄에 연결된 줄에서 선행 공백을 제거합니다; <code class="docutils literal notranslate"><span class="pre">(join_lines</span> <span class="pre">and</span> <span class="pre">not</span> <span class="pre">lstrip_ws)</span></code>일 때만 중요합니다</p></td>
<td><p>거짓</p></td>
</tr>
</tbody>
</table>
<p><em>rstrip_ws</em>는 후행 줄 바꿈을 제거할 수 있어서, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>의 의미는 내장 파일 객체의 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 메서드와 달라야 함에 유의하십시오! 특히, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>은 파일 끝에 대해 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다: <em>rstrip_ws</em>가 참이지만 <em>skip_blanks</em>가 거짓이면, 빈 문자열은 단지 빈 줄(또는 모두 공백인 줄)일 수 있습니다.</p>
<dl class="method">
<dt id="distutils.text_file.TextFile.open">
<code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile.open" title="정의 주소">¶</a></dt>
<dd><p>새 파일 <em>filename</em>을 엽니다. 이것은 <em>file</em>이나 <em>filename</em> 생성자 인자를 재정의합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile.close" title="정의 주소">¶</a></dt>
<dd><p>현재 파일을 닫고 (파일명과 현재 줄 번호를 포함하여) 그것에 대해 알고 있는 모든 것을 잊어버립니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.warn">
<code class="sig-name descname">warn</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="optional">[</span>, <em class="sig-param">line=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile.warn" title="정의 주소">¶</a></dt>
<dd><p>현재 파일의 현재 논리적 줄에 연결된 경고 메시지를 (stderr로) 인쇄합니다. 파일의 현재 논리적 줄이 여러 물리적 줄에 걸쳐있으면, 경고는 전체 범위를 나타냅니다, 가령 <code class="docutils literal notranslate"><span class="pre">&quot;lines</span> <span class="pre">3-5&quot;</span></code>. <em>line</em>이 제공되면, 현재 줄 번호를 대체합니다; 물리적 줄의 범위를 나타내는 리스트나 튜플이거나, 단일 물리적 줄을 나타내는 정수일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.readline">
<code class="sig-name descname">readline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile.readline" title="정의 주소">¶</a></dt>
<dd><p>현재 파일에서 단일 논리적 줄을 읽고 반환합니다 (또는 줄이 이전에 <a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unreadline()</span></code></a>으로 &quot;되돌린&quot; 경우 내부 버퍼에서). <em>join_lines</em> 옵션이 참이면, 여러 물리적 줄을 단일 문자열로 이어붙인 줄을 읽는 것이 수반될 수 있습니다. 현재 줄 번호를 갱신해서, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 후에 <a class="reference internal" href="#distutils.text_file.TextFile.warn" title="distutils.text_file.TextFile.warn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warn()</span></code></a>을 호출하면 방금 읽은 물리적 줄에 대한 경고가 표시됩니다. <em>rstrip_ws</em>가 참이지만 <em>strip_blanks</em>가 거짓이면 빈 문자열이 발생할 수 있어서, 파일 끝에서는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.readlines">
<code class="sig-name descname">readlines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile.readlines" title="정의 주소">¶</a></dt>
<dd><p>현재 파일에 남아있는 모든 논리적 줄의 리스트를 읽고 반환합니다. 이렇게 하면 현재 줄 번호가 파일의 마지막 줄로 갱신됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.unreadline">
<code class="sig-name descname">unreadline</code><span class="sig-paren">(</span><em class="sig-param">line</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.text_file.TextFile.unreadline" title="정의 주소">¶</a></dt>
<dd><p><em>line</em>(문자열)을 향후 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 호출에서 확인할 내부 버퍼로 푸시합니다. 한 번에 한 줄씩 미리 보기가 있는 구문 분석기를 구현하는 데 편리합니다. <a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unreadline()</span></code></a>으로 &quot;되돌린&quot; 줄은 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>으로 읽을 때 이후에 다시 정리(공백 제거 등)되지 않음에 유의하십시오. <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>을 호출하기 전에 <a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unreadline()</span></code></a>을 여러 번 호출하면, 가장 최근의 것이 첫 번째로 오는 순서로 줄이 반환됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-distutils.version">
<span id="distutils-version-version-number-classes"></span><h2><span class="section-number">9.22. </span><a class="reference internal" href="#module-distutils.version" title="distutils.version: Implements classes that represent module version numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.version</span></code></a> --- 버전 번호 클래스<a class="headerlink" href="#module-distutils.version" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.cmd">
<span id="distutils-cmd-abstract-base-class-for-distutils-commands"></span><h2><span class="section-number">9.23. </span><a class="reference internal" href="#module-distutils.cmd" title="distutils.cmd: Provides the abstract base class :class:`~distutils.cmd.Command`. This class is subclassed by the modules in the distutils.command subpackage."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.cmd</span></code></a> --- Distutils 명령을 위한 추상 베이스 클래스<a class="headerlink" href="#module-distutils.cmd" title="제목 주소">¶</a></h2>
<p>이 모듈은 추상 베이스 클래스 <a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code></a>를 제공합니다.</p>
<dl class="class">
<dt id="distutils.cmd.Command">
<em class="property">class </em><code class="sig-prename descclassname">distutils.cmd.</code><code class="sig-name descname">Command</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="headerlink" href="#distutils.cmd.Command" title="정의 주소">¶</a></dt>
<dd><p>Distutils의 &quot;일벌&quot;인 명령 클래스를 정의하기 위한 추상 베이스 클래스. 명령 클래스에 대한 유용한 비유는 <em>options</em>라는 로컬 변수가 있는 서브 루틴으로 생각하는 것입니다. 옵션은 <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize_options()</span></code></a>에서 선언되고 <a class="reference internal" href="#distutils.cmd.Command.finalize_options" title="distutils.cmd.Command.finalize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finalize_options()</span></code></a>에서 정의됩니다 (최종값 제공). 두 메서드 모두 모든 명령 클래스에서 정의해야 합니다. 옵션값은 외부 세계(명령 줄, 구성 파일, ...)에서 올 수 있고, 다른 옵션에 종속된 모든 옵션은 이러한 외부 영향이 처리된 후에 계산되어야 해서 --- 그래서 <a class="reference internal" href="#distutils.cmd.Command.finalize_options" title="distutils.cmd.Command.finalize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finalize_options()</span></code></a>, 둘 사이의 구분이 필요합니다. 옵션값을 기반으로 모든 작업을 수행하는 서브 루틴의 본문은 <a class="reference internal" href="#distutils.cmd.Command.run" title="distutils.cmd.Command.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 메서드이며, 역시 모든 명령 클래스에서 구현해야 합니다.</p>
<p>클래스 생성자는 <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></a> 인스턴스인 단일 인자 <em>dist</em>를 취합니다.</p>
</dd></dl>

</div>
<div class="section" id="creating-a-new-distutils-command">
<h2><span class="section-number">9.24. </span>새 Distutils 명령 만들기<a class="headerlink" href="#creating-a-new-distutils-command" title="제목 주소">¶</a></h2>
<p>이 섹션에서는 새 Distutils 명령을 만드는 단계를 간략하게 설명합니다.</p>
<p>새로운 명령은 <a class="reference internal" href="#module-distutils.command" title="distutils.command: Contains one module for each standard Distutils command."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command</span></code></a> 패키지의 모듈에 있습니다. 해당 디렉터리에 <code class="file docutils literal notranslate"><span class="pre">command_template</span></code>라는 샘플 템플릿이 있습니다. 구현 중인 새 명령과 이름이 같은 새 모듈에 이 파일을 복사하십시오. 이 모듈은 모듈(및 명령)과 같은 이름의 클래스를 구현해야 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">peel_banana</span></code> 명령을 만들려면 (사용자가 <code class="docutils literal notranslate"><span class="pre">setup.py</span> <span class="pre">peel_banana</span></code>를 실행할 수 있도록), <code class="file docutils literal notranslate"><span class="pre">command_template</span></code>를 <code class="file docutils literal notranslate"><span class="pre">distutils/command/peel_banana.py</span></code>에 복사한 다음, <a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.cmd.Command</span></code></a>의 서브 클래스인 <code class="xref py py-class docutils literal notranslate"><span class="pre">peel_banana</span></code> 클래스를 구현하도록 편집합니다.</p>
<p><a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code></a>의 서브 클래스는 다음 메서드를 정의해야 합니다.</p>
<dl class="method">
<dt id="distutils.cmd.Command.initialize_options">
<code class="sig-prename descclassname">Command.</code><code class="sig-name descname">initialize_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.cmd.Command.initialize_options" title="정의 주소">¶</a></dt>
<dd><p>이 명령이 지원하는 모든 옵션의 기본값을 설정합니다. 이러한 기본값은 다른 명령, 설정 스크립트, 구성 파일 또는 명령 줄에 의해 재정의될 수 있습니다. 따라서, 이것은 옵션 간의 종속성을 코딩하는 곳이 아닙니다; 일반적으로 <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize_options()</span></code></a> 구현은 한 무더기의 <code class="docutils literal notranslate"><span class="pre">self.foo</span> <span class="pre">=</span> <span class="pre">None</span></code> 대입일 뿐입니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.cmd.Command.finalize_options">
<code class="sig-prename descclassname">Command.</code><code class="sig-name descname">finalize_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.cmd.Command.finalize_options" title="정의 주소">¶</a></dt>
<dd><p>이 명령이 지원하는 모든 옵션에 대한 최종값을 설정합니다. 이것은 항상 가능한 한 늦게 호출됩니다, 즉, 명령 줄이나 다른 명령에서 모든 옵션 대입이 완료된 후에. 따라서, 이것이 옵션 종속성을 코딩하는 장소입니다: <em>foo</em>가 <em>bar</em>에 의존하면, <em>foo</em>가 <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize_options()</span></code></a>에서 대입된 것과 같은 값을 여전히 가지고 있는 한 <em>foo</em>를 <em>bar</em>에서 설정하는 것이 안전합니다.</p>
</dd></dl>

<dl class="method">
<dt id="distutils.cmd.Command.run">
<code class="sig-prename descclassname">Command.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distutils.cmd.Command.run" title="정의 주소">¶</a></dt>
<dd><p>명령의 존재 이유: 수행하기 위해 존재하는 작업을 수행하고, <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize_options()</span></code></a>에서 초기화되고, 다른 명령, 설정 스크립트, 명령 줄 및 구성 파일로 사용자 정의되고, <a class="reference internal" href="#distutils.cmd.Command.finalize_options" title="distutils.cmd.Command.finalize_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finalize_options()</span></code></a>에서 마무리된 옵션으로 제어됩니다. 모든 터미널 출력과 파일 시스템 상호 작용은 <a class="reference internal" href="#distutils.cmd.Command.run" title="distutils.cmd.Command.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>에서 수행해야 합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="distutils.cmd.Command.sub_commands">
<code class="sig-prename descclassname">Command.</code><code class="sig-name descname">sub_commands</code><a class="headerlink" href="#distutils.cmd.Command.sub_commands" title="정의 주소">¶</a></dt>
<dd><p><em>sub_commands</em>는 명령의 &quot;패밀리&quot; 개념을 형식화합니다, 예를 들어, 하위 명령 <code class="docutils literal notranslate"><span class="pre">install_lib</span></code>, <code class="docutils literal notranslate"><span class="pre">install_headers</span></code> 등이 있는 부모로서의 <code class="docutils literal notranslate"><span class="pre">install</span></code>. 명령 패밀리의 부모는 <em>sub_commands</em>를 클래스 어트리뷰트로 정의합니다; 2-튜플 <code class="docutils literal notranslate"><span class="pre">(command_name,</span> <span class="pre">predicate)</span></code>의 리스트인데, <em>command_name</em>은 문자열이고 <em>predicate</em>는 함수, 문자열 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. <em>predicate</em>는 해당 명령이 현재 상황에서 적용 가능한지를 결정하는 상위 명령의 메서드입니다. (예를 들어 <code class="docutils literal notranslate"><span class="pre">install_headers</span></code>는 설치할 C 헤더 파일이 있을 때만 적용됩니다.) <em>predicate</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 해당 명령은 항상 적용 가능합니다.</p>
<p><em>sub_commands</em>는 일반적으로 클래스의 <em>끝</em>에서 정의됩니다, predicate는 클래스의 메서드일 수 있는데, 이때는 이미 정의되어 있어야 하기 때문입니다. 규범적 예는 <strong class="command">install</strong> 명령입니다.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.command">
<span id="distutils-command-individual-distutils-commands"></span><h2><span class="section-number">9.25. </span><a class="reference internal" href="#module-distutils.command" title="distutils.command: Contains one module for each standard Distutils command."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command</span></code></a> --- 개별 Distutils 명령<a class="headerlink" href="#module-distutils.command" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist">
<span id="distutils-command-bdist-build-a-binary-installer"></span><h2><span class="section-number">9.26. </span><a class="reference internal" href="#module-distutils.command.bdist" title="distutils.command.bdist: Build a binary installer for a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist</span></code></a> --- 바이너리 설치 프로그램 빌드<a class="headerlink" href="#module-distutils.command.bdist" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_packager">
<span id="distutils-command-bdist-packager-abstract-base-class-for-packagers"></span><h2><span class="section-number">9.27. </span><a class="reference internal" href="#module-distutils.command.bdist_packager" title="distutils.command.bdist_packager: Abstract base class for packagers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_packager</span></code></a> --- 패키저를 위한 추상 베이스 클래스<a class="headerlink" href="#module-distutils.command.bdist_packager" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_dumb">
<span id="distutils-command-bdist-dumb-build-a-dumb-installer"></span><h2><span class="section-number">9.28. </span><a class="reference internal" href="#module-distutils.command.bdist_dumb" title="distutils.command.bdist_dumb: Build a &quot;dumb&quot; installer - a simple archive of files"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_dumb</span></code></a> --- &quot;dumb&quot; 설치 프로그램 빌드<a class="headerlink" href="#module-distutils.command.bdist_dumb" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_msi">
<span id="distutils-command-bdist-msi-build-a-microsoft-installer-binary-package"></span><h2><span class="section-number">9.29. </span><a class="reference internal" href="#module-distutils.command.bdist_msi" title="distutils.command.bdist_msi: Build a binary distribution as a Windows MSI file"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_msi</span></code></a> --- Microsoft 설치 프로그램 바이너리 패키지 빌드<a class="headerlink" href="#module-distutils.command.bdist_msi" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="distutils.command.bdist_msi.bdist_msi">
<em class="property">class </em><code class="sig-prename descclassname">distutils.command.bdist_msi.</code><code class="sig-name descname">bdist_msi</code><a class="headerlink" href="#distutils.command.bdist_msi.bdist_msi" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span>대신 bdist_wheel(휠 패키지)을 사용하십시오.</p>
<p><a class="reference external" href="https://msdn.microsoft.com/en-us/library/cc185688(VS.85).aspx">Windows Installer</a> (.msi) 바이너리 패키지를 빌드합니다.</p>
<p>대부분의 경우, <code class="docutils literal notranslate"><span class="pre">bdist_msi</span></code> 설치 프로그램은 Win64 플랫폼에 대한 더 나은 지원을 제공하고, 관리자가 비대화 형 설치를 수행할 수 있도록 하며, 그룹 정책을 통한 설치를 허용하기 때문에 <code class="docutils literal notranslate"><span class="pre">bdist_wininst</span></code> 설치 프로그램보다 더 나은 선택입니다.</p>
</div>
</div>
<div class="section" id="module-distutils.command.bdist_rpm">
<span id="distutils-command-bdist-rpm-build-a-binary-distribution-as-a-redhat-rpm-and-srpm"></span><h2><span class="section-number">9.30. </span><a class="reference internal" href="#module-distutils.command.bdist_rpm" title="distutils.command.bdist_rpm: Build a binary distribution as a Redhat RPM and SRPM"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_rpm</span></code></a> --- Redhat RPM과 SRPM으로 바이너리 배포판 구축<a class="headerlink" href="#module-distutils.command.bdist_rpm" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_wininst">
<span id="distutils-command-bdist-wininst-build-a-windows-installer"></span><h2><span class="section-number">9.31. </span><a class="reference internal" href="#module-distutils.command.bdist_wininst" title="distutils.command.bdist_wininst: Build a Windows installer"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_wininst</span></code></a> --- 윈도우 설치 프로그램 빌드<a class="headerlink" href="#module-distutils.command.bdist_wininst" title="제목 주소">¶</a></h2>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span>대신 bdist_wheel(휠 패키지)을 사용하십시오.</p>
</div>
</div>
<div class="section" id="module-distutils.command.sdist">
<span id="distutils-command-sdist-build-a-source-distribution"></span><h2><span class="section-number">9.32. </span><a class="reference internal" href="#module-distutils.command.sdist" title="distutils.command.sdist: Build a source distribution"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.sdist</span></code></a> --- 소스 배포판 빌드<a class="headerlink" href="#module-distutils.command.sdist" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build">
<span id="distutils-command-build-build-all-files-of-a-package"></span><h2><span class="section-number">9.33. </span><a class="reference internal" href="#module-distutils.command.build" title="distutils.command.build: Build all files of a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build</span></code></a> --- 패키지의 모든 파일 빌드<a class="headerlink" href="#module-distutils.command.build" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_clib">
<span id="distutils-command-build-clib-build-any-c-libraries-in-a-package"></span><h2><span class="section-number">9.34. </span><a class="reference internal" href="#module-distutils.command.build_clib" title="distutils.command.build_clib: Build any C libraries in a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_clib</span></code></a> --- 패키지의 모든 C 라이브러리 빌드<a class="headerlink" href="#module-distutils.command.build_clib" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_ext">
<span id="distutils-command-build-ext-build-any-extensions-in-a-package"></span><h2><span class="section-number">9.35. </span><a class="reference internal" href="#module-distutils.command.build_ext" title="distutils.command.build_ext: Build any extensions in a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_ext</span></code></a> --- 패키지의 모든 확장 빌드<a class="headerlink" href="#module-distutils.command.build_ext" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_py">
<span id="distutils-command-build-py-build-the-py-pyc-files-of-a-package"></span><h2><span class="section-number">9.36. </span><a class="reference internal" href="#module-distutils.command.build_py" title="distutils.command.build_py: Build the .py/.pyc files of a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_py</span></code></a> --- 패키지의 .py/.pyc 파일 빌드<a class="headerlink" href="#module-distutils.command.build_py" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="distutils.command.build_py.build_py">
<em class="property">class </em><code class="sig-prename descclassname">distutils.command.build_py.</code><code class="sig-name descname">build_py</code><a class="headerlink" href="#distutils.command.build_py.build_py" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="distutils.command.build_py.build_py_2to3">
<em class="property">class </em><code class="sig-prename descclassname">distutils.command.build_py.</code><code class="sig-name descname">build_py_2to3</code><a class="headerlink" href="#distutils.command.build_py.build_py_2to3" title="정의 주소">¶</a></dt>
<dd><p>설치할 각 .py 파일에 대해 2to3 변환 라이브러리를 실행하는 build_py의 대체 구현입니다. 파이썬 2.x와 3.x 모두에서 실행되도록 설계된 배포판의 setup.py 파일에서 이를 사용하려면, 여러분의 setup.py 에 다음을 추가하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">distutils.command.build_py</span> <span class="k">import</span> <span class="n">build_py_2to3</span> <span class="k">as</span> <span class="n">build_py</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">distutils.command.build_py</span> <span class="k">import</span> <span class="n">build_py</span>
</pre></div>
</div>
<p>그리고 나중에:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cmdclass</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;build_py&#39;</span><span class="p">:</span> <span class="n">build_py</span><span class="p">}</span>
</pre></div>
</div>
<p>를 setup() 호출에 추가하십시오.</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.command.build_scripts">
<span id="distutils-command-build-scripts-build-the-scripts-of-a-package"></span><h2><span class="section-number">9.37. </span><a class="reference internal" href="#module-distutils.command.build_scripts" title="distutils.command.build_scripts: Build the scripts of a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_scripts</span></code></a> --- 패키지의 스크립트 빌드<a class="headerlink" href="#module-distutils.command.build_scripts" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.clean">
<span id="distutils-command-clean-clean-a-package-build-area"></span><h2><span class="section-number">9.38. </span><a class="reference internal" href="#module-distutils.command.clean" title="distutils.command.clean: Clean a package build area"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.clean</span></code></a> --- 패키지 빌드 영역 정리<a class="headerlink" href="#module-distutils.command.clean" title="제목 주소">¶</a></h2>
<p>이 명령은 중간 컴파일된 오브젝트 파일과 같이 <strong class="command">build</strong>와 하위 명령에 의해 만들어진 임시 파일들을 제거합니다. <code class="docutils literal notranslate"><span class="pre">--all</span></code> 옵션을 사용하면, 전체 빌드 디렉터리가 제거됩니다.</p>
<p><a class="reference internal" href="configfile.html#distutils-build-ext-inplace"><span class="std std-ref">제자리에서</span></a> 빌드된 확장 모듈은 빌드 디렉터리에 없기 때문에 정리되지 않습니다.</p>
</div>
<div class="section" id="module-distutils.command.config">
<span id="distutils-command-config-perform-package-configuration"></span><h2><span class="section-number">9.39. </span><a class="reference internal" href="#module-distutils.command.config" title="distutils.command.config: Perform package configuration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.config</span></code></a> --- 패키지 구성 수행<a class="headerlink" href="#module-distutils.command.config" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install">
<span id="distutils-command-install-install-a-package"></span><h2><span class="section-number">9.40. </span><a class="reference internal" href="#module-distutils.command.install" title="distutils.command.install: Install a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install</span></code></a> --- 패키지 설치<a class="headerlink" href="#module-distutils.command.install" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_data">
<span id="distutils-command-install-data-install-data-files-from-a-package"></span><h2><span class="section-number">9.41. </span><a class="reference internal" href="#module-distutils.command.install_data" title="distutils.command.install_data: Install data files from a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_data</span></code></a> --- 패키지에서 데이터 파일 설치<a class="headerlink" href="#module-distutils.command.install_data" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_headers">
<span id="distutils-command-install-headers-install-c-c-header-files-from-a-package"></span><h2><span class="section-number">9.42. </span><a class="reference internal" href="#module-distutils.command.install_headers" title="distutils.command.install_headers: Install C/C++ header files from a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_headers</span></code></a> --- 패키지에서 C/C++ 헤더 파일 설치<a class="headerlink" href="#module-distutils.command.install_headers" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_lib">
<span id="distutils-command-install-lib-install-library-files-from-a-package"></span><h2><span class="section-number">9.43. </span><a class="reference internal" href="#module-distutils.command.install_lib" title="distutils.command.install_lib: Install library files from a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_lib</span></code></a> --- 패키지에서 라이브러리 파일 설치<a class="headerlink" href="#module-distutils.command.install_lib" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_scripts">
<span id="distutils-command-install-scripts-install-script-files-from-a-package"></span><h2><span class="section-number">9.44. </span><a class="reference internal" href="#module-distutils.command.install_scripts" title="distutils.command.install_scripts: Install script files from a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_scripts</span></code></a> --- 패키지에서 스크립트 파일 설치<a class="headerlink" href="#module-distutils.command.install_scripts" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.register">
<span id="distutils-command-register-register-a-module-with-the-python-package-index"></span><h2><span class="section-number">9.45. </span><a class="reference internal" href="#module-distutils.command.register" title="distutils.command.register: Register a module with the Python Package Index"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.register</span></code></a> --- 파이썬 패키지 색인에 모듈 등록<a class="headerlink" href="#module-distutils.command.register" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">register</span></code> 명령은 패키지를 파이썬 패키지 색인에 등록합니다. 이것은 <span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0301"><strong>PEP 301</strong></a>에 더 자세히 설명되어 있습니다.</p>
</div>
<div class="section" id="module-distutils.command.check">
<span id="distutils-command-check-check-the-meta-data-of-a-package"></span><h2><span class="section-number">9.46. </span><a class="reference internal" href="#module-distutils.command.check" title="distutils.command.check: Check the meta-data of a package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.check</span></code></a> --- 패키지의 메타 데이터 확인<a class="headerlink" href="#module-distutils.command.check" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">check</span></code> 명령은 패키지의 메타 데이터에 대해 몇 가지 테스트를 수행합니다. 예를 들어, 모든 필수 메타 데이터가 <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 함수에 전달된 인자로 제공되는지 확인합니다.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. API 레퍼런스</a><ul>
<li><a class="reference internal" href="#module-distutils.core">9.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.core</span></code> --- 핵심 Distutils 기능</a></li>
<li><a class="reference internal" href="#module-distutils.ccompiler">9.2. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.ccompiler</span></code> --- CCompiler 베이스 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.unixccompiler">9.3. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.unixccompiler</span></code> --- 유닉스 C 컴파일러</a></li>
<li><a class="reference internal" href="#module-distutils.msvccompiler">9.4. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.msvccompiler</span></code> --- Microsoft 컴파일러</a></li>
<li><a class="reference internal" href="#module-distutils.bcppcompiler">9.5. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.bcppcompiler</span></code> --- Borland 컴파일러</a></li>
<li><a class="reference internal" href="#module-distutils.cygwinccompiler">9.6. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.cygwincompiler</span></code> --- Cygwin 컴파일러</a></li>
<li><a class="reference internal" href="#module-distutils.archive_util">9.7. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.archive_util</span></code> --- 아카이브 유틸리티</a></li>
<li><a class="reference internal" href="#module-distutils.dep_util">9.8. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dep_util</span></code> --- 종속성 검사</a></li>
<li><a class="reference internal" href="#module-distutils.dir_util">9.9. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dir_util</span></code> --- 디렉터리 트리 연산</a></li>
<li><a class="reference internal" href="#module-distutils.file_util">9.10. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.file_util</span></code> --- 단일 파일 연산</a></li>
<li><a class="reference internal" href="#module-distutils.util">9.11. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.util</span></code> --- 기타 유틸리티 함수</a></li>
<li><a class="reference internal" href="#module-distutils.dist">9.12. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.dist</span></code> --- Distribution 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.extension">9.13. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.extension</span></code> --- Extension 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.debug">9.14. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.debug</span></code> --- Distutils 디버그 모드</a></li>
<li><a class="reference internal" href="#module-distutils.errors">9.15. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.errors</span></code> --- Distutils 예외</a></li>
<li><a class="reference internal" href="#module-distutils.fancy_getopt">9.16. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.fancy_getopt</span></code> --- 표준 getopt 모듈을 감싸는 래퍼</a></li>
<li><a class="reference internal" href="#module-distutils.filelist">9.17. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.filelist</span></code> --- FileList 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.log">9.18. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.log</span></code> --- 간단한 <strong>PEP 282</strong> 스타일 로깅</a></li>
<li><a class="reference internal" href="#module-distutils.spawn">9.19. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.spawn</span></code> --- 서브 프로세스 스폰</a></li>
<li><a class="reference internal" href="#module-distutils.sysconfig">9.20. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.sysconfig</span></code> --- 시스템 구성 정보</a></li>
<li><a class="reference internal" href="#module-distutils.text_file">9.21. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.text_file</span></code> --- TextFile 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.version">9.22. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.version</span></code> --- 버전 번호 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.cmd">9.23. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.cmd</span></code> --- Distutils 명령을 위한 추상 베이스 클래스</a></li>
<li><a class="reference internal" href="#creating-a-new-distutils-command">9.24. 새 Distutils 명령 만들기</a></li>
<li><a class="reference internal" href="#module-distutils.command">9.25. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command</span></code> --- 개별 Distutils 명령</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist">9.26. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist</span></code> --- 바이너리 설치 프로그램 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_packager">9.27. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_packager</span></code> --- 패키저를 위한 추상 베이스 클래스</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_dumb">9.28. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_dumb</span></code> --- &quot;dumb&quot; 설치 프로그램 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_msi">9.29. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_msi</span></code> --- Microsoft 설치 프로그램 바이너리 패키지 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_rpm">9.30. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_rpm</span></code> --- Redhat RPM과 SRPM으로 바이너리 배포판 구축</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_wininst">9.31. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.bdist_wininst</span></code> --- 윈도우 설치 프로그램 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.sdist">9.32. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.sdist</span></code> --- 소스 배포판 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.build">9.33. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build</span></code> --- 패키지의 모든 파일 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_clib">9.34. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_clib</span></code> --- 패키지의 모든 C 라이브러리 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_ext">9.35. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_ext</span></code> --- 패키지의 모든 확장 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_py">9.36. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_py</span></code> --- 패키지의 .py/.pyc 파일 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_scripts">9.37. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.build_scripts</span></code> --- 패키지의 스크립트 빌드</a></li>
<li><a class="reference internal" href="#module-distutils.command.clean">9.38. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.clean</span></code> --- 패키지 빌드 영역 정리</a></li>
<li><a class="reference internal" href="#module-distutils.command.config">9.39. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.config</span></code> --- 패키지 구성 수행</a></li>
<li><a class="reference internal" href="#module-distutils.command.install">9.40. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install</span></code> --- 패키지 설치</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_data">9.41. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_data</span></code> --- 패키지에서 데이터 파일 설치</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_headers">9.42. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_headers</span></code> --- 패키지에서 C/C++ 헤더 파일 설치</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_lib">9.43. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_lib</span></code> --- 패키지에서 라이브러리 파일 설치</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_scripts">9.44. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.install_scripts</span></code> --- 패키지에서 스크립트 파일 설치</a></li>
<li><a class="reference internal" href="#module-distutils.command.register">9.45. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.register</span></code> --- 파이썬 패키지 색인에 모듈 등록</a></li>
<li><a class="reference internal" href="#module-distutils.command.check">9.46. <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils.command.check</span></code> --- 패키지의 메타 데이터 확인</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="commandref.html"
                        title="이전 장"><span class="section-number">8. </span>명령 레퍼런스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="../install/index.html"
                        title="다음 장">파이썬 모듈 설치 (레거시 버전)</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="../install/index.html" title="파이썬 모듈 설치 (레거시 버전)"
             >다음</a> |</li>
        <li class="right" >
          <a href="commandref.html" title="8. 명령 레퍼런스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 모듈 배포 (레거시 버전)</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>