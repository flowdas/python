
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>정규식 HOWTO &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="소켓 프로그래밍 HOWTO" href="sockets.html" />
    <link rel="prev" title="로깅 요리책" href="logging-cookbook.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/howto/regex.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="소켓 프로그래밍 HOWTO"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="로깅 요리책"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="regular-expression-howto">
<span id="regex-howto"></span><h1>정규식 HOWTO<a class="headerlink" href="#regular-expression-howto" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">저자</dt>
<dd class="field-odd"><p>A.M. Kuchling &lt;<a class="reference external" href="mailto:amk&#37;&#52;&#48;amk&#46;ca">amk<span>&#64;</span>amk<span>&#46;</span>ca</a>&gt;</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title first">요약</p>
<p>이 설명서는 파이썬에서 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈로 정규식을 사용하는 방법을 소개하는 입문서입니다. 라이브러리 레퍼런스의 해당 절보다 더 부드러운 소개를 제공합니다.</p>
</div>
<div class="section" id="introduction">
<h2>소개<a class="headerlink" href="#introduction" title="제목 주소">¶</a></h2>
<p>정규식(RE, regexes 또는 regex 패턴이라고 불립니다)은 본질적으로 파이썬에 내장된 매우 작고 고도로 특수화된 프로그래밍 언어이며, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈을 통해 사용할 수 있습니다. 이 작은 언어를 사용하여, 일치시키려는 가능한 문자열 집합에 대한 규칙을 지정합니다; 이 집합은 영어 문장, 전자 메일 주소, TeX 명령 또는 원하는 어떤 것이건 포함 할 수 있습니다. 그런 다음 &quot;이 문자열이 패턴과 일치합니까?&quot;, 또는 &quot;이 문자열의 어느 부분에 패턴과 일치하는 것이 있습니까?&quot;와 같은 질문을 할 수 있습니다. 또한 RE를 사용하여 문자열을 수정하거나 여러 방법으로 분할할 수 있습니다.</p>
<p>정규식 패턴은 일련의 바이트 코드로 컴파일 된 다음 C로 작성된 일치 엔진에 의해 실행됩니다. 고급 사용을 위해서는, 엔진이 지정된 RE를 실행하는 방법에 주의를 기울이고, 더 빠르게 실행되는 바이트 코드를 생성하기 위해 특정한 방법으로 RE를 작성하는 것이 필요할 수 있습니다. 최적화는 일치 엔진의 내부를 잘 이해하고 있어야하기 때문에 이 설명서에서 다루지 않습니다.</p>
<p>정규식 언어는 비교적 작고 제한적이므로, 정규식을 사용하여 가능한 모든 문자열 처리 작업을 수행 할 수있는 것은 아닙니다. 정규식으로 수행할 <em>수</em>는 있지만 표현이 아주 복잡해지는 작업도 있습니다. 이럴 때, 처리하기 위한 파이썬 코드를 작성하는 것이 더 나을 수 있습니다; 파이썬 코드는 정교한 정규식보다 느리겠지만, 아마도 더 이해하기 쉬울겁니다.</p>
</div>
<div class="section" id="simple-patterns">
<h2>단순한 패턴<a class="headerlink" href="#simple-patterns" title="제목 주소">¶</a></h2>
<p>우리는 가능한 가장 단순한 정규식에 대해 배우는 것으로 시작합니다. 정규식은 문자열에 대한 연산에 사용되므로, 가장 일반적인 작업으로 시작하겠습니다: 문자 일치.</p>
<p>정규식의 기초가되는 컴퓨터 과학(결정적인 혹은 비 결정적인 유한 오토마타)에 대한 자세한 설명은, 컴파일러 작성에 관한 거의 모든 교과서를 참조 할 수 있습니다.</p>
<div class="section" id="matching-characters">
<h3>문자 일치<a class="headerlink" href="#matching-characters" title="제목 주소">¶</a></h3>
<p>대부분 글자와 문자는 단순히 자신과 일치합니다. 예를 들어, 정규식 <code class="docutils literal notranslate"><span class="pre">test</span></code>는 문자열 <code class="docutils literal notranslate"><span class="pre">test</span></code>와 정확히 일치합니다. (이 RE가 <code class="docutils literal notranslate"><span class="pre">Test</span></code>나 <code class="docutils literal notranslate"><span class="pre">TEST</span></code>와 일치하도록 대/소문자를 구분하지 않는 모드를 활성화할 수 있습니다; 나중에 자세히 설명합니다.)</p>
<p>이 규칙에는 예외가 있습니다; 일부 문자는 특수한 <em class="dfn">메타 문자 (metacharacters)</em>이며, 자신과 일치하지 않습니다. 그 대신, 그들은 일반적이지 않은 것을 일치시켜야 한다는 신호를 보냅니다. 또는 반복하거나 의미를 바꾸어 RE의 다른 부분에 영향을줍니다. 이 설명서의 많은 부분은 다양한 메타 문자와 그 기능에 대해 논의하는데 할애하고 있습니다.</p>
<p>다음은 메타 문자의 전체 목록입니다; 이것들의 의미는 이 HOWTO의 나머지 부분에서 논의 될 것입니다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>. ^ $ * + ? { } [ ] \ | ( )
</pre></div>
</div>
<p>우리가 살펴볼 첫 번째 메타 문자는 <code class="docutils literal notranslate"><span class="pre">[</span></code>와 <code class="docutils literal notranslate"><span class="pre">]</span></code>입니다. 일치시키려는 문자 집합인 문자 클래스를 지정하는 데 사용됩니다. 문자는 개별적으로 나열되거나, 두 문자를 주고 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>로 구분하여 문자의 범위를 나타낼 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[abc]</span></code>는 <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">c</span></code> 문자와 일치합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">[a-c]</span></code>와 같은데, 같은 문자 집합을 표현하기위해 범위를 사용합니다. 소문자들 만 일치 시키려면, RE가 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>가 됩니다.</p>
<p>메타 문자는 클래스 내부에서는 활성화되지 않습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[akm$]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'k'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'$'</span></code> 문자와 일치합니다; <code class="docutils literal notranslate"><span class="pre">'$'</span></code>는 대개 메타 문자이지만, 문자 클래스 안에서는 특수한 특성이 없어집니다.</p>
<p><em class="dfn">여집합 (complement set)</em>을 사용해서 클래스에 나열되지 않은 문자를 일치시킬 수 있습니다. 이것은 클래스의 첫 번째 문자로 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>를 포함하는 것으로 나타냅니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>를 제외한 모든 문자와 일치합니다. 캐럿이 문자 클래스의 다른 곳에 나타나면, 특별한 의미가 없습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[5^]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>와 일치합니다.</p>
<p>아마도 가장 중요한 메타 문자는 백 슬래시(<code class="docutils literal notranslate"><span class="pre">\</span></code>)입니다. 파이썬 문자열 리터럴에서와 같이, 백 슬래시 다음에 다양한 특수 시퀀스를 알리는 다양한 문자가 따라올 수 있습니다. 또한, 모든 메타 문자를 이스케이프 처리하여 패턴으로 일치시킬 수 있도록 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[</span></code>나 <code class="docutils literal notranslate"><span class="pre">\</span></code>와 일치시켜야 할 때, 특별한 의미를 제거하기 위해 앞에 백 슬래시를 붙일 수 있습니다: <code class="docutils literal notranslate"><span class="pre">\[</span></code>나 <code class="docutils literal notranslate"><span class="pre">\\</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">'\'</span></code>로 시작하는 특수 시퀀스 중 일부는 숫자(digit) 집합, 글자(letter) 집합 또는 공백이 아닌 모든 것의 집합과 같이 종종 유용한 미리 정의된 문자 집합을 나타냅니다.</p>
<p>예를 들어 보겠습니다: <code class="docutils literal notranslate"><span class="pre">\w</span></code>는 모든 영숫자(alphanumeric character)와 일치합니다. 정규식 패턴을 바이트열로 표현하면, 이것은 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> 클래스와 동등합니다. 정규식 패턴이 문자열이면, <code class="docutils literal notranslate"><span class="pre">\w</span></code>는 <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 모듈이 제공하는 유니코드 데이터베이스에서 글자(letter)로 표시된 모든 문자를 일치시킵니다. 정규식을 컴파일할 때 <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> 플래그를 제공하여 문자열 패턴에서 <code class="docutils literal notranslate"><span class="pre">\w</span></code>의 더 제한된 정의를 사용할 수 있습니다.</p>
<p>다음 특수 시퀀스 목록은 완전하지 않습니다. 유니코드 문자열 패턴에 대한 시퀀스와 확장 클래스 정의의 전체 목록은, 표준 라이브러리 레퍼런스에서 <a class="reference internal" href="../library/re.html#re-syntax"><span class="std std-ref">정규식 문법</span></a>의 마지막 부분을 참조하십시오. 일반적으로, 유니코드 버전은 유니코드 데이터베이스의 적절한 범주에있는 모든 문자와 일치합니다.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><p>모든 십진숫자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>모든 비 숫자 문자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><p>모든 공백 문자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>모든 비 공백 문자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><p>모든 영숫자(alphanumeric character)와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>모든 비 영숫자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>와 동등합니다.</p>
</dd>
</dl>
<p>이 시퀀스들은 문자 클래스 내에 포함될 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[\s,.]</span></code>는 모든 공백 문자, <code class="docutils literal notranslate"><span class="pre">','</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'.'</span></code>와 일치하는 문자 클래스입니다.</p>
<p>이 절의 마지막 메타 문자는 <code class="docutils literal notranslate"><span class="pre">.</span></code>입니다. 개행 문자를 제외한 모든 문자와 일치하며, 개행 문자와도 일치하는 대체 모드(<a class="reference internal" href="../library/re.html#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.DOTALL</span></code></a>)가 있습니다. <code class="docutils literal notranslate"><span class="pre">.</span></code>는 &quot;모든 문자&quot;와 일치시키려고 할 때 자주 사용됩니다.</p>
</div>
<div class="section" id="repeating-things">
<h3>반복하기<a class="headerlink" href="#repeating-things" title="제목 주소">¶</a></h3>
<p>다양한 문자 집합을 일치시킬 수 있다는 것이 문자열에서 사용할 수있는 메서드로 이미 가능하지않은 것을 정규식이 수행 할 수있는 첫 번째 것입니다. 그러나, 이것이 정규식의 유일한 추가 기능이라면, 그다지 진보했다고 할 수 없습니다. 또 다른 기능은 RE의 일부가 특정 횟수만큼 반복되어야한다고 지정할 수 있다는 것입니다.</p>
<p>우리가 살펴볼 반복을 위한 첫 번째 메타 문자는 <code class="docutils literal notranslate"><span class="pre">*</span></code>입니다. <code class="docutils literal notranslate"><span class="pre">*</span></code>는 리터럴 문자 <code class="docutils literal notranslate"><span class="pre">'*'</span></code>와 일치하지 않습니다; 대신 이전 문자를 정확히 한 번이 아닌 0번 이상 일치시킬 수 있도록 지정합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">ca*t</span></code>는 <code class="docutils literal notranslate"><span class="pre">'ct'</span></code> (0개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자), <code class="docutils literal notranslate"><span class="pre">'cat'</span></code> (1개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>), <code class="docutils literal notranslate"><span class="pre">'caaat'</span></code> (3개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자) 등과 일치합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">*</span></code>와 같은 반복은 <em class="dfn">탐욕스럽습니다 (greedy)</em>; RE를 반복 할 때, 일치 엔진은 가능한 한 여러 번 반복하려고 시도합니다. 패턴의 뒷 부분이 일치하지 않으면, 일치 엔진은 되돌아 가서 더 작은 반복으로 다시 시도합니다.</p>
<p>단계별 예제를 통해 더 명확하게 알 수 있습니다. 정규식 <code class="docutils literal notranslate"><span class="pre">a[bcd]*b</span></code>를 생각해 봅시다. 이 문자는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치하고, 0개 이상의 <code class="docutils literal notranslate"><span class="pre">[bcd]</span></code> 클래스 문자가 뒤따르고, 마지막에 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>로 끝납니다. 이제 이 RE를 문자열 <code class="docutils literal notranslate"><span class="pre">'abcbd'</span></code>와 일치시킨다고 상상해보십시오.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 12%" />
<col style="width: 22%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>단계</p></th>
<th class="head"><p>일치된 것</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p>RE의 <code class="docutils literal notranslate"><span class="pre">a</span></code>가 일치합니다.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcbd</span></code></p></td>
<td><p>엔진은 가능한 한 길게 <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>와 일치시키려고 문자열의 끝 까지 갑니다.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><em>실패</em></p></td>
<td><p>엔진은 <code class="docutils literal notranslate"><span class="pre">b</span></code>를 일치하려고 시도하지만, 현재 위치가 문자열의 끝이므로 실패합니다.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcb</span></code></p></td>
<td><p>물러서서, <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>가 하나 적은 문자와 일치합니다.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p><em>실패</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">b</span></code>를 다시 시도하지만, 현재 위치는 <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 인 마지막 문자에 있습니다.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abc</span></code></p></td>
<td><p>다시 물러서서, <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>가 <code class="docutils literal notranslate"><span class="pre">bc</span></code>하고 만 일치합니다.</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcb</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">b</span></code>를 다시 시도합니다. 이번에는 현재 위치의 문자가 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>이므로 성공합니다.</p></td>
</tr>
</tbody>
</table>
<p>RE의 끝에 도달했으며, <code class="docutils literal notranslate"><span class="pre">'abcb'</span></code>와 일치했습니다. 이것은 일치 엔진이 처음에는 갈수있는 데까지 가본다음, 일치하는 것이 발견되지 않으면 점진적으로 물러서고, 나머지 RE의 나머지 부분을 반복해서 다시 시도하는 것을 보여줍니다. <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>에 대한 일치 항목의 길이가 0이 될 때까지 물러서고, 그 것 마저도 실패하면, 엔진은 문자열이 RE와 전혀 일치하지 않는다고 결론을 내립니다.</p>
<p>또 다른 반복 메타 문자는 <code class="docutils literal notranslate"><span class="pre">+</span></code>인데, 하나 이상과 일치합니다. <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">+</span></code>의 차이점에 주의하십시오; <code class="docutils literal notranslate"><span class="pre">*</span></code>는 <em>0</em> 이상과 일치하므로, 반복되는 내용이 전혀 표시되지 않을 수 있습니다. 반면 <code class="docutils literal notranslate"><span class="pre">+</span></code>는 적어도 <em>1</em> 번 이상 나타날 것을 요구합니다. 비슷한 예제를 사용하면, <code class="docutils literal notranslate"><span class="pre">ca+t</span></code>는 <code class="docutils literal notranslate"><span class="pre">'cat'</span></code> (1 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>), <code class="docutils literal notranslate"><span class="pre">'caaat'</span></code> (3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>)와 일치하지만 <code class="docutils literal notranslate"><span class="pre">'ct'</span></code>와 일치하지는 않습니다.</p>
<p>반복 한정자(qualifier)가 두 개 더 있습니다. 물음표 문자 <code class="docutils literal notranslate"><span class="pre">?</span></code>는 한 번이나 0 번 일치합니다; 무언가를 선택적이라고 표시한다고 생각해도 좋습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">home-?brew</span></code>는 <code class="docutils literal notranslate"><span class="pre">'homebrew'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'home-brew'</span></code>와 일치합니다.</p>
<p>가장 복잡한 반복 한정자는 <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>입니다. 여기서 <em>m</em>과 <em>n</em>은 10 진수입니다. 이 한정자는 적어도 <em>m</em> 반복, 최대 <em>n</em> 반복이 있어야 함을 의미합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a/{1,3}b</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a/b'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a//b'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'a///b'</span></code>와 일치합니다. <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>에는 슬래시가 없어서 일치하지 않고, <code class="docutils literal notranslate"><span class="pre">'a////b'</span></code>에는 4개 있어서 일치하지 않습니다.</p>
<p><em>m</em>이나 <em>n</em>을 생략 할 수 있습니다; 이 때, 빠진 값에 대해 합리적인 값이 가정됩니다. <em>m</em>을 생략하면 0 하한으로 해석하는 반면, <em>m</em>을 생략하면 무한대의 상한을 뜻합니다.</p>
<p>환원 주의로 기울어진 독자는 다른 세 한정자들을 이 표기법을 사용하여 표현할 수 있음을 알아챌 수 있을겁니다. <code class="docutils literal notranslate"><span class="pre">{0,}</span></code>은 <code class="docutils literal notranslate"><span class="pre">*</span></code>와 같고, <code class="docutils literal notranslate"><span class="pre">{1,}</span></code>은 <code class="docutils literal notranslate"><span class="pre">+</span></code>와 같으며, <code class="docutils literal notranslate"><span class="pre">{0,1}</span></code>은 <code class="docutils literal notranslate"><span class="pre">?</span></code>와 같습니다. 그럴 수 있다면 <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">?</span></code>를 사용하는 것이 좋은데, 더 짧고 읽기 쉽기 때문입니다.</p>
</div>
</div>
<div class="section" id="using-regular-expressions">
<h2>정규식 사용하기<a class="headerlink" href="#using-regular-expressions" title="제목 주소">¶</a></h2>
<p>이제 간단한 정규식을 살펴 보았습니다. 실제로 파이썬에서 어떻게 사용해야할까요? <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈은 정규식 엔진에 대한 인터페이스를 제공해서, RE를 객체로 컴파일 한 다음 일치를 수행 할 수 있도록합니다.</p>
<div class="section" id="compiling-regular-expressions">
<h3>정규식 컴파일하기<a class="headerlink" href="#compiling-regular-expressions" title="제목 주소">¶</a></h3>
<p>정규식은 패턴 객체로 컴파일되는데, 패턴 일치를 검색하거나 문자열 치환을 수행하는 등의 다양한 작업을 위한 메서드를 갖고있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">re.compile(&#39;ab*&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>은 다양한 특수 기능과 문법 변형을 가능하게 하는 선택적 <em>flags</em> 인자도 받아들입니다. 나중에 사용할 수 있는 설정을 살펴 보도록하겠지만, 지금은 한 가지 예 만 보겠습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
</pre></div>
</div>
<p>RE는 문자열로 <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>에 전달됩니다. 정규식이 핵심 파이썬 언어의 일부가 아니고, 정규식을 표현하기위한 특수 문법이 만들어지지 않았기 때문에 RE는 문자열로 다뤄집니다. (RE를 전혀 필요로하지 않는 응용 프로그램이 있으므로, 이를 포함해서 언어 사양을 부풀릴 필요가 없습니다.) 대신, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈은 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>이나 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈과 마찬가지로 파이썬에 포함 된 C 확장 모듈 일뿐입니다.</p>
<p>RE를 문자열에 넣는 것은 파이썬 언어가 더 간단하게 유지되도록 하지만, 다음 절의 주제 인 한가지 단점이 있습니다.</p>
</div>
<div class="section" id="the-backslash-plague">
<span id="id1"></span><h3>백 슬래시 전염병<a class="headerlink" href="#the-backslash-plague" title="제목 주소">¶</a></h3>
<p>앞에서 언급한 것처럼, 정규식은 백 슬래시 문자(<code class="docutils literal notranslate"><span class="pre">'\'</span></code>)를 사용하여 특수 형식을 나타내거나 특수 문자 특별한 의미를 갖지 않고 사용되로록 합니다. 이것은 파이썬이 문자열 리터럴에서 같은 목적으로 같은 문자를 사용하는 것과 충돌합니다.</p>
<p>LaTeX 파일에서 발견되는 문자열 <code class="docutils literal notranslate"><span class="pre">\section</span></code>과 일치하는 RE를 작성한다고 가정 해 봅시다. 프로그램 코드에 무엇을 쓸지 알아내기 위해, 일치시키고자 하는 문자열로 시작하십시오. 그런 다음, 백 슬래시와 다른 메타 문자 앞에 백 슬래시를 붙여 이스케이프 처리하면, 문자열 <code class="docutils literal notranslate"><span class="pre">\\section</span></code>을 얻게됩니다. <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>에 전달되어야하는 결과 문자열은 <code class="docutils literal notranslate"><span class="pre">\\section</span></code>이어야 합니다. 그러나, 이를 파이썬 문자열 리터럴로 표현하려면, 두 개의 백 슬래시를 모두 <em>다시</em> 이스케이프 처리해야합니다.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>문자</p></th>
<th class="head"><p>단계</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\section</span></code></p></td>
<td><p>일치시킬 텍스트 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\section</span></code></p></td>
<td><p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>을 위해 이스케이프 처리된 백 슬래시</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\\\section&quot;</span></code></p></td>
<td><p>문자열 리터럴을 위해 이스케이프 처리된 백 슬래시</p></td>
</tr>
</tbody>
</table>
<p>즉, 리터럴 백 슬래시와 일치 시키려면, RE 문자열로 <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code>을 작성해야 하는데, 정규식은 <code class="docutils literal notranslate"><span class="pre">\\</span></code>이어야하고, 일반 파이썬 문자열 리터럴안에서 각 백 슬래시를 <code class="docutils literal notranslate"><span class="pre">\\</span></code>로 표현해야하기 때문입니다. 백 슬래시를 반복적으로 사용하는 RE에서는, 수없이 반복되는 백 슬래시로 이어져, 결과 문자열을 이해하기 어렵게 만듭니다.</p>
<p>해결책은 정규식에 파이썬의 날 문자열 표기법을 사용하는 것입니다; 백 슬래시는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 접두사가 붙은 문자열 리터럴에서 특별한 방법으로 처리되지 않으므로, <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code>는 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'n'</span></code>을 포함하는 두 문자 문자열인 반면, <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>는 줄 넘김을 포함하는 한 문자 문자열입니다. 정규식은 종종 이 날 문자열 표기법을 사용하여 파이썬 코드로 작성됩니다.</p>
<p>또한, 정규식에서는 유효하지만 파이썬 문자열 리터럴에서는 유효하지 않은 특수 이스케이프 시퀀스는 이제 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 발생시키고 결국에는 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>가 될 것입니다. 이는 날 문자열 표기법이나 백 슬래시 이스케이핑이 사용되지 않으면 시퀀스가 유효하지 않게됨을 뜻합니다.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>일반 문자열</p></th>
<th class="head"><p>날 문자열</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;ab*&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;ab*&quot;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\\\section&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;\\section&quot;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\w+\\s+\\1&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;\w+\s+\1&quot;</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="performing-matches">
<h3>일치 수행하기<a class="headerlink" href="#performing-matches" title="제목 주소">¶</a></h3>
<p>일단 컴파일된 정규식을 나타내는 객체가 있으면, 이 것으로 무엇을 할까요? 패턴 객체에는 여러 가지 메서드와 어트리뷰트가 있습니다. 가장 중요한 것만 여기서 다루어집니다; 전체 목록을 보려면 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 설명서를 참조하십시오.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드/어트리뷰트</p></th>
<th class="head"><p>목적</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">match()</span></code></p></td>
<td><p>문자열의 시작 부분에서 RE가 일치하는지 판단합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">search()</span></code></p></td>
<td><p>이 RE가 일치하는 위치를 찾으면서, 문자열을 훑습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">findall()</span></code></p></td>
<td><p>RE가 일치하는 모든 부분 문자열을 찾아 리스트로 반환합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">finditer()</span></code></p></td>
<td><p>RE가 일치하는 모든 부분 문자열을 찾아 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>로 반환합니다.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>와 <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>는 일치하는 항목이 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 성공하면, <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 인스턴스가 반환되고, 일치에 대한 정보가 들어 있습니다: 어디에서 시작하고 끝나는지, 일치하는 부분 문자열 등입니다.</p>
<p><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈로 대화식으로 실험해보면 알 수 있습니다. <a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a>를 사용할 수 있다면, 파이썬 배포판에 포함된 데모 프로그램인 <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Tools/demo/redemo.py">Tools/demo/redemo.py</a>를 살펴볼 수도 있습니다. RE와 문자열을 입력하면, RE가 일치하는지 실패하는지 표시합니다. <code class="file docutils literal notranslate"><span class="pre">redemo.py</span></code>는 복잡한 RE를 디버깅할 때 매우 유용 할 수 있습니다.</p>
<p>이 HOWTO는 예제에 표준 파이썬 인터프리터를 사용합니다. 먼저, 파이썬 인터프리터를 실행하고, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈을 임포트한 다음, RE를 컴파일하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">re.compile(&#39;[a-z]+&#39;)</span>
</pre></div>
</div>
<p>이제, 다양한 문자열을 RE <code class="docutils literal notranslate"><span class="pre">[a-z]+</span></code>와 일치시켜볼 수 있습니다. <code class="docutils literal notranslate"><span class="pre">+</span></code>는 '하나 이상의 반복'을 의미하므로, 빈 문자열은 전혀 일치하지 않아야합니다. 이 때 <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야하며, 인터프리터는 출력을 인쇄하지 않습니다. 분명하게하기 위해 <code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code>의 결과를 명시적으로 인쇄 할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>이제, 일치해야하는 문자열을 시도해 봅시다, 가령 <code class="docutils literal notranslate"><span class="pre">tempo</span></code>. 이 때, <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>는 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환하므로, 나중에 사용할 수 있도록 결과를 변수에 저장해야합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;tempo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;re.Match object; span=(0, 5), match=&#39;tempo&#39;&gt;</span>
</pre></div>
</div>
<p>이제 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a>를 조회하여 일치하는 문자열에 대한 정보를 얻을 수 있습니다. 일치 객체 인스턴스에는 여러 메서드와 어트리뷰트가 있습니다; 가장 중요한 것들은 다음과 같습니다:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드/어트리뷰트</p></th>
<th class="head"><p>목적</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">group()</span></code></p></td>
<td><p>RE와 일치하는 문자열을 반환합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">start()</span></code></p></td>
<td><p>일치의 시작 위치를 반환합니다</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">end()</span></code></p></td>
<td><p>일치의 끝 위치를 반환합니다</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">span()</span></code></p></td>
<td><p>일치의 (시작, 끝) 위치를 포함하는 튜플을 반환합니다.</p></td>
</tr>
</tbody>
</table>
<p>이 메서드를 실험해보면 곧 그 의미가 분명해질 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;tempo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(0, 5)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>은 RE에 의해 일치된 부분 문자열을 반환합니다. <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>와 <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end()</span></code></a>는 일치의 시작과 끝 인덱스를 반환합니다. <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">span()</span></code></a>은 시작과 끝 인덱스를 단일 튜플로 반환합니다. <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 메서드는 문자열의 시작 부분에서 RE가 일치하는지 검사하므로, <code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code>는 항상 0입니다. 그러나, 패턴의 <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드는 문자열을 훑으므로, 일치가 0에서 시작하지 않을 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(4, 11), match=&#39;message&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(4, 11)</span>
</pre></div>
</div>
<p>실제 프로그램에서, 가장 일반적인 스타일은 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a>를 변수에 저장 한 다음, <code class="docutils literal notranslate"><span class="pre">None</span></code>인지 확인하는 것입니다. 보통 이런 식 입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span> <span class="s1">&#39;string goes here&#39;</span> <span class="p">)</span>
<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Match found: &#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>두 패턴 메서드는 패턴에 대한 모든 일치를 반환합니다. <a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a>은 일치하는 문자열 리스트를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#39;</span><span class="p">)</span>
<span class="go">[&#39;12&#39;, &#39;11&#39;, &#39;10&#39;]</span>
</pre></div>
</div>
<p>이 예제에서는 리터럴을 날 문자열 리터럴로 만드는 <code class="docutils literal notranslate"><span class="pre">r</span></code> 접두어가 필요한데, 일반적인 &quot;요리된(cooked)&quot; 문자열 리터럴에 있는, 정규식에서는 허락되지만 파이썬에서 인식하지 못하는, 이스케이프 시퀀스가 이제 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 발생시키고, 결국에는 결국 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>가 될 것이기 때문입니다. <a class="reference internal" href="#the-backslash-plague"><span class="std std-ref">백 슬래시 전염병</span></a>를 참조하십시오.</p>
<p><a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a>은 결과로 반환하기 전에 전체 리스트를 만들어야합니다. <a class="reference internal" href="../library/re.html#re.Pattern.finditer" title="re.Pattern.finditer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code></a> 메서드는 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">매치 객체</span></a> 인스턴스의 시퀀스를 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>로 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 ... 10 ...&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span>  
<span class="go">&lt;callable_iterator object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">(0, 2)</span>
<span class="go">(22, 24)</span>
<span class="go">(29, 31)</span>
</pre></div>
</div>
</div>
<div class="section" id="module-level-functions">
<h3>모듈 수준 함수<a class="headerlink" href="#module-level-functions" title="제목 주소">¶</a></h3>
<p>패턴 객체를 생성하고 메서드를 호출해야만 하는 것은 아닙니다; <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈은 <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>, <a class="reference internal" href="../library/re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 등의 최상위 수준 함수도 제공합니다. 이 함수들은 첫 번째 인자로 RE 문자열이 추가 된 해당 패턴 메서드와 같은 인자를 취하고, 여전히 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 인스턴스를 반환합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;Fromage amk&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;From amk Thu May 14 19:12:10 1998&#39;</span><span class="p">)</span>  
<span class="go">&lt;re.Match object; span=(0, 5), match=&#39;From &#39;&gt;</span>
</pre></div>
</div>
<p>내부적으로, 이 함수는 단순히 패턴 객체를 만들고 적절한 메서드를 호출합니다. 또한 컴파일 된 객체를 캐시에 저장하므로, 같은 RE를 사용하는 이후의 호출에서는 패턴을 반복해서 구문 분석 할 필요가 없습니다.</p>
<p>이러한 모듈 수준의 함수를 사용해야할까요, 아니면 패턴을 얻어서 메서드를 직접 호출해야할까요? 루프 내에서 정규식에 액세스하고 있가면, 사전 컴파일이 몇 번의 함수 호출을 절약할 수 있습니다. 루프 바깥에서는, 내부 캐시 덕분에 큰 차이가 없습니다.</p>
</div>
<div class="section" id="compilation-flags">
<h3>컴파일 플래그<a class="headerlink" href="#compilation-flags" title="제목 주소">¶</a></h3>
<p>컴파일 플래그를 사용하면 정규식의 작동 방식을 수정할 수 있습니다. 플래그는 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈에서 <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code>와 같은 긴 이름과 <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code>와 같은 간단한 한 글자 형식의 두 가지 이름으로 사용 가능합니다. (Perl의 패턴 수정자에 익숙하다면, 한 글자 형식은 같은 글자를 사용합니다; 예를 들어, <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>의 짧은 형식은 <a class="reference internal" href="../library/re.html#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a>입니다.) 다중 플래그는 비트별 OR하여 지정할 수 있습니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">re.I</span> <span class="pre">|</span> <span class="pre">re.M</span></code>는 <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code>와 <code class="xref py py-const docutils literal notranslate"><span class="pre">M</span></code> 플래그를 모두 설정합니다.</p>
<p>다음은 사용 가능한 플래그와 각 플래그에 대한 자세한 설명입니다.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>플래그</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">A</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> 및 <code class="docutils literal notranslate"><span class="pre">\d</span></code>와 같은 여러 이스케이프가 해당 속성이있는 ASCII 문자에만 일치하도록 합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">S</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code>가 개행 문자를 포함한 모든 문자와 일치하도록합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code></p></td>
<td><p>대소 문자 구분 없는 일치를 수행합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p>로케일을 고려하는 일치를 수행합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">M</span></code></p></td>
<td><p>다중 행 일치, <code class="docutils literal notranslate"><span class="pre">^</span></code>와 <code class="docutils literal notranslate"><span class="pre">$</span></code>에 영향을 줍니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">VERBOSE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">X</span></code> ('확장' 용)</p></td>
<td><p>보다 명확하고 이해하기 쉽게 정리될 수 있는 상세한 RE를 활성화합니다.</p></td>
</tr>
</tbody>
</table>
<dl class="data">
<dt>
<code class="descname">I</code></dt>
<dt>
<code class="descname">IGNORECASE</code></dt>
<dd><p>대소 문자를 구분하지 않는 일치를 수행합니다; 문자 클래스와 리터럴 문자열은 대소 문자를 무시하여 문자와 일치합니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code>는 소문자와도 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code> 플래그로 ASCII가 아닌 일치를 막지 않는 한, 전체 유니코드 일치도 작동합니다. 유니코드 패턴 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>나 <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code>가 <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code> 플래그와 함께 사용되면, 52 ASCII 문자와 4개의 추가 비 ASCII 문자와 일치합니다: 'İ' (U+0130, 위에 점이 있는 라틴 대문자 I), 'ı' (U+0131, 라틴 소문자 점없는 i), 'ſ' (U+017F, 라틴 소문자 긴 s) 및 'K' (U+212A, 켈빈 기호). <code class="docutils literal notranslate"><span class="pre">Spam</span></code>은 <code class="docutils literal notranslate"><span class="pre">'Spam'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spam'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spAM'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'ſpam'</span></code>과 일치합니다 (마지막은 유니코드 모드에서만 일치합니다). 이 소문자화는 현재 로케일을 고려하지 않습니다; 고려하려면 <code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code> 플래그를 설정하면됩니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">L</code></dt>
<dt>
<code class="descname">LOCALE</code></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> 및 대소 문자를 구분하지 않는 일치를 유니코드 데이터베이스 대신 현재 로케일에 의존하도록 만듭니다.</p>
<p>로케일은 언어 차이를 고려한 프로그램을 작성하는 데 도움이되는 C 라이브러리의 기능입니다. 예를 들어, 인코딩된 프랑스어 텍스트를 처리할 때, 단어와 일치하도록 <code class="docutils literal notranslate"><span class="pre">\w+</span></code>를 쓰고 싶습니다, 하지만 <code class="docutils literal notranslate"><span class="pre">\w</span></code>는 바이트열 패턴에서 <code class="docutils literal notranslate"><span class="pre">[A-Za-z]</span></code> 문자 클래스 하고만 일치합니다; <code class="docutils literal notranslate"><span class="pre">é</span></code>나 <code class="docutils literal notranslate"><span class="pre">ç</span></code>에 해당하는 바이트는 일치하지 않습니다. 시스템이 올바르게 구성되고 프랑스어 로케일이 선택되면, 특정 C 함수는 <code class="docutils literal notranslate"><span class="pre">é</span></code>에 해당하는 바이트도 문자로 간주되어야 함을 프로그램에 알립니다. 정규식을 컴파일 할 때 <code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code> 플래그를 설정하면, 컴파일 된 결과 객체가 <code class="docutils literal notranslate"><span class="pre">\w</span></code>에 대해 이러한 C 함수를 사용하게됩니다; 더 느리기는 하지만, 기대하는데로 <code class="docutils literal notranslate"><span class="pre">\w+</span></code>가 프랑스어 단어를 일치시킬 수 있습니다. 이 플래그의 사용은 파이썬 3에서는 권장하지 않는데, 로케일 메커니즘이 매우 신뢰성이 떨어지고, 한 번에 하나의 &quot;컬처(culture)&quot; 만 처리하고, 8비트 로케일에서만 작동하기 때문입니다. 파이썬 3에서 유니코드 (str) 패턴에 대해 유니코드 일치가 기본적으로 이미 활성화되어 있으며, 다른 로케일/언어를 처리할 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">M</code></dt>
<dt>
<code class="descname">MULTILINE</code></dt>
<dd><p>(<code class="docutils literal notranslate"><span class="pre">^</span></code>과 <code class="docutils literal notranslate"><span class="pre">$</span></code>는 아직 설명되지 않았습니다; <a class="reference internal" href="#more-metacharacters"><span class="std std-ref">메타 문자 더보기</span></a> 절에서 소개 될 예정입니다.)</p>
<p>보통 <code class="docutils literal notranslate"><span class="pre">^</span></code>는 문자열의 시작 부분에서만 일치하고, <code class="docutils literal notranslate"><span class="pre">$</span></code>는 문자열의 끝 부분과 문자열 끝에 있는 줄 바꿈 (있다면) 바로 앞에서 일치합니다. 이 플래그를 지정하면 <code class="docutils literal notranslate"><span class="pre">^</span></code>는 문자열 시작 부분과 문자열 내의 각 줄 시작 부분(각 줄 바꿈의 바로 뒤)에서 일치합니다. 비슷하게, <code class="docutils literal notranslate"><span class="pre">$</span></code> 메타 문자는 문자열 끝과 각 줄의 끝(각 줄 바꿈 바로 앞)에서 일치합니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">S</code></dt>
<dt>
<code class="descname">DOTALL</code></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'.'</span></code> 특수 문자가 개행 문자를 포함하는 모든 문자와 일치하도록 만듭니다; 이 플래그가 없으면, <code class="docutils literal notranslate"><span class="pre">'.'</span></code>는 개행 문자를 <em>제외한</em> 모든 문자와 일치합니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">A</code></dt>
<dt>
<code class="descname">ASCII</code></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> 및 <code class="docutils literal notranslate"><span class="pre">\S</span></code>가 전체 유니코드 일치 대신 ASCII 전용 일치를 수행하도록 만듭니다. 유니코드 패턴에서만 의미가 있으며, 바이트열 패턴에서는 무시됩니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">X</code></dt>
<dt>
<code class="descname">VERBOSE</code></dt>
<dd><p>이 플래그는 정규식을 포매팅하는 더 유연한 방법을 제공해서 더 가독성있는 정규식을 작성할 수 있도록 합니다. 이 플래그가 지정되면, 문자 클래스에 있거나 이스케이프되지 않은 백 슬래시 뒤에 있을 때를 제외하고, RE 문자열 내의 공백을 무시합니다; 이것은 RE를 보다 명확하게 구성하고 들여 쓰기 할 수 있도록 합니다. 이 플래그는 RE 내에 엔진이 무시하는 주석을 넣을 수도 있게합니다; 주석은 문자 클래스나 이스케이프 처리되지 않은 백 슬래시 뒤에 있지 않은 <code class="docutils literal notranslate"><span class="pre">'#'</span></code>로 표시됩니다.</p>
<p>예를 들어, 여기에 <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>를 사용하는 RE가 있습니다; 얼마다 더 읽기 쉬워지는지 보이십니까?</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> &amp;[#]                # 숫자 엔티티 참조의 시작</span>
<span class="s2"> (</span>
<span class="s2">     0[0-7]+         # 8진수 형식</span>
<span class="s2">   | [0-9]+          # 십진수 형식</span>
<span class="s2">   | x[0-9a-fA-F]+   # 16진수 형식</span>
<span class="s2"> )</span>
<span class="s2"> ;                   # 후행 세미콜론</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
</pre></div>
</div>
<p>상세 설정이 없으면, RE는 이렇게 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;&amp;#(0[0-7]+&quot;</span>
                     <span class="s2">&quot;|[0-9]+&quot;</span>
                     <span class="s2">&quot;|x[0-9a-fA-F]+);&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>위의 예에서, 파이썬의 문자열 리터럴 자동 이어붙이기를 사용해서 RE를 더 작은 조각으로 나누었지만, <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>를 사용하는 버전보다 여전히 이해하기가 어렵습니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="more-pattern-power">
<h2>더 많은 패턴 기능<a class="headerlink" href="#more-pattern-power" title="제목 주소">¶</a></h2>
<p>지금까지 정규식의 일부 기능에 대해서만 설명했습니다. 이 절에서는, 몇 가지 새로운 메타 문자와 그룹을 사용하여 일치하는 텍스트의 부분을 꺼내는 방법을 다룹니다.</p>
<div class="section" id="more-metacharacters">
<span id="id2"></span><h3>메타 문자 더보기<a class="headerlink" href="#more-metacharacters" title="제목 주소">¶</a></h3>
<p>우리가 아직 다루지 않은 몇 가지 메타 문자가 있습니다. 대부분 이 절에서 다룰 것입니다.</p>
<p>논의 할 나머지 메타 문자 중 일부는 <em class="dfn">폭이 없는 어서션(zero-width assertions)</em>입니다. 이들은 엔진이 문자열을 통해 앞으로 나아가도록 하지 않습니다; 대신, 문자를 전혀 소비하지 않고, 단순히 성공하거나 실패합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 현재 위치가 단어 경계에 위치한다는 어서션입니다; 위치는 <code class="docutils literal notranslate"><span class="pre">\b</span></code>에 의해 전혀 변경되지 않습니다. 이것은 폭이 없는 어서션을 반복해서는 안된다는 뜻인데, 주어진 위치에서 일단 일치하면 명백히 무한한 횟수 만큼 일치 할 수 있기 때문입니다.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p>대안, 또는 &quot;or&quot; 연산자. <em>A</em>와 <em>B</em>가 정규식이면, <code class="docutils literal notranslate"><span class="pre">A|B</span></code>는 <em>A</em>나 <em>B</em>와 일치하는 문자열과 일치합니다. <code class="docutils literal notranslate"><span class="pre">|</span></code>는 여러 문자로 된 문자열의 대안을 사용할 때 합리적으로 작동하도록하기 위해 우선순위가 매우 낮습니다. <code class="docutils literal notranslate"><span class="pre">Crow|Servo</span></code>는 <code class="docutils literal notranslate"><span class="pre">'Crow'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'Servo'</span></code>와 일치합니다, <code class="docutils literal notranslate"><span class="pre">'Cro'</span></code>, <code class="docutils literal notranslate"><span class="pre">'w'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'S'</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">'ervo'</span></code>가 아닙니다.</p>
<p>리터럴 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\|</span></code>를 사용하거나 <code class="docutils literal notranslate"><span class="pre">[|]</span></code>처럼 문자 클래스 안에 넣으십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>줄의 시작 부분에 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 플래그가 설정되어 있지 않은한, 문자열 시작 부분에서만 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 모드에서는, 문자열 내의 각 줄 바꿈 바로 뒤에서도 일치합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">From</span></code>라는 단어를 줄의 시작 부분에서만 일치시키려면, 사용할 RE는 <code class="docutils literal notranslate"><span class="pre">^From</span></code>입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^From&#39;</span><span class="p">,</span> <span class="s1">&#39;From Here to Eternity&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39;From&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^From&#39;</span><span class="p">,</span> <span class="s1">&#39;Reciting From Memory&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>리터럴 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\^</span></code>를 사용하십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>줄의 끝 부분과 일치하는데, 문자열의 끝이나 줄 바꿈 문자 다음에 오는 모든 위치로 정의됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="s1">&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(6, 7), match=&#39;}&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="s1"> &#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(6, 7), match=&#39;}&#39;&gt;</span>
</pre></div>
</div>
<p>리터럴 <code class="docutils literal notranslate"><span class="pre">'$'</span></code>를 일치 시키려면, <code class="docutils literal notranslate"><span class="pre">\$</span></code>를 사용하거나 <code class="docutils literal notranslate"><span class="pre">[$]</span></code>처럼 문자 클래스 안에 넣으십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>문자열의 시작 부분에서만 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 모드가 아닐 때, <code class="docutils literal notranslate"><span class="pre">\A</span></code>와 <code class="docutils literal notranslate"><span class="pre">^</span></code>는 실질적으로 같습니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 모드에서는, 다릅니다: <code class="docutils literal notranslate"><span class="pre">\A</span></code>는 여전히 문자열의 시작 부분에서만 일치하지만, <code class="docutils literal notranslate"><span class="pre">^</span></code>는 문자열 내의 줄 바꿈 문자 뒤에 오는 모든 위치에서 일치 할 수 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>문자열 끝 부분에서만 일치합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>단어 경계. 이것은 단어(word)의 시작이니 끝 부분에서만 일치하는 폭이 없는 어서션입니다. 단어는 영숫자 문자의 시퀀스로 정의되므로, 단어의 끝은 공백이나 영숫자가 아닌 문자로 표시됩니다.</p>
<p>다음 예제는 완전한 단어 일 때만 <code class="docutils literal notranslate"><span class="pre">class</span></code>와 일치합니다. 다른 단어 안에 포함되어 있으면 일치하지 않습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bclass\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;no class at all&#39;</span><span class="p">))</span>
<span class="go">&lt;re.Match object; span=(3, 8), match=&#39;class&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;the declassified algorithm&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;one subclass is&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>이 특수 시퀀스를 사용할 때 기억해야 할 두 가지 미묘한 점이 있습니다. 첫째, 이것은 파이썬의 문자열 리터럴과 정규식 시퀀스 간의 최악의 충돌입니다. 파이썬의 문자열 리터럴에서 <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 ASCII 값 8을 갖는 백 스페이스 문자입니다. 날 문자열을 사용하지 않으면, 파이썬이 <code class="docutils literal notranslate"><span class="pre">\b</span></code>를 백 스페이스로 변환하고, 여러분의 RE는 예상대로 일치하지 않습니다. 다음 예제는 앞의 RE와 같아 보이지만, RE 문자열 앞의 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>가 빠졌습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">class</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;no class at all&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;class&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="go">&lt;re.Match object; span=(0, 7), match=&#39;\x08class\x08&#39;&gt;</span>
</pre></div>
</div>
<p>둘째, 이 어서선이 사용되지 않는 문자 클래스 내에서, <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 파이썬의 문자열 리터럴과의 호환성을 위해 백 스페이스 문자를 나타냅니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>또 다른 폭이 없는 어서션, 이것은 <code class="docutils literal notranslate"><span class="pre">\b</span></code>의 반대이며, 현재 위치가 단어 경계에 있지 않을 때만 일치합니다.</p>
</dd>
</dl>
</div>
<div class="section" id="grouping">
<h3>그룹<a class="headerlink" href="#grouping" title="제목 주소">¶</a></h3>
<p>종종 단지 RE가 일치하는지보다 많은 정보를 얻을 필요가 있습니다. 정규식은 종종 관심있는 다른 구성 요소와 일치하는 몇 개의 서브 그룹으로 나누어진 RE를 작성하여 문자열을 해부하는 데 사용됩니다. 예를 들어, RFC-822 헤더 행은 다음과 같이 <code class="docutils literal notranslate"><span class="pre">':'</span></code>로 구분된 헤더 이름과 값으로 나뉩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>From: author@example.com
User-Agent: Thunderbird 1.5.0.9 (X11/20061227)
MIME-Version: 1.0
To: editor@example.com
</pre></div>
</div>
<p>이것은 전체 헤더 행과 일치하는 정규식을 작성하고, 헤더 이름과 일치하는 그룹 하나와 헤더 값과 일치하는 다른 그룹을 가짐으로써 처리 할 수 있습니다.</p>
<p>그룹은 <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">')'</span></code> 메타 문자로 표시됩니다. <code class="docutils literal notranslate"><span class="pre">'('</span></code>와 <code class="docutils literal notranslate"><span class="pre">')'</span></code>는 수학적 표현에서와 거의 같은 의미를 가지고 있습니다; 내부에 포함된 표현식을 함께 묶고, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>와 같은 반복 한정자로 그룹의 내용을 반복 할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(ab)*</span></code>는 <code class="docutils literal notranslate"><span class="pre">ab</span></code>를 0번 이상 반복한 것에 일치합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(ab)*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;ababababab&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 10)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">')'</span></code>로 표시된 그룹은 일치하는 텍스트의 시작과 끝 인덱스도 포착합니다; 인것은 <a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>, <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end()</span></code></a> 및 <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">span()</span></code></a>에 인자를 전달하여 꺼낼 수 있습니다. 그룹은 0부터 시작하여 번호가 매겨집니다. 그룹 0은 항상 존재합니다; 이것은 전체 RE이므로 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 메서드는 모두 그룹 0을 기본 인자로 사용합니다. 나중에 일치하는 텍스트 범위를 포착하지 않는 그룹을 표현하는 방법을 살펴 보겠습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(a)b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;ab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>서브 그룹은 왼쪽에서 오른쪽으로 1부터 위로 번호가 매겨집니다. 그룹은 중첩 될 수 있습니다; 숫자를 결정하려면, 왼쪽에서 오른쪽으로 가면서 여는 괄호 문자를 세십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(a(b)c)d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;abcd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>으로는 한 번에 여러 개의 그룹 번호를 전달할 수 있으며, 이 때 해당 그룹에 해당하는 값을 포함하는 튜플을 반환합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(&#39;b&#39;, &#39;abc&#39;, &#39;b&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.groups" title="re.Match.groups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groups()</span></code></a> 메서드는 모든 서브 그룹에 대한 문자열을 포함하는 튜플을 반환합니다,  1에서 최대까지.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;abc&#39;, &#39;b&#39;)</span>
</pre></div>
</div>
<p>패턴의 역 참조를 사용하면 이전 포착 그룹의 내용이 문자열의 현재 위치에서도 발견되어야한다고 지정할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">\1</span></code>은 그룹 1의 정확한 내용이 현재 위치에서 발견되면 성공하고, 그렇지 않으면 실패합니다. 파이썬의 문자열 리터럴은 백 슬래시 뒤에 숫자를 붙여 문자열에 임의의 문자를 포함 할 수 있으므로, RE에 역 참조를 포함 할 때 날 문자열을 사용해야합니다.</p>
<p>예를 들어, 다음 RE는 문자열에서 중복 단어를 감지합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(\w+)\s+\1\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Paris in the the spring&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;the the&#39;</span>
</pre></div>
</div>
<p>이와 같은 역 참조는 단순히 문자열을 검색하는 데는 별로 유용하지 않습니다 --- 이런 식으로 데이터를 반복하는 텍스트 형식은 거의 없습니다 --- 하지만 곧 문자열 치환을 수행 할 때 <em>아주</em> 유용하다는 것을 알게 될 것입니다.</p>
</div>
<div class="section" id="non-capturing-and-named-groups">
<h3>비 포착 그룹과 이름 있는 그룹<a class="headerlink" href="#non-capturing-and-named-groups" title="제목 주소">¶</a></h3>
<p>정교한 RE는 관심있는 부분 문자열을 포착하고 RE 자체를 그룹화하고 구조화하기 위해 많은 그룹을 사용할 수 있습니다. 복잡한 RE에서는, 그룹 번호를 추적하기가 어려워집니다. 이 문제를 해결하는 데 도움이되는 두 가지 기능이 있습니다. 둘 모두 정규식 확장에 같은 문법을 사용하므로, 그것부터 살펴 보겠습니다.</p>
<p>Perl 5는 표준 정규식에 대한 강력한 추가 기능으로 유명합니다. 이러한 새로운 기능을 위해 Perl 개발자는 Perl의 정규식을 표준 RE와 혼란스러울만큼 다르게 만들지 않으면서 한 글자 메타 문자나 <code class="docutils literal notranslate"><span class="pre">\</span></code>로 시작하는 새로운 특수 시퀀스를 선택할 수 없었습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>를 새로운 메타 문자로 선택하면, 예전 정규식은 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>가 일반 문자라고 가정하고 <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code>나 <code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code>로 작성하여 이스케이프하지 않을 것입니다.</p>
<p>Perl 개발자가 선택한 해법은 <code class="docutils literal notranslate"><span class="pre">(?...)</span></code>를 확장 문법으로 사용하는 것입니다. 괄호 바로 뒤에있는 <code class="docutils literal notranslate"><span class="pre">?</span></code>는 <code class="docutils literal notranslate"><span class="pre">?</span></code>가 반복할 것이 없기 때문에 문법 에러였습니다. 따라서 이것은 어떤 호환성 문제도 일으키지 않습니다. <code class="docutils literal notranslate"><span class="pre">?</span></code> 다음에 나오는 문자는 어떤 확장이 사용되는지 나타내므로, <code class="docutils literal notranslate"><span class="pre">(?=foo)</span></code>는 한가지 확장이고 (긍정적인 미리보기 어서션), <code class="docutils literal notranslate"><span class="pre">(?:foo)</span></code>는 또 다른 것입니다 (서브 정규식 <code class="docutils literal notranslate"><span class="pre">foo</span></code>를 포함하는 비 포착 그룹).</p>
<p>파이썬은 여러 Perl의 확장을 지원하고 Perl의 확장 문법에 확장 문법을 추가합니다. 물음표 뒤의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">P</span></code>이면, 파이썬에 특유한 확장임을 알 수 있습니다.</p>
<p>이제 일반적인 확장 문법을 살펴 보았으므로, 복잡한 RE에서 그룹 작업을 단순화하는 기능으로 돌아갈 수 있습니다.</p>
<p>Sometimes you'll want to use a group to denote a part of a regular expression,
but aren't interested in retrieving the group's contents. You can make this fact
explicit by using a non-capturing group: <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>, where you can replace the
<code class="docutils literal notranslate"><span class="pre">...</span></code> with any other regular expression.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;([abc])+&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;c&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;(?:[abc])+&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">()</span>
</pre></div>
</div>
<p>Except for the fact that you can't retrieve the contents of what the group
matched, a non-capturing group behaves exactly the same as a capturing group;
you can put anything inside it, repeat it with a repetition metacharacter such
as <code class="docutils literal notranslate"><span class="pre">*</span></code>, and nest it within other groups (capturing or non-capturing).
<code class="docutils literal notranslate"><span class="pre">(?:...)</span></code> is particularly useful when modifying an existing pattern, since you
can add new groups without changing how all the other groups are numbered.  It
should be mentioned that there's no performance difference in searching between
capturing and non-capturing groups; neither form is any faster than the other.</p>
<p>A more significant feature is named groups: instead of referring to them by
numbers, groups can be referenced by a name.</p>
<p>The syntax for a named group is one of the Python-specific extensions:
<code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>.  <em>name</em> is, obviously, the name of the group.  Named groups
behave exactly like capturing groups, and additionally associate a name
with a group.  The <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> methods that deal with
capturing groups all accept either integers that refer to the group by number
or strings that contain the desired group's name.  Named groups are still
given numbers, so you can retrieve information about a group in two ways:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;word&gt;\b\w+\b)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="s1">&#39;(((( Lots of punctuation )))&#39;</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">&#39;Lots&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Lots&#39;</span>
</pre></div>
</div>
<p>Additionally, you can retrieve named groups as a dictionary with
<a class="reference internal" href="../library/re.html#re.Match.groupdict" title="re.Match.groupdict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groupdict()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;first&gt;\w+) (?P&lt;last&gt;\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Jane Doe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first&#39;: &#39;Jane&#39;, &#39;last&#39;: &#39;Doe&#39;}</span>
</pre></div>
</div>
<p>Named groups are handy because they let you use easily-remembered names, instead
of having to remember numbers.  Here's an example RE from the <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a>
module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">InternalDate</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;INTERNALDATE &quot;&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;year&gt;[0-9][0-9][0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39; (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39; (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It's obviously much easier to retrieve <code class="docutils literal notranslate"><span class="pre">m.group('zonem')</span></code>, instead of having
to remember to retrieve group 9.</p>
<p>The syntax for backreferences in an expression such as <code class="docutils literal notranslate"><span class="pre">(...)\1</span></code> refers to the
number of the group.  There's naturally a variant that uses the group name
instead of the number. This is another Python extension: <code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code> indicates
that the contents of the group called <em>name</em> should again be matched at the
current point.  The regular expression for finding doubled words,
<code class="docutils literal notranslate"><span class="pre">\b(\w+)\s+\1\b</span></code> can also be written as <code class="docutils literal notranslate"><span class="pre">\b(?P&lt;word&gt;\w+)\s+(?P=word)\b</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(?P&lt;word&gt;\w+)\s+(?P=word)\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Paris in the the spring&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;the the&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="lookahead-assertions">
<h3>미리보기 어서션<a class="headerlink" href="#lookahead-assertions" title="제목 주소">¶</a></h3>
<p>Another zero-width assertion is the lookahead assertion.  Lookahead assertions
are available in both positive and negative form, and  look like this:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>Positive lookahead assertion.  This succeeds if the contained regular
expression, represented here by <code class="docutils literal notranslate"><span class="pre">...</span></code>, successfully matches at the current
location, and fails otherwise. But, once the contained expression has been
tried, the matching engine doesn't advance at all; the rest of the pattern is
tried right where the assertion started.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>Negative lookahead assertion.  This is the opposite of the positive assertion;
it succeeds if the contained expression <em>doesn't</em> match at the current position
in the string.</p>
</dd>
</dl>
<p>To make this concrete, let's look at a case where a lookahead is useful.
Consider a simple pattern to match a filename and split it apart into a base
name and an extension, separated by a <code class="docutils literal notranslate"><span class="pre">.</span></code>.  For example, in <code class="docutils literal notranslate"><span class="pre">news.rc</span></code>,
<code class="docutils literal notranslate"><span class="pre">news</span></code> is the base name, and <code class="docutils literal notranslate"><span class="pre">rc</span></code> is the filename's extension.</p>
<p>The pattern to match this is quite simple:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.].*$</span></code></p>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">.</span></code> needs to be treated specially because it's a
metacharacter, so it's inside a character class to only match that
specific character.  Also notice the trailing <code class="docutils literal notranslate"><span class="pre">$</span></code>; this is added to
ensure that all the rest of the string must be included in the
extension.  This regular expression matches <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> and
<code class="docutils literal notranslate"><span class="pre">autoexec.bat</span></code> and <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code> and <code class="docutils literal notranslate"><span class="pre">printers.conf</span></code>.</p>
<p>Now, consider complicating the problem a bit; what if you want to match
filenames where the extension is not <code class="docutils literal notranslate"><span class="pre">bat</span></code>? Some incorrect attempts:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.][^b].*$</span></code>  The first attempt above tries to exclude <code class="docutils literal notranslate"><span class="pre">bat</span></code> by requiring
that the first character of the extension is not a <code class="docutils literal notranslate"><span class="pre">b</span></code>.  This is wrong,
because the pattern also doesn't match <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.]([^b]..|.[^a].|..[^t])$</span></code></p>
<p>The expression gets messier when you try to patch up the first solution by
requiring one of the following cases to match: the first character of the
extension isn't <code class="docutils literal notranslate"><span class="pre">b</span></code>; the second character isn't <code class="docutils literal notranslate"><span class="pre">a</span></code>; or the third character
isn't <code class="docutils literal notranslate"><span class="pre">t</span></code>.  This accepts <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> and rejects <code class="docutils literal notranslate"><span class="pre">autoexec.bat</span></code>, but it
requires a three-letter extension and won't accept a filename with a two-letter
extension such as <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>.  We'll complicate the pattern again in an
effort to fix it.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</span></code></p>
<p>In the third attempt, the second and third letters are all made optional in
order to allow matching extensions shorter than three characters, such as
<code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>.</p>
<p>The pattern's getting really complicated now, which makes it hard to read and
understand.  Worse, if the problem changes and you want to exclude both <code class="docutils literal notranslate"><span class="pre">bat</span></code>
and <code class="docutils literal notranslate"><span class="pre">exe</span></code> as extensions, the pattern would get even more complicated and
confusing.</p>
<p>A negative lookahead cuts through all this confusion:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.](?!bat$)[^.]*$</span></code>  The negative lookahead means: if the expression <code class="docutils literal notranslate"><span class="pre">bat</span></code>
doesn't match at this point, try the rest of the pattern; if <code class="docutils literal notranslate"><span class="pre">bat$</span></code> does
match, the whole pattern will fail.  The trailing <code class="docutils literal notranslate"><span class="pre">$</span></code> is required to ensure
that something like <code class="docutils literal notranslate"><span class="pre">sample.batch</span></code>, where the extension only starts with
<code class="docutils literal notranslate"><span class="pre">bat</span></code>, will be allowed.  The <code class="docutils literal notranslate"><span class="pre">[^.]*</span></code> makes sure that the pattern works
when there are multiple dots in the filename.</p>
<p>Excluding another filename extension is now easy; simply add it as an
alternative inside the assertion.  The following pattern excludes filenames that
end in either <code class="docutils literal notranslate"><span class="pre">bat</span></code> or <code class="docutils literal notranslate"><span class="pre">exe</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.](?!bat$|exe$)[^.]*$</span></code></p>
</div>
</div>
<div class="section" id="modifying-strings">
<h2>Modifying Strings<a class="headerlink" href="#modifying-strings" title="제목 주소">¶</a></h2>
<p>Up to this point, we've simply performed searches against a static string.
Regular expressions are also commonly used to modify strings in various ways,
using the following pattern methods:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드/어트리뷰트</p></th>
<th class="head"><p>목적</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">split()</span></code></p></td>
<td><p>Split the string into a list, splitting it
wherever the RE matches</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sub()</span></code></p></td>
<td><p>Find all substrings where the RE matches, and
replace them with a different string</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">subn()</span></code></p></td>
<td><p>Does the same thing as <code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code>,  but
returns the new string and the number of
replacements</p></td>
</tr>
</tbody>
</table>
<div class="section" id="splitting-strings">
<h3>Splitting Strings<a class="headerlink" href="#splitting-strings" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="../library/re.html#re.Pattern.split" title="re.Pattern.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> method of a pattern splits a string apart
wherever the RE matches, returning a list of the pieces. It's similar to the
<a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> method of strings but provides much more generality in the
delimiters that you can split by; string <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code> only supports splitting by
whitespace or by a fixed string.  As you'd expect, there's a module-level
<a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> function, too.</p>
<dl class="method">
<dt>
<code class="descclassname">.</code><code class="descname">split</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>maxsplit=0</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Split <em>string</em> by the matches of the regular expression.  If capturing
parentheses are used in the RE, then their contents will also be returned as
part of the resulting list.  If <em>maxsplit</em> is nonzero, at most <em>maxsplit</em> splits
are performed.</p>
</dd></dl>

<p>You can limit the number of splits made, by passing a value for <em>maxsplit</em>.
When <em>maxsplit</em> is nonzero, at most <em>maxsplit</em> splits will be made, and the
remainder of the string is returned as the final element of the list.  In the
following example, the delimiter is any sequence of non-alphanumeric characters.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This is a test, short and sweet, of split().&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;short&#39;, &#39;and&#39;, &#39;sweet&#39;, &#39;of&#39;, &#39;split&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This is a test, short and sweet, of split().&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test, short and sweet, of split().&#39;]</span>
</pre></div>
</div>
<p>Sometimes you're not only interested in what the text between delimiters is, but
also need to know what the delimiter was.  If capturing parentheses are used in
the RE, then their values are also returned as part of the list.  Compare the
following calls:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This... is a test.&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This... is a test.&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;... &#39;, &#39;is&#39;, &#39; &#39;, &#39;a&#39;, &#39; &#39;, &#39;test&#39;, &#39;.&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>The module-level function <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> adds the RE to be used as the first
argument, but is otherwise the same.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W]+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([\W]+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W]+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="search-and-replace">
<h3>Search and Replace<a class="headerlink" href="#search-and-replace" title="제목 주소">¶</a></h3>
<p>Another common task is to find all the matches for a pattern, and replace them
with a different string.  The <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> method takes a replacement value,
which can be either a string or a function, and the string to be processed.</p>
<dl class="method">
<dt>
<code class="descclassname">.</code><code class="descname">sub</code><span class="sig-paren">(</span><em>replacement</em>, <em>string</em><span class="optional">[</span>, <em>count=0</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the string obtained by replacing the leftmost non-overlapping
occurrences of the RE in <em>string</em> by the replacement <em>replacement</em>.  If the
pattern isn't found, <em>string</em> is returned unchanged.</p>
<p>The optional argument <em>count</em> is the maximum number of pattern occurrences to be
replaced; <em>count</em> must be a non-negative integer.  The default value of 0 means
to replace all occurrences.</p>
</dd></dl>

<p>Here's a simple example of using the <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> method.  It replaces colour
names with the word <code class="docutils literal notranslate"><span class="pre">colour</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(blue|white|red)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">)</span>
<span class="go">&#39;colour socks and colour shoes&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;colour socks and red shoes&#39;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/re.html#re.Pattern.subn" title="re.Pattern.subn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subn()</span></code></a> method does the same work, but returns a 2-tuple containing the
new string value and the number of replacements  that were performed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(blue|white|red)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">)</span>
<span class="go">(&#39;colour socks and colour shoes&#39;, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;no colours at all&#39;</span><span class="p">)</span>
<span class="go">(&#39;no colours at all&#39;, 0)</span>
</pre></div>
</div>
<p>Empty matches are replaced only when they're not adjacent to a previous empty match.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;x*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;abxd&#39;</span><span class="p">)</span>
<span class="go">&#39;-a-b--d-&#39;</span>
</pre></div>
</div>
<p>If <em>replacement</em> is a string, any backslash escapes in it are processed.  That
is, <code class="docutils literal notranslate"><span class="pre">\n</span></code> is converted to a single newline character, <code class="docutils literal notranslate"><span class="pre">\r</span></code> is converted to a
carriage return, and so forth. Unknown escapes such as <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> are left alone.
Backreferences, such as <code class="docutils literal notranslate"><span class="pre">\6</span></code>, are replaced with the substring matched by the
corresponding group in the RE.  This lets you incorporate portions of the
original text in the resulting replacement string.</p>
<p>This example matches the word <code class="docutils literal notranslate"><span class="pre">section</span></code> followed by a string enclosed in
<code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>, and changes <code class="docutils literal notranslate"><span class="pre">section</span></code> to <code class="docutils literal notranslate"><span class="pre">subsection</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;section{ ( [^}]* ) }&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\1}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1"> section</span><span class="si">{second}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First} subsection{second}&#39;</span>
</pre></div>
</div>
<p>There's also a syntax for referring to named groups as defined by the
<code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> syntax.  <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> will use the substring matched by the
group named <code class="docutils literal notranslate"><span class="pre">name</span></code>, and  <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code>  uses the corresponding group number.
<code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code> is therefore equivalent to <code class="docutils literal notranslate"><span class="pre">\2</span></code>,  but isn't ambiguous in a
replacement string such as <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>.  (<code class="docutils literal notranslate"><span class="pre">\20</span></code> would be interpreted as a
reference to group 20, not a reference to group 2 followed by the literal
character <code class="docutils literal notranslate"><span class="pre">'0'</span></code>.)  The following substitutions are all equivalent, but use all
three variations of the replacement string.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;section{ (?P&lt;name&gt; [^}]* ) }&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\1}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\g&lt;1&gt;}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\g&lt;name&gt;}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
</pre></div>
</div>
<p><em>replacement</em> can also be a function, which gives you even more control.  If
<em>replacement</em> is a function, the function is called for every non-overlapping
occurrence of <em>pattern</em>.  On each call, the function is passed a
<a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> argument for the match and can use this
information to compute the desired replacement string and return it.</p>
<p>In the following example, the replacement function translates decimals into
hexadecimal:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">hexrepl</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;Return the hex string for a decimal number&quot;</span>
<span class="gp">... </span>    <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">hex</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">hexrepl</span><span class="p">,</span> <span class="s1">&#39;Call 65490 for printing, 49152 for user code.&#39;</span><span class="p">)</span>
<span class="go">&#39;Call 0xffd2 for printing, 0xc000 for user code.&#39;</span>
</pre></div>
</div>
<p>When using the module-level <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> function, the pattern is passed as
the first argument.  The pattern may be provided as an object or as a string; if
you need to specify regular expression flags, you must either use a
pattern object as the first parameter, or use embedded modifiers in the
pattern string, e.g. <code class="docutils literal notranslate"><span class="pre">sub(&quot;(?i)b+&quot;,</span> <span class="pre">&quot;x&quot;,</span> <span class="pre">&quot;bbbb</span> <span class="pre">BBBB&quot;)</span></code> returns <code class="docutils literal notranslate"><span class="pre">'x</span> <span class="pre">x'</span></code>.</p>
</div>
</div>
<div class="section" id="common-problems">
<h2>Common Problems<a class="headerlink" href="#common-problems" title="제목 주소">¶</a></h2>
<p>Regular expressions are a powerful tool for some applications, but in some ways
their behaviour isn't intuitive and at times they don't behave the way you may
expect them to.  This section will point out some of the most common pitfalls.</p>
<div class="section" id="use-string-methods">
<h3>Use String Methods<a class="headerlink" href="#use-string-methods" title="제목 주소">¶</a></h3>
<p>Sometimes using the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module is a mistake.  If you're matching a fixed
string, or a single character class, and you're not using any <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> features
such as the <a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> flag, then the full power of regular expressions
may not be required. Strings have several methods for performing operations with
fixed strings and they're usually much faster, because the implementation is a
single small C loop that's been optimized for the purpose, instead of the large,
more generalized regular expression engine.</p>
<p>One example might be replacing a single fixed string with another one; for
example, you might replace <code class="docutils literal notranslate"><span class="pre">word</span></code> with <code class="docutils literal notranslate"><span class="pre">deed</span></code>.  <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> seems like the
function to use for this, but consider the <a class="reference internal" href="../library/stdtypes.html#str.replace" title="str.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> method.  Note that
<code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code> will also replace <code class="docutils literal notranslate"><span class="pre">word</span></code> inside words, turning <code class="docutils literal notranslate"><span class="pre">swordfish</span></code>
into <code class="docutils literal notranslate"><span class="pre">sdeedfish</span></code>, but the  naive RE <code class="docutils literal notranslate"><span class="pre">word</span></code> would have done that, too.  (To
avoid performing the substitution on parts of words, the pattern would have to
be <code class="docutils literal notranslate"><span class="pre">\bword\b</span></code>, in order to require that <code class="docutils literal notranslate"><span class="pre">word</span></code> have a word boundary on
either side.  This takes the job beyond  <code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code>'s abilities.)</p>
<p>Another common task is deleting every occurrence of a single character from a
string or replacing it with another single character.  You might do this with
something like <code class="docutils literal notranslate"><span class="pre">re.sub('\n',</span> <span class="pre">'</span> <span class="pre">',</span> <span class="pre">S)</span></code>, but <a class="reference internal" href="../library/stdtypes.html#str.translate" title="str.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a> is capable of
doing both tasks and will be faster than any regular expression operation can
be.</p>
<p>In short, before turning to the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module, consider whether your problem
can be solved with a faster and simpler string method.</p>
</div>
<div class="section" id="match-versus-search">
<h3>match() versus search()<a class="headerlink" href="#match-versus-search" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> function only checks if the RE matches at the beginning of the
string while <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> will scan forward through the string for a match.
It's important to keep this distinction in mind.  Remember,  <code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code> will
only report a successful match which will start at 0; if the match wouldn't
start at zero,  <code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code> will <em>not</em> report it.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;superstition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;insuperable&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>On the other hand, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> will scan forward through the string,
reporting the first match it finds.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;superstition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;insuperable&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(2, 7)</span>
</pre></div>
</div>
<p>Sometimes you'll be tempted to keep using <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>, and just add <code class="docutils literal notranslate"><span class="pre">.*</span></code>
to the front of your RE.  Resist this temptation and use <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>
instead.  The regular expression compiler does some analysis of REs in order to
speed up the process of looking for a match.  One such analysis figures out what
the first character of a match must be; for example, a pattern starting with
<code class="docutils literal notranslate"><span class="pre">Crow</span></code> must match starting with a <code class="docutils literal notranslate"><span class="pre">'C'</span></code>.  The analysis lets the engine
quickly scan through the string looking for the starting character, only trying
the full match if a <code class="docutils literal notranslate"><span class="pre">'C'</span></code> is found.</p>
<p>Adding <code class="docutils literal notranslate"><span class="pre">.*</span></code> defeats this optimization, requiring scanning to the end of the
string and then backtracking to find a match for the rest of the RE.  Use
<a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> instead.</p>
</div>
<div class="section" id="greedy-versus-non-greedy">
<h3>Greedy versus Non-Greedy<a class="headerlink" href="#greedy-versus-non-greedy" title="제목 주소">¶</a></h3>
<p>When repeating a regular expression, as in <code class="docutils literal notranslate"><span class="pre">a*</span></code>, the resulting action is to
consume as much of the pattern as possible.  This fact often bites you when
you're trying to match a pair of balanced delimiters, such as the angle brackets
surrounding an HTML tag.  The naive pattern for matching a single HTML tag
doesn't work because of the greedy nature of <code class="docutils literal notranslate"><span class="pre">.*</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="go">&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;</span>
</pre></div>
</div>
<p>The RE matches the <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> in <code class="docutils literal notranslate"><span class="pre">'&lt;html&gt;'</span></code>, and the <code class="docutils literal notranslate"><span class="pre">.*</span></code> consumes the rest of
the string.  There's still more left in the RE, though, and the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> can't
match at the end of the string, so the regular expression engine has to
backtrack character by character until it finds a match for the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>.   The
final match extends from the <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> in <code class="docutils literal notranslate"><span class="pre">'&lt;html&gt;'</span></code> to the <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> in
<code class="docutils literal notranslate"><span class="pre">'&lt;/title&gt;'</span></code>, which isn't what you want.</p>
<p>In this case, the solution is to use the non-greedy qualifiers <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>,
<code class="docutils literal notranslate"><span class="pre">??</span></code>, or <code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code>, which match as <em>little</em> text as possible.  In the above
example, the <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> is tried immediately after the first <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> matches, and
when it fails, the engine advances a character at a time, retrying the <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>
at every step.  This produces just the right result:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*?&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="go">&lt;html&gt;</span>
</pre></div>
</div>
<p>(Note that parsing HTML or XML with regular expressions is painful.
Quick-and-dirty patterns will handle common cases, but HTML and XML have special
cases that will break the obvious regular expression; by the time you've written
a regular expression that handles all of the possible cases, the patterns will
be <em>very</em> complicated.  Use an HTML or XML parser module for such tasks.)</p>
</div>
<div class="section" id="using-re-verbose">
<h3>Using re.VERBOSE<a class="headerlink" href="#using-re-verbose" title="제목 주소">¶</a></h3>
<p>By now you've probably noticed that regular expressions are a very compact
notation, but they're not terribly readable.  REs of moderate complexity can
become lengthy collections of backslashes, parentheses, and metacharacters,
making them difficult to read and understand.</p>
<p>For such REs, specifying the <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a> flag when compiling the regular
expression can be helpful, because it allows you to format the regular
expression more clearly.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">re.VERBOSE</span></code> flag has several effects.  Whitespace in the regular
expression that <em>isn't</em> inside a character class is ignored.  This means that an
expression such as <code class="docutils literal notranslate"><span class="pre">dog</span> <span class="pre">|</span> <span class="pre">cat</span></code> is equivalent to the less readable <code class="docutils literal notranslate"><span class="pre">dog|cat</span></code>,
but <code class="docutils literal notranslate"><span class="pre">[a</span> <span class="pre">b]</span></code> will still match the characters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, or a space.  In
addition, you can also put comments inside a RE; comments extend from a <code class="docutils literal notranslate"><span class="pre">#</span></code>
character to the next newline.  When used with triple-quoted strings, this
enables REs to be formatted more neatly:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> \s*                 # Skip leading whitespace</span>
<span class="s2"> (?P&lt;header&gt;[^:]+)   # Header name</span>
<span class="s2"> \s* :               # Whitespace, and a colon</span>
<span class="s2"> (?P&lt;value&gt;.*?)      # The header&#39;s value -- *? used to</span>
<span class="s2">                     # lose the following trailing whitespace</span>
<span class="s2"> \s*$                # Trailing whitespace to end-of-line</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
</pre></div>
</div>
<p>This is far more readable than:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="feedback">
<h2>Feedback<a class="headerlink" href="#feedback" title="제목 주소">¶</a></h2>
<p>Regular expressions are a complicated topic.  Did this document help you
understand them?  Were there parts that were unclear, or Problems you
encountered that weren't covered here?  If so, please send suggestions for
improvements to the author.</p>
<p>The most complete book on regular expressions is almost certainly Jeffrey
Friedl's Mastering Regular Expressions, published by O'Reilly.  Unfortunately,
it exclusively concentrates on Perl and Java's flavours of regular expressions,
and doesn't contain any Python material at all, so it won't be useful as a
reference for programming in Python.  (The first edition covered Python's
now-removed <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> module, which won't help you much.)  Consider checking
it out from your library.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">정규식 HOWTO</a><ul>
<li><a class="reference internal" href="#introduction">소개</a></li>
<li><a class="reference internal" href="#simple-patterns">단순한 패턴</a><ul>
<li><a class="reference internal" href="#matching-characters">문자 일치</a></li>
<li><a class="reference internal" href="#repeating-things">반복하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-regular-expressions">정규식 사용하기</a><ul>
<li><a class="reference internal" href="#compiling-regular-expressions">정규식 컴파일하기</a></li>
<li><a class="reference internal" href="#the-backslash-plague">백 슬래시 전염병</a></li>
<li><a class="reference internal" href="#performing-matches">일치 수행하기</a></li>
<li><a class="reference internal" href="#module-level-functions">모듈 수준 함수</a></li>
<li><a class="reference internal" href="#compilation-flags">컴파일 플래그</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-pattern-power">더 많은 패턴 기능</a><ul>
<li><a class="reference internal" href="#more-metacharacters">메타 문자 더보기</a></li>
<li><a class="reference internal" href="#grouping">그룹</a></li>
<li><a class="reference internal" href="#non-capturing-and-named-groups">비 포착 그룹과 이름 있는 그룹</a></li>
<li><a class="reference internal" href="#lookahead-assertions">미리보기 어서션</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modifying-strings">Modifying Strings</a><ul>
<li><a class="reference internal" href="#splitting-strings">Splitting Strings</a></li>
<li><a class="reference internal" href="#search-and-replace">Search and Replace</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-problems">Common Problems</a><ul>
<li><a class="reference internal" href="#use-string-methods">Use String Methods</a></li>
<li><a class="reference internal" href="#match-versus-search">match() versus search()</a></li>
<li><a class="reference internal" href="#greedy-versus-non-greedy">Greedy versus Non-Greedy</a></li>
<li><a class="reference internal" href="#using-re-verbose">Using re.VERBOSE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#feedback">Feedback</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="logging-cookbook.html"
                        title="이전 장">로깅 요리책</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="sockets.html"
                        title="다음 장">소켓 프로그래밍 HOWTO</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="소켓 프로그래밍 HOWTO"
             >다음</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="로깅 요리책"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>