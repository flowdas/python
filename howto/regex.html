
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>정규식 HOWTO &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="소켓 프로그래밍 HOWTO" href="sockets.html" />
    <link rel="prev" title="로깅 요리책" href="logging-cookbook.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/howto/regex.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="소켓 프로그래밍 HOWTO"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="로깅 요리책"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="regular-expression-howto">
<span id="regex-howto"></span><h1>정규식 HOWTO<a class="headerlink" href="#regular-expression-howto" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">저자</dt>
<dd class="field-odd"><p>A.M. Kuchling &lt;<a class="reference external" href="mailto:amk&#37;&#52;&#48;amk&#46;ca">amk<span>&#64;</span>amk<span>&#46;</span>ca</a>&gt;</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title first">요약</p>
<p>이 설명서는 파이썬에서 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈로 정규식을 사용하는 방법을 소개하는 입문서입니다. 라이브러리 레퍼런스의 해당 절보다 더 부드러운 소개를 제공합니다.</p>
</div>
<div class="section" id="introduction">
<h2>소개<a class="headerlink" href="#introduction" title="제목 주소">¶</a></h2>
<p>정규식(RE, regexes 또는 regex 패턴이라고 불립니다)은 본질적으로 파이썬에 내장된 매우 작고 고도로 특수화된 프로그래밍 언어이며, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈을 통해 사용할 수 있습니다. 이 작은 언어를 사용하여, 일치시키려는 가능한 문자열 집합에 대한 규칙을 지정합니다; 이 집합은 영어 문장, 전자 메일 주소, TeX 명령 또는 원하는 어떤 것이건 포함 할 수 있습니다. 그런 다음 &quot;이 문자열이 패턴과 일치합니까?&quot;, 또는 &quot;이 문자열의 어느 부분에 패턴과 일치하는 것이 있습니까?&quot;와 같은 질문을 할 수 있습니다. 또한 RE를 사용하여 문자열을 수정하거나 여러 방법으로 분할할 수 있습니다.</p>
<p>정규식 패턴은 일련의 바이트 코드로 컴파일된 다음 C로 작성된 일치 엔진에 의해 실행됩니다. 고급 사용을 위해서는, 엔진이 지정된 RE를 실행하는 방법에 주의를 기울이고, 더 빠르게 실행되는 바이트 코드를 생성하기 위해 특정한 방법으로 RE를 작성하는 것이 필요할 수 있습니다. 최적화는 일치 엔진의 내부를 잘 이해하고 있어야 하므로 이 설명서에서 다루지 않습니다.</p>
<p>정규식 언어는 비교적 작고 제한적이므로, 정규식을 사용하여 가능한 모든 문자열 처리 작업을 수행할 수 있는 것은 아닙니다. 정규식으로 수행할 <em>수</em>는 있지만, 표현이 아주 복잡해지는 작업도 있습니다. 이럴 때, 처리하기 위한 파이썬 코드를 작성하는 것이 더 나을 수 있습니다; 파이썬 코드는 정교한 정규식보다 느리겠지만, 아마도 더 이해하기 쉬울 겁니다.</p>
</div>
<div class="section" id="simple-patterns">
<h2>단순한 패턴<a class="headerlink" href="#simple-patterns" title="제목 주소">¶</a></h2>
<p>우리는 가능한 가장 단순한 정규식에 대해 배우는 것으로 시작합니다. 정규식은 문자열에 대한 연산에 사용되므로, 가장 일반적인 작업으로 시작하겠습니다: 문자 일치.</p>
<p>정규식의 기초가 되는 컴퓨터 과학(결정적인 혹은 비결정적인 유한 오토마타)에 대한 자세한 설명은, 컴파일러 작성에 관한 거의 모든 교과서를 참조 할 수 있습니다.</p>
<div class="section" id="matching-characters">
<h3>문자 일치<a class="headerlink" href="#matching-characters" title="제목 주소">¶</a></h3>
<p>대부분 글자와 문자는 단순히 자신과 일치합니다. 예를 들어, 정규식 <code class="docutils literal notranslate"><span class="pre">test</span></code>는 문자열 <code class="docutils literal notranslate"><span class="pre">test</span></code>와 정확히 일치합니다. (이 RE가 <code class="docutils literal notranslate"><span class="pre">Test</span></code>나 <code class="docutils literal notranslate"><span class="pre">TEST</span></code>와 일치하도록 대/소문자를 구분하지 않는 모드를 활성화할 수 있습니다; 나중에 자세히 설명합니다.)</p>
<p>이 규칙에는 예외가 있습니다; 일부 문자는 특수한 <em class="dfn">메타 문자 (metacharacters)</em>이며, 자신과 일치하지 않습니다. 그 대신, 그들은 일반적이지 않은 것을 일치시켜야 한다는 신호를 보냅니다. 또는 반복하거나 의미를 바꾸어 RE의 다른 부분에 영향을 줍니다. 이 설명서의 많은 부분은 다양한 메타 문자와 그 기능에 대해 논의하는데 할애하고 있습니다.</p>
<p>다음은 메타 문자의 전체 목록입니다; 이것들의 의미는 이 HOWTO의 나머지 부분에서 논의될 것입니다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>. ^ $ * + ? { } [ ] \ | ( )
</pre></div>
</div>
<p>우리가 살펴볼 첫 번째 메타 문자는 <code class="docutils literal notranslate"><span class="pre">[</span></code>와 <code class="docutils literal notranslate"><span class="pre">]</span></code>입니다. 일치시키려는 문자 집합인 문자 클래스를 지정하는 데 사용됩니다. 문자는 개별적으로 나열되거나, 두 문자를 주고 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>로 구분하여 문자의 범위를 나타낼 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[abc]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">c</span></code> 문자와 일치합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">[a-c]</span></code>와 같은데, 같은 문자 집합을 표현하기 위해 범위를 사용합니다. 소문자들만 일치시키려면, RE가 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>가 됩니다.</p>
<p>메타 문자는 클래스 내부에서는 활성화되지 않습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[akm$]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'k'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'$'</span></code> 문자와 일치합니다; <code class="docutils literal notranslate"><span class="pre">'$'</span></code>는 대개 메타 문자이지만, 문자 클래스 안에서는 특수한 특성이 없어집니다.</p>
<p><em class="dfn">여집합 (complement set)</em>을 사용해서 클래스에 나열되지 않은 문자를 일치시킬 수 있습니다. 이것은 클래스의 첫 번째 문자로 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>를 포함하는 것으로 나타냅니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>를 제외한 모든 문자와 일치합니다. 캐럿이 문자 클래스의 다른 곳에 나타나면, 특별한 의미가 없습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[5^]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>와 일치합니다.</p>
<p>아마도 가장 중요한 메타 문자는 백 슬래시(<code class="docutils literal notranslate"><span class="pre">\</span></code>)입니다. 파이썬 문자열 리터럴에서와 같이, 백 슬래시 다음에 다양한 특수 시퀀스를 알리는 다양한 문자가 따라올 수 있습니다. 또한, 모든 메타 문자를 이스케이프 처리하여 패턴으로 일치시킬 수 있도록 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[</span></code>나 <code class="docutils literal notranslate"><span class="pre">\</span></code>와 일치시켜야 할 때, 특별한 의미를 제거하기 위해 앞에 백 슬래시를 붙일 수 있습니다: <code class="docutils literal notranslate"><span class="pre">\[</span></code>나 <code class="docutils literal notranslate"><span class="pre">\\</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">'\'</span></code>로 시작하는 특수 시퀀스 중 일부는 숫자(digit) 집합, 글자(letter) 집합 또는 공백이 아닌 모든 것의 집합과 같이 종종 유용한 미리 정의된 문자 집합을 나타냅니다.</p>
<p>예를 들어 보겠습니다: <code class="docutils literal notranslate"><span class="pre">\w</span></code>는 모든 영숫자(alphanumeric character)와 일치합니다. 정규식 패턴을 바이트열로 표현하면, 이것은 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> 클래스와 동등합니다. 정규식 패턴이 문자열이면, <code class="docutils literal notranslate"><span class="pre">\w</span></code>는 <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 모듈이 제공하는 유니코드 데이터베이스에서 글자(letter)로 표시된 모든 문자를 일치시킵니다. 정규식을 컴파일할 때 <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> 플래그를 제공하여 문자열 패턴에서 <code class="docutils literal notranslate"><span class="pre">\w</span></code>의 더 제한된 정의를 사용할 수 있습니다.</p>
<p>다음 특수 시퀀스 목록은 완전하지 않습니다. 유니코드 문자열 패턴에 대한 시퀀스와 확장 클래스 정의의 전체 목록은, 표준 라이브러리 레퍼런스에서 <a class="reference internal" href="../library/re.html#re-syntax"><span class="std std-ref">정규식 문법</span></a>의 마지막 부분을 참조하십시오. 일반적으로, 유니코드 버전은 유니코드 데이터베이스의 적절한 범주에 있는 모든 문자와 일치합니다.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><p>모든 십진 숫자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>모든 비 숫자 문자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><p>모든 공백 문자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> 와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>모든 비 공백 문자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code> 와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><p>모든 영숫자(alphanumeric character)와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>와 동등합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>모든 비 영숫자와 일치합니다; 이것은 클래스 <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>와 동등합니다.</p>
</dd>
</dl>
<p>이 시퀀스들은 문자 클래스 내에 포함될 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[\s,.]</span></code> 는 모든 공백 문자, <code class="docutils literal notranslate"><span class="pre">','</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'.'</span></code>와 일치하는 문자 클래스입니다.</p>
<p>이 절의 마지막 메타 문자는 <code class="docutils literal notranslate"><span class="pre">.</span></code>입니다. 개행 문자를 제외한 모든 문자와 일치하며, 개행 문자와도 일치하는 대체 모드(<a class="reference internal" href="../library/re.html#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.DOTALL</span></code></a>)가 있습니다. <code class="docutils literal notranslate"><span class="pre">.</span></code> 은 &quot;모든 문자&quot;와 일치시키려고 할 때 자주 사용됩니다.</p>
</div>
<div class="section" id="repeating-things">
<h3>반복하기<a class="headerlink" href="#repeating-things" title="제목 주소">¶</a></h3>
<p>다양한 문자 집합을 일치시킬 수 있다는 것이 문자열에서 사용할 수 있는 메서드로 이미 가능하지 않은 것을 정규식이 수행할 수 있는 첫 번째 것입니다. 그러나, 이것이 정규식의 유일한 추가 기능이라면, 그다지 진보했다고 할 수 없습니다. 또 다른 기능은 RE의 일부가 특정 횟수만큼 반복되어야 한다고 지정할 수 있다는 것입니다.</p>
<p>우리가 살펴볼 반복을 위한 첫 번째 메타 문자는 <code class="docutils literal notranslate"><span class="pre">*</span></code>입니다. <code class="docutils literal notranslate"><span class="pre">*</span></code>는 리터럴 문자 <code class="docutils literal notranslate"><span class="pre">'*'</span></code>와 일치하지 않습니다; 대신 이전 문자를 정확히 한 번이 아닌 0번 이상 일치시킬 수 있도록 지정합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">ca*t</span></code>는 <code class="docutils literal notranslate"><span class="pre">'ct'</span></code> (0개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자), <code class="docutils literal notranslate"><span class="pre">'cat'</span></code> (1개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>), <code class="docutils literal notranslate"><span class="pre">'caaat'</span></code> (3개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자) 등과 일치합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">*</span></code>와 같은 반복은 <em class="dfn">탐욕스럽습니다 (greedy)</em>; RE를 반복할 때, 일치 엔진은 가능한 한 여러 번 반복하려고 시도합니다. 패턴의 뒷부분이 일치하지 않으면, 일치 엔진은 되돌아가서 더 작은 반복으로 다시 시도합니다.</p>
<p>단계별 예제를 통해 더 명확하게 알 수 있습니다. 정규식 <code class="docutils literal notranslate"><span class="pre">a[bcd]*b</span></code>를 생각해 봅시다. 이 문자는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치하고, 0개 이상의 <code class="docutils literal notranslate"><span class="pre">[bcd]</span></code> 클래스 문자가 뒤따르고, 마지막에 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>로 끝납니다. 이제 이 RE를 문자열 <code class="docutils literal notranslate"><span class="pre">'abcbd'</span></code>와 일치시킨다고 상상해보십시오.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 22%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>단계</p></th>
<th class="head"><p>일치된 것</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p>RE의 <code class="docutils literal notranslate"><span class="pre">a</span></code>가 일치합니다.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcbd</span></code></p></td>
<td><p>엔진은 가능한 한 길게 <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>와 일치시키려고 문자열의 끝까지 갑니다.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><em>실패</em></p></td>
<td><p>엔진은 <code class="docutils literal notranslate"><span class="pre">b</span></code>를 일치하려고 시도하지만, 현재 위치가 문자열의 끝이므로 실패합니다.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcb</span></code></p></td>
<td><p>물러서서, <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>가 하나 적은 문자와 일치합니다.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p><em>실패</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">b</span></code>를 다시 시도하지만, 현재 위치는 <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 인 마지막 문자에 있습니다.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abc</span></code></p></td>
<td><p>다시 물러서서, <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>가 <code class="docutils literal notranslate"><span class="pre">bc</span></code>하고 만 일치합니다.</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcb</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">b</span></code>를 다시 시도합니다. 이번에는 현재 위치의 문자가 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>이므로 성공합니다.</p></td>
</tr>
</tbody>
</table>
<p>RE의 끝에 도달했으며, <code class="docutils literal notranslate"><span class="pre">'abcb'</span></code>와 일치했습니다. 이것은 일치 엔진이 처음에는 갈 수 있는 데까지 가본 다음, 일치하는 것이 발견되지 않으면 점진적으로 물러서고, 나머지 RE의 나머지 부분을 반복해서 다시 시도하는 것을 보여줍니다. <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>에 대한 일치 항목의 길이가 0이 될 때까지 물러서고, 그것마저도 실패하면, 엔진은 문자열이 RE와 전혀 일치하지 않는다고 결론을 내립니다.</p>
<p>또 다른 반복 메타 문자는 <code class="docutils literal notranslate"><span class="pre">+</span></code>인 데, 하나 이상과 일치합니다. <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">+</span></code>의 차이점에 주의하십시오; <code class="docutils literal notranslate"><span class="pre">*</span></code>는 <em>0</em> 이상과 일치하므로, 반복되는 내용이 전혀 표시되지 않을 수 있습니다. 반면 <code class="docutils literal notranslate"><span class="pre">+</span></code>는 적어도 <em>1</em>번 이상 나타날 것을 요구합니다. 비슷한 예제를 사용하면, <code class="docutils literal notranslate"><span class="pre">ca+t</span></code>는 <code class="docutils literal notranslate"><span class="pre">'cat'</span></code> (1 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>), <code class="docutils literal notranslate"><span class="pre">'caaat'</span></code> (3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>)와 일치하지만 <code class="docutils literal notranslate"><span class="pre">'ct'</span></code>와 일치하지는 않습니다.</p>
<p>반복 한정자(qualifier)가 두 개 더 있습니다. 물음표 문자 <code class="docutils literal notranslate"><span class="pre">?</span></code>는 한 번이나 0번 일치합니다; 무언가를 선택적이라고 표시한다고 생각해도 좋습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">home-?brew</span></code>는 <code class="docutils literal notranslate"><span class="pre">'homebrew'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'home-brew'</span></code>와 일치합니다.</p>
<p>가장 복잡한 반복 한정자는 <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>입니다. 여기서 <em>m</em>과 <em>n</em>은 십진수입니다. 이 한정자는 적어도 <em>m</em> 반복, 최대 <em>n</em> 반복이 있어야 함을 의미합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a/{1,3}b</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a/b'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a//b'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'a///b'</span></code>와 일치합니다. <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>에는 슬래시가 없어서 일치하지 않고, <code class="docutils literal notranslate"><span class="pre">'a////b'</span></code>에는 4개 있어서 일치하지 않습니다.</p>
<p><em>m</em>이나 <em>n</em>을 생략 할 수 있습니다; 이때, 빠진 값에 대해 합리적인 값이 가정됩니다. <em>m</em>을 생략하면 0 하한으로 해석하는 반면, <em>m</em>을 생략하면 무한대의 상한을 뜻합니다.</p>
<p>환원주의로 기울어진 독자는 다른 세 한정자들을 이 표기법을 사용하여 표현할 수 있음을 알아챌 수 있을 겁니다. <code class="docutils literal notranslate"><span class="pre">{0,}</span></code>은 <code class="docutils literal notranslate"><span class="pre">*</span></code>와 같고, <code class="docutils literal notranslate"><span class="pre">{1,}</span></code>은 <code class="docutils literal notranslate"><span class="pre">+</span></code>와 같으며, <code class="docutils literal notranslate"><span class="pre">{0,1}</span></code>은 <code class="docutils literal notranslate"><span class="pre">?</span></code>와 같습니다. 그럴 수 있다면 <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">?</span></code>를 사용하는 것이 좋은데, 더 짧고 읽기 쉽기 때문입니다.</p>
</div>
</div>
<div class="section" id="using-regular-expressions">
<h2>정규식 사용하기<a class="headerlink" href="#using-regular-expressions" title="제목 주소">¶</a></h2>
<p>이제 간단한 정규식을 살펴보았습니다. 실제로 파이썬에서 어떻게 사용해야 할까요? <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈은 정규식 엔진에 대한 인터페이스를 제공해서, RE를 객체로 컴파일한 다음 일치를 수행 할 수 있도록 합니다.</p>
<div class="section" id="compiling-regular-expressions">
<h3>정규식 컴파일하기<a class="headerlink" href="#compiling-regular-expressions" title="제목 주소">¶</a></h3>
<p>정규식은 패턴 객체로 컴파일되는데, 패턴 일치를 검색하거나 문자열 치환을 수행하는 등의 다양한 작업을 위한 메서드를 갖고 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">re.compile(&#39;ab*&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>은 다양한 특수 기능과 문법 변형을 가능하게 하는 선택적 <em>flags</em> 인자도 받아들입니다. 나중에 사용할 수 있는 설정을 살펴보도록 하겠지만, 지금은 한 가지 예 만 보겠습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
</pre></div>
</div>
<p>RE는 문자열로 <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>에 전달됩니다. 정규식이 핵심 파이썬 언어의 일부가 아니고, 정규식을 표현하기 위한 특수 문법이 만들어지지 않았기 때문에 RE는 문자열로 다뤄집니다. (RE를 전혀 필요로하지 않는 응용 프로그램이 있기 때문에, 이를 포함해서 언어 사양을 부풀릴 필요가 없습니다.) 대신, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈은 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>이나 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈과 마찬가지로 파이썬에 포함된 C 확장 모듈일 뿐입니다.</p>
<p>RE를 문자열에 넣는 것은 파이썬 언어가 더 간단하게 유지되도록 하지만, 다음 절의 주제인 한 가지 단점이 있습니다.</p>
</div>
<div class="section" id="the-backslash-plague">
<span id="id1"></span><h3>백 슬래시 전염병<a class="headerlink" href="#the-backslash-plague" title="제목 주소">¶</a></h3>
<p>앞에서 언급한 것처럼, 정규식은 백 슬래시 문자(<code class="docutils literal notranslate"><span class="pre">'\'</span></code>)를 사용하여 특수 형식을 나타내거나 특수 문자 특별한 의미를 갖지 않고 사용되도록 합니다. 이것은 파이썬이 문자열 리터럴에서 같은 목적으로 같은 문자를 사용하는 것과 충돌합니다.</p>
<p>LaTeX 파일에서 발견되는 문자열 <code class="docutils literal notranslate"><span class="pre">\section</span></code>과 일치하는 RE를 작성한다고 가정해 봅시다. 프로그램 코드에 무엇을 쓸지 알아내기 위해, 일치시키고자 하는 문자열로 시작하십시오. 그런 다음, 백 슬래시와 다른 메타 문자 앞에 백 슬래시를 붙여 이스케이프 처리하면, 문자열 <code class="docutils literal notranslate"><span class="pre">\\section</span></code>을 얻게 됩니다. <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>에 전달되어야 하는 결과 문자열은 <code class="docutils literal notranslate"><span class="pre">\\section</span></code>이어야 합니다. 그러나, 이를 파이썬 문자열 리터럴로 표현하려면, 두 개의 백 슬래시를 모두 <em>다시</em> 이스케이프 처리해야 합니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>문자</p></th>
<th class="head"><p>단계</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\section</span></code></p></td>
<td><p>일치시킬 텍스트 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\section</span></code></p></td>
<td><p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>을 위해 이스케이프 처리된 백 슬래시</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\\\section&quot;</span></code></p></td>
<td><p>문자열 리터럴을 위해 이스케이프 처리된 백 슬래시</p></td>
</tr>
</tbody>
</table>
<p>즉, 리터럴 백 슬래시와 일치시키려면, RE 문자열로 <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code>을 작성해야 하는데, 정규식은 <code class="docutils literal notranslate"><span class="pre">\\</span></code>이어야하고, 일반 파이썬 문자열 리터럴 안에서 각 백 슬래시를 <code class="docutils literal notranslate"><span class="pre">\\</span></code>로 표현해야 하기 때문입니다. 백 슬래시를 반복적으로 사용하는 RE에서는, 수없이 반복되는 백 슬래시로 이어져, 결과 문자열을 이해하기 어렵게 만듭니다.</p>
<p>해결책은 정규식에 파이썬의 날 문자열 표기법을 사용하는 것입니다; 백 슬래시는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 접두사가 붙은 문자열 리터럴에서 특별한 방법으로 처리되지 않아서, <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code>는 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'n'</span></code>을 포함하는 두 문자 문자열이지만, <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>는 줄 넘김을 포함하는 한 문자 문자열입니다. 정규식은 종종 이 날 문자열 표기법을 사용하여 파이썬 코드로 작성됩니다.</p>
<p>또한, 정규식에서는 유효하지만, 파이썬 문자열 리터럴에서는 유효하지 않은 특수 이스케이프 시퀀스는 이제 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 발생시키고 결국에는 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>가 될 것입니다. 이는 날 문자열 표기법이나 백 슬래시 이스케이핑이 사용되지 않으면 시퀀스가 유효하지 않게 됨을 뜻합니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>일반 문자열</p></th>
<th class="head"><p>날 문자열</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;ab*&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;ab*&quot;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\\\section&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;\\section&quot;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\w+\\s+\\1&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;\w+\s+\1&quot;</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="performing-matches">
<h3>일치 수행하기<a class="headerlink" href="#performing-matches" title="제목 주소">¶</a></h3>
<p>일단 컴파일된 정규식을 나타내는 객체가 있으면, 이것으로 무엇을 할까요? 패턴 객체에는 여러 가지 메서드와 어트리뷰트가 있습니다. 가장 중요한 것만 여기서 다루어집니다; 전체 목록을 보려면 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 설명서를 참조하십시오.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드/어트리뷰트</p></th>
<th class="head"><p>목적</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">match()</span></code></p></td>
<td><p>문자열의 시작 부분에서 RE가 일치하는지 판단합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">search()</span></code></p></td>
<td><p>이 RE가 일치하는 위치를 찾으면서, 문자열을 훑습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">findall()</span></code></p></td>
<td><p>RE가 일치하는 모든 부분 문자열을 찾아 리스트로 반환합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">finditer()</span></code></p></td>
<td><p>RE가 일치하는 모든 부분 문자열을 찾아 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>로 반환합니다.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>와 <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>는 일치하는 항목이 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 성공하면, <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 인스턴스가 반환되고, 일치에 대한 정보가 들어 있습니다: 어디에서 시작하고 끝나는지, 일치하는 부분 문자열 등입니다.</p>
<p><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈로 대화식으로 실험해보면 알 수 있습니다. <a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a>를 사용할 수 있다면, 파이썬 배포판에 포함된 데모 프로그램인 <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Tools/demo/redemo.py">Tools/demo/redemo.py</a>를 살펴볼 수도 있습니다. RE와 문자열을 입력하면, RE가 일치하는지 실패하는지 표시합니다. <code class="file docutils literal notranslate"><span class="pre">redemo.py</span></code>는 복잡한 RE를 디버깅할 때 매우 유용 할 수 있습니다.</p>
<p>이 HOWTO는 예제에 표준 파이썬 인터프리터를 사용합니다. 먼저, 파이썬 인터프리터를 실행하고, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈을 임포트 한 다음, RE를 컴파일하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">re.compile(&#39;[a-z]+&#39;)</span>
</pre></div>
</div>
<p>이제, 다양한 문자열을 RE <code class="docutils literal notranslate"><span class="pre">[a-z]+</span></code>와 일치시켜볼 수 있습니다. <code class="docutils literal notranslate"><span class="pre">+</span></code>는 '하나 이상의 반복'을 의미하므로, 빈 문자열은 전혀 일치하지 않아야 합니다. 이때 <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야 하며, 인터프리터는 출력을 인쇄하지 않습니다. 분명하게 하기 위해 <code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code>의 결과를 명시적으로 인쇄 할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>이제, 일치해야 하는 문자열을 시도해 봅시다, 가령 <code class="docutils literal notranslate"><span class="pre">tempo</span></code>. 이때, <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>는 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환하므로, 나중에 사용할 수 있도록 결과를 변수에 저장해야 합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;tempo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;re.Match object; span=(0, 5), match=&#39;tempo&#39;&gt;</span>
</pre></div>
</div>
<p>이제 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a>를 조회하여 일치하는 문자열에 대한 정보를 얻을 수 있습니다. 일치 객체 인스턴스에는 여러 메서드와 어트리뷰트가 있습니다; 가장 중요한 것들은 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드/어트리뷰트</p></th>
<th class="head"><p>목적</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">group()</span></code></p></td>
<td><p>RE와 일치하는 문자열을 반환합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">start()</span></code></p></td>
<td><p>일치의 시작 위치를 반환합니다</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">end()</span></code></p></td>
<td><p>일치의 끝 위치를 반환합니다</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">span()</span></code></p></td>
<td><p>일치의 (시작, 끝) 위치를 포함하는 튜플을 반환합니다.</p></td>
</tr>
</tbody>
</table>
<p>이 메서드를 실험해보면 곧 그 의미가 분명해질 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;tempo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(0, 5)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>은 RE에 의해 일치된 부분 문자열을 반환합니다. <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>와 <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end()</span></code></a>는 일치의 시작과 끝 인덱스를 반환합니다. <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">span()</span></code></a>은 시작과 끝 인덱스를 단일 튜플로 반환합니다. <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 메서드는 문자열의 시작 부분에서 RE가 일치하는지 검사하므로, <code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code>는 항상 0입니다. 그러나, 패턴의 <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드는 문자열을 훑기 때문에, 일치가 0에서 시작하지 않을 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(4, 11), match=&#39;message&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(4, 11)</span>
</pre></div>
</div>
<p>실제 프로그램에서, 가장 일반적인 스타일은 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a>를 변수에 저장한 다음, <code class="docutils literal notranslate"><span class="pre">None</span></code>인지 확인하는 것입니다. 보통 이런 식입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span> <span class="s1">&#39;string goes here&#39;</span> <span class="p">)</span>
<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Match found: &#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>두 패턴 메서드는 패턴에 대한 모든 일치를 반환합니다. <a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a>은 일치하는 문자열 리스트를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#39;</span><span class="p">)</span>
<span class="go">[&#39;12&#39;, &#39;11&#39;, &#39;10&#39;]</span>
</pre></div>
</div>
<p>이 예제에서는 리터럴을 날 문자열 리터럴로 만드는 <code class="docutils literal notranslate"><span class="pre">r</span></code> 접두어가 필요한데, 일반적인 &quot;요리된(cooked)&quot; 문자열 리터럴에 있는, 정규식에서는 허락되지만, 파이썬에서 인식하지 못하는, 이스케이프 시퀀스가 이제 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 발생시키고, 결국에는 결국 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>가 될 것이기 때문입니다. <a class="reference internal" href="#the-backslash-plague"><span class="std std-ref">백 슬래시 전염병</span></a>를 참조하십시오.</p>
<p><a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a>은 결과로 반환하기 전에 전체 리스트를 만들어야 합니다. <a class="reference internal" href="../library/re.html#re.Pattern.finditer" title="re.Pattern.finditer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code></a> 메서드는 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">매치 객체</span></a> 인스턴스의 시퀀스를 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>로 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 ... 10 ...&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span>  
<span class="go">&lt;callable_iterator object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">(0, 2)</span>
<span class="go">(22, 24)</span>
<span class="go">(29, 31)</span>
</pre></div>
</div>
</div>
<div class="section" id="module-level-functions">
<h3>모듈 수준 함수<a class="headerlink" href="#module-level-functions" title="제목 주소">¶</a></h3>
<p>패턴 객체를 생성하고 메서드를 호출해야만 하는 것은 아닙니다; <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈은 <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>, <a class="reference internal" href="../library/re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 등의 최상위 수준 함수도 제공합니다. 이 함수들은 첫 번째 인자로 RE 문자열이 추가된 해당 패턴 메서드와 같은 인자를 취하고, 여전히 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 인스턴스를 반환합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;Fromage amk&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;From amk Thu May 14 19:12:10 1998&#39;</span><span class="p">)</span>  
<span class="go">&lt;re.Match object; span=(0, 5), match=&#39;From &#39;&gt;</span>
</pre></div>
</div>
<p>내부적으로, 이 함수는 단순히 패턴 객체를 만들고 적절한 메서드를 호출합니다. 또한 컴파일된 객체를 캐시에 저장하므로, 같은 RE를 사용하는 이후의 호출에서는 패턴을 반복해서 구문 분석할 필요가 없습니다.</p>
<p>이러한 모듈 수준의 함수를 사용해야 할까요, 아니면 패턴을 얻어서 메서드를 직접 호출해야 할까요? 루프 내에서 정규식에 액세스하고 있다면, 사전 컴파일이 몇 번의 함수 호출을 절약할 수 있습니다. 루프 바깥에서는, 내부 캐시 덕분에 큰 차이가 없습니다.</p>
</div>
<div class="section" id="compilation-flags">
<h3>컴파일 플래그<a class="headerlink" href="#compilation-flags" title="제목 주소">¶</a></h3>
<p>컴파일 플래그를 사용하면 정규식의 작동 방식을 수정할 수 있습니다. 플래그는 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈에서 <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code>와 같은 긴 이름과 <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code>와 같은 간단한 한 글자 형식의 두 가지 이름으로 사용 가능합니다. (Perl의 패턴 수정자에 익숙하다면, 한 글자 형식은 같은 글자를 사용합니다; 예를 들어, <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>의 짧은 형식은 <a class="reference internal" href="../library/re.html#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a>입니다.) 다중 플래그는 비트별 OR 하여 지정할 수 있습니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">re.I</span> <span class="pre">|</span> <span class="pre">re.M</span></code>은 <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code>와 <code class="xref py py-const docutils literal notranslate"><span class="pre">M</span></code> 플래그를 모두 설정합니다.</p>
<p>다음은 사용 가능한 플래그와 각 플래그에 대한 자세한 설명입니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>플래그</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">A</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> 및 <code class="docutils literal notranslate"><span class="pre">\d</span></code>와 같은 여러 이스케이프가 해당 속성이 있는 ASCII 문자에만 일치하도록 합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">S</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code>가 개행 문자를 포함한 모든 문자와 일치하도록 합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code></p></td>
<td><p>대소 문자 구분 없는 일치를 수행합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p>로케일을 고려하는 일치를 수행합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">M</span></code></p></td>
<td><p>다중 행 일치, <code class="docutils literal notranslate"><span class="pre">^</span></code>와 <code class="docutils literal notranslate"><span class="pre">$</span></code>에 영향을 줍니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">VERBOSE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">X</span></code> ('확장' 용)</p></td>
<td><p>더 명확하고 이해하기 쉽게 정리될 수 있는 상세한 RE를 활성화합니다.</p></td>
</tr>
</tbody>
</table>
<dl class="data">
<dt>
<code class="sig-name descname">I</code></dt>
<dt>
<code class="sig-name descname">IGNORECASE</code></dt>
<dd><p>대소 문자를 구분하지 않는 일치를 수행합니다; 문자 클래스와 리터럴 문자열은 대소 문자를 무시하여 문자와 일치합니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code>는 소문자와도 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code> 플래그로 ASCII가 아닌 일치를 막지 않는 한, 전체 유니코드 일치도 작동합니다. 유니코드 패턴 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>나 <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code>가 <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code> 플래그와 함께 사용되면, 52 ASCII 문자와 4개의 추가 비 ASCII 문자와 일치합니다: 'İ' (U+0130, 위에 점이 있는 라틴 대문자 I), 'ı' (U+0131, 라틴 소문자 점 없는 i), 'ſ' (U+017F, 라틴 소문자 긴 s) 및 'K' (U+212A, 켈빈 기호). <code class="docutils literal notranslate"><span class="pre">Spam</span></code>은 <code class="docutils literal notranslate"><span class="pre">'Spam'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spam'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spAM'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'ſpam'</span></code>과 일치합니다 (마지막은 유니코드 모드에서만 일치합니다). 이 소문자화는 현재 로케일을 고려하지 않습니다; 고려하려면 <code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code> 플래그를 설정하면 됩니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-name descname">L</code></dt>
<dt>
<code class="sig-name descname">LOCALE</code></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> 및 대소 문자를 구분하지 않는 일치를 유니코드 데이터베이스 대신 현재 로케일에 의존하도록 만듭니다.</p>
<p>로케일은 언어 차이를 고려한 프로그램을 작성하는 데 도움이 되는 C 라이브러리의 기능입니다. 예를 들어, 인코딩된 프랑스어 텍스트를 처리할 때, 단어와 일치하도록 <code class="docutils literal notranslate"><span class="pre">\w+</span></code>를 쓰고 싶습니다, 하지만 <code class="docutils literal notranslate"><span class="pre">\w</span></code>는 바이트열 패턴에서 <code class="docutils literal notranslate"><span class="pre">[A-Za-z]</span></code> 문자 클래스하고만 일치합니다; <code class="docutils literal notranslate"><span class="pre">é</span></code>나 <code class="docutils literal notranslate"><span class="pre">ç</span></code>에 해당하는 바이트는 일치하지 않습니다. 시스템이 올바르게 구성되고 프랑스어 로케일이 선택되면, 특정 C 함수는 <code class="docutils literal notranslate"><span class="pre">é</span></code>에 해당하는 바이트도 문자로 간주하여야 함을 프로그램에 알립니다. 정규식을 컴파일할 때 <code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code> 플래그를 설정하면, 컴파일된 결과 객체가 <code class="docutils literal notranslate"><span class="pre">\w</span></code>에 대해 이러한 C 함수를 사용하게 됩니다; 더 느리기는 하지만, 기대하는 대로 <code class="docutils literal notranslate"><span class="pre">\w+</span></code>가 프랑스어 단어를 일치시킬 수 있습니다. 이 플래그의 사용은 파이썬 3에서는 권장하지 않는데, 로케일 메커니즘이 매우 신뢰성이 떨어지고, 한 번에 하나의 &quot;컬처(culture)&quot; 만 처리하고, 8비트 로케일에서 만 작동하기 때문입니다. 파이썬 3에서 유니코드 (str) 패턴에 대해 유니코드 일치가 기본적으로 이미 활성화되어 있으며, 다른 로케일/언어를 처리할 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-name descname">M</code></dt>
<dt>
<code class="sig-name descname">MULTILINE</code></dt>
<dd><p>(<code class="docutils literal notranslate"><span class="pre">^</span></code>과 <code class="docutils literal notranslate"><span class="pre">$</span></code>는 아직 설명되지 않았습니다; <a class="reference internal" href="#more-metacharacters"><span class="std std-ref">메타 문자 더 보기</span></a> 절에서 소개될 예정입니다.)</p>
<p>보통 <code class="docutils literal notranslate"><span class="pre">^</span></code>는 문자열의 시작 부분에서만 일치하고, <code class="docutils literal notranslate"><span class="pre">$</span></code>는 문자열의 끝부분과 문자열 끝에 있는 줄 바꿈 (있다면) 바로 앞에서 일치합니다. 이 플래그를 지정하면 <code class="docutils literal notranslate"><span class="pre">^</span></code>는 문자열 시작 부분과 문자열 내의 각 줄 시작 부분(각 줄 바꿈의 바로 뒤)에서 일치합니다. 비슷하게, <code class="docutils literal notranslate"><span class="pre">$</span></code> 메타 문자는 문자열 끝과 각 줄의 끝(각 줄 바꿈 바로 앞)에서 일치합니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-name descname">S</code></dt>
<dt>
<code class="sig-name descname">DOTALL</code></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'.'</span></code> 특수 문자가 개행 문자를 포함하는 모든 문자와 일치하도록 만듭니다; 이 플래그가 없으면, <code class="docutils literal notranslate"><span class="pre">'.'</span></code>는 개행 문자를 <em>제외한</em> 모든 문자와 일치합니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-name descname">A</code></dt>
<dt>
<code class="sig-name descname">ASCII</code></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> 및 <code class="docutils literal notranslate"><span class="pre">\S</span></code>가 전체 유니코드 일치 대신 ASCII 전용 일치를 수행하도록 만듭니다. 유니코드 패턴에서만 의미가 있으며, 바이트열 패턴에서는 무시됩니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-name descname">X</code></dt>
<dt>
<code class="sig-name descname">VERBOSE</code></dt>
<dd><p>이 플래그는 정규식을 포매팅하는 더 유연한 방법을 제공해서 더 가독성 있는 정규식을 작성할 수 있도록 합니다. 이 플래그가 지정되면, 문자 클래스에 있거나 이스케이프 되지 않은 백 슬래시 뒤에 있을 때를 제외하고, RE 문자열 내의 공백을 무시합니다; 이것은 RE를 보다 명확하게 구성하고 들여쓰기 할 수 있도록 합니다. 이 플래그는 RE 내에 엔진이 무시하는 주석을 넣을 수도 있게 합니다; 주석은 문자 클래스나 이스케이프 처리되지 않은 백 슬래시 뒤에 있지 않은 <code class="docutils literal notranslate"><span class="pre">'#'</span></code>로 표시됩니다.</p>
<p>예를 들어, 여기에 <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>를 사용하는 RE가 있습니다; 얼마다 더 읽기 쉬워지는지 보이십니까?</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> &amp;[#]                # 숫자 엔티티 참조의 시작</span>
<span class="s2"> (</span>
<span class="s2">     0[0-7]+         # 8진수 형식</span>
<span class="s2">   | [0-9]+          # 십진수 형식</span>
<span class="s2">   | x[0-9a-fA-F]+   # 16진수 형식</span>
<span class="s2"> )</span>
<span class="s2"> ;                   # 후행 세미콜론</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
</pre></div>
</div>
<p>상세 설정이 없으면, RE는 이렇게 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;&amp;#(0[0-7]+&quot;</span>
                     <span class="s2">&quot;|[0-9]+&quot;</span>
                     <span class="s2">&quot;|x[0-9a-fA-F]+);&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>위의 예에서, 파이썬의 문자열 리터럴 자동 이어붙이기를 사용해서 RE를 더 작은 조각으로 나누었지만, <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>를 사용하는 버전보다 여전히 이해하기가 어렵습니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="more-pattern-power">
<h2>더 많은 패턴 기능<a class="headerlink" href="#more-pattern-power" title="제목 주소">¶</a></h2>
<p>지금까지 정규식의 일부 기능에 관해서만 설명했습니다. 이 절에서는, 몇 가지 새로운 메타 문자와 그룹을 사용하여 일치하는 텍스트의 부분을 꺼내는 방법을 다룹니다.</p>
<div class="section" id="more-metacharacters">
<span id="id2"></span><h3>메타 문자 더 보기<a class="headerlink" href="#more-metacharacters" title="제목 주소">¶</a></h3>
<p>우리가 아직 다루지 않은 몇 가지 메타 문자가 있습니다. 대부분 이 절에서 다룰 것입니다.</p>
<p>논의할 나머지 메타 문자 중 일부는 <em class="dfn">폭이 없는 어서션(zero-width assertions)</em>입니다. 이들은 엔진이 문자열을 통해 앞으로 나아가도록 하지 않습니다; 대신, 문자를 전혀 소비하지 않고, 단순히 성공하거나 실패합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 현재 위치가 단어 경계에 위치한다는 어서션입니다; 위치는 <code class="docutils literal notranslate"><span class="pre">\b</span></code>에 의해 전혀 변경되지 않습니다. 이것은 폭이 없는 어서션을 반복해서는 안 된다는 뜻인데, 주어진 위치에서 일단 일치하면 명백히 무한한 횟수만큼 일치 할 수 있기 때문입니다.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p>대안, 또는 &quot;or&quot; 연산자. <em>A</em>와 <em>B</em>가 정규식이면, <code class="docutils literal notranslate"><span class="pre">A|B</span></code>는 <em>A</em>나 <em>B</em>와 일치하는 문자열과 일치합니다. <code class="docutils literal notranslate"><span class="pre">|</span></code>는 여러 문자로 된 문자열의 대안을 사용할 때 합리적으로 작동하도록 하기 위해 우선순위가 매우 낮습니다. <code class="docutils literal notranslate"><span class="pre">Crow|Servo</span></code>는 <code class="docutils literal notranslate"><span class="pre">'Crow'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'Servo'</span></code>와 일치합니다, <code class="docutils literal notranslate"><span class="pre">'Cro'</span></code>, <code class="docutils literal notranslate"><span class="pre">'w'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'S'</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">'ervo'</span></code>가 아닙니다.</p>
<p>리터럴 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\|</span></code>를 사용하거나 <code class="docutils literal notranslate"><span class="pre">[|]</span></code> 처럼 문자 클래스 안에 넣으십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>줄의 시작 부분에 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 플래그가 설정되어 있지 않은 한, 문자열 시작 부분에서만 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 모드에서는, 문자열 내의 각 줄 바꿈 바로 뒤에서도 일치합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">From</span></code>이라는 단어를 줄의 시작 부분에서만 일치시키려면, 사용할 RE는 <code class="docutils literal notranslate"><span class="pre">^From</span></code>입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^From&#39;</span><span class="p">,</span> <span class="s1">&#39;From Here to Eternity&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39;From&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^From&#39;</span><span class="p">,</span> <span class="s1">&#39;Reciting From Memory&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>리터럴 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\^</span></code>를 사용하십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>줄의 끝부분과 일치하는데, 문자열의 끝이나 줄 바꿈 문자 다음에 오는 모든 위치로 정의됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="s1">&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(6, 7), match=&#39;}&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="s1"> &#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(6, 7), match=&#39;}&#39;&gt;</span>
</pre></div>
</div>
<p>리터럴 <code class="docutils literal notranslate"><span class="pre">'$'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\$</span></code>를 사용하거나 <code class="docutils literal notranslate"><span class="pre">[$]</span></code> 처럼 문자 클래스 안에 넣으십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>문자열의 시작 부분에서만 일치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 모드가 아닐 때, <code class="docutils literal notranslate"><span class="pre">\A</span></code>와 <code class="docutils literal notranslate"><span class="pre">^</span></code>는 실질적으로 같습니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> 모드에서는, 다릅니다: <code class="docutils literal notranslate"><span class="pre">\A</span></code>는 여전히 문자열의 시작 부분에서만 일치하지만, <code class="docutils literal notranslate"><span class="pre">^</span></code>는 문자열 내의 줄 바꿈 문자 뒤에 오는 모든 위치에서 일치 할 수 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>문자열 끝부분에서만 일치합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>단어 경계. 이것은 단어(word)의 시작이니 끝부분에서만 일치하는 폭이 없는 어서션입니다. 단어는 영숫자 문자의 시퀀스로 정의되므로, 단어의 끝은 공백이나 영숫자가 아닌 문자로 표시됩니다.</p>
<p>다음 예제는 완전한 단어일 때만 <code class="docutils literal notranslate"><span class="pre">class</span></code>와 일치합니다. 다른 단어 안에 포함되어 있으면 일치하지 않습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bclass\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;no class at all&#39;</span><span class="p">))</span>
<span class="go">&lt;re.Match object; span=(3, 8), match=&#39;class&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;the declassified algorithm&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;one subclass is&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>이 특수 시퀀스를 사용할 때 기억해야 할 두 가지 미묘한 점이 있습니다. 첫째, 이것은 파이썬의 문자열 리터럴과 정규식 시퀀스 간의 최악의 충돌입니다. 파이썬의 문자열 리터럴에서 <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 ASCII 값 8을 갖는 백스페이스 문자입니다. 날 문자열을 사용하지 않으면, 파이썬이 <code class="docutils literal notranslate"><span class="pre">\b</span></code>를 백스페이스로 변환하고, 여러분의 RE는 예상대로 일치하지 않습니다. 다음 예제는 앞의 RE와 같아 보이지만, RE 문자열 앞의 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>가 빠졌습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">class</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;no class at all&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;class&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="go">&lt;re.Match object; span=(0, 7), match=&#39;\x08class\x08&#39;&gt;</span>
</pre></div>
</div>
<p>둘째, 이 어서선이 사용되지 않는 문자 클래스 내에서, <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 파이썬의 문자열 리터럴과의 호환성을 위해 백스페이스 문자를 나타냅니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>또 다른 폭이 없는 어서션, 이것은 <code class="docutils literal notranslate"><span class="pre">\b</span></code>의 반대이며, 현재 위치가 단어 경계에 있지 않을 때만 일치합니다.</p>
</dd>
</dl>
</div>
<div class="section" id="grouping">
<h3>그룹<a class="headerlink" href="#grouping" title="제목 주소">¶</a></h3>
<p>종종 단지 RE가 일치하는지보다 많은 정보를 얻을 필요가 있습니다. 정규식은 종종 관심 있는 다른 구성 요소와 일치하는 몇 개의 서브 그룹으로 나누어진 RE를 작성하여 문자열을 해부하는 데 사용됩니다. 예를 들어, RFC-822 헤더 행은 다음과 같이 <code class="docutils literal notranslate"><span class="pre">':'</span></code>로 구분된 헤더 이름과 값으로 나뉩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>From: author@example.com
User-Agent: Thunderbird 1.5.0.9 (X11/20061227)
MIME-Version: 1.0
To: editor@example.com
</pre></div>
</div>
<p>이것은 전체 헤더 행과 일치하는 정규식을 작성하고, 헤더 이름과 일치하는 그룹 하나와 헤더 값과 일치하는 다른 그룹을 가짐으로써 처리 할 수 있습니다.</p>
<p>그룹은 <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">')'</span></code> 메타 문자로 표시됩니다. <code class="docutils literal notranslate"><span class="pre">'('</span></code>와 <code class="docutils literal notranslate"><span class="pre">')'</span></code>는 수학적 표현에서와 거의 같은 의미가 있습니다; 내부에 포함된 표현식을 함께 묶고, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>과 같은 반복 한정자로 그룹의 내용을 반복 할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(ab)*</span></code>는 <code class="docutils literal notranslate"><span class="pre">ab</span></code>를 0번 이상 반복한 것에 일치합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(ab)*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;ababababab&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 10)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">')'</span></code>로 표시된 그룹은 일치하는 텍스트의 시작과 끝 인덱스도 포착합니다; 이것은 <a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>, <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end()</span></code></a> 및 <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">span()</span></code></a>에 인자를 전달하여 꺼낼 수 있습니다. 그룹은 0부터 시작하여 번호가 매겨집니다. 그룹 0은 항상 존재합니다; 이것은 전체 RE이므로 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 메서드는 모두 그룹 0을 기본 인자로 사용합니다. 나중에 일치하는 텍스트 범위를 포착하지 않는 그룹을 표현하는 방법을 살펴보겠습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(a)b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;ab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>서브 그룹은 왼쪽에서 오른쪽으로 1부터 위로 번호가 매겨집니다. 그룹은 중첩될 수 있습니다; 숫자를 결정하려면, 왼쪽에서 오른쪽으로 가면서 여는 괄호 문자를 세십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(a(b)c)d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;abcd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>으로는 한 번에 여러 개의 그룹 번호를 전달할 수 있으며, 이때 해당 그룹에 해당하는 값을 포함하는 튜플을 반환합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(&#39;b&#39;, &#39;abc&#39;, &#39;b&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.groups" title="re.Match.groups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groups()</span></code></a> 메서드는 모든 서브 그룹에 대한 문자열을 포함하는 튜플을 반환합니다,  1에서 최대까지.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;abc&#39;, &#39;b&#39;)</span>
</pre></div>
</div>
<p>패턴의 역참조를 사용하면 이전 포착 그룹의 내용이 문자열의 현재 위치에서도 발견되어야 한다고 지정할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">\1</span></code>은 그룹 1의 정확한 내용이 현재 위치에서 발견되면 성공하고, 그렇지 않으면 실패합니다. 파이썬의 문자열 리터럴은 백 슬래시 뒤에 숫자를 붙여 문자열에 임의의 문자를 포함할 수 있기 때문에, RE에 역참조를 포함할 때 날 문자열을 사용해야 합니다.</p>
<p>예를 들어, 다음 RE는 문자열에서 중복 단어를 감지합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(\w+)\s+\1\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Paris in the the spring&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;the the&#39;</span>
</pre></div>
</div>
<p>이와 같은 역참조는 단순히 문자열을 검색하는 데는 별로 유용하지 않습니다 --- 이런 식으로 데이터를 반복하는 텍스트 형식은 거의 없습니다 --- 하지만 곧 문자열 치환을 수행할 때 <em>아주</em> 유용하다는 것을 알게 될 것입니다.</p>
</div>
<div class="section" id="non-capturing-and-named-groups">
<h3>비 포착 그룹과 이름 있는 그룹<a class="headerlink" href="#non-capturing-and-named-groups" title="제목 주소">¶</a></h3>
<p>정교한 RE는 관심 있는 부분 문자열을 포착하고 RE 자체를 그룹화하고 구조화하기 위해 많은 그룹을 사용할 수 있습니다. 복잡한 RE에서는, 그룹 번호를 추적하기가 어려워집니다. 이 문제를 해결하는 데 도움이 되는 두 가지 기능이 있습니다. 둘 다 정규식 확장에 같은 문법을 사용하므로, 그것부터 살펴보겠습니다.</p>
<p>Perl 5는 표준 정규식에 대한 강력한 추가 기능으로 유명합니다. 이러한 새로운 기능을 위해 Perl 개발자는 Perl의 정규식을 표준 RE와 혼란스러울 만큼 다르게 만들지 않으면서 한 글자 메타 문자나 <code class="docutils literal notranslate"><span class="pre">\</span></code>로 시작하는 새로운 특수 시퀀스를 선택할 수 없었습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>를 새로운 메타 문자로 선택하면, 예전 정규식은 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>가 일반 문자라고 가정하고 <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code>나 <code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code>로 작성하여 이스케이프 하지 않을 것입니다.</p>
<p>Perl 개발자가 선택한 해법은 <code class="docutils literal notranslate"><span class="pre">(?...)</span></code>를 확장 문법으로 사용하는 것입니다. 괄호 바로 뒤에 있는 <code class="docutils literal notranslate"><span class="pre">?</span></code>는 <code class="docutils literal notranslate"><span class="pre">?</span></code>가 반복할 것이 없기 때문에 문법 에러였습니다. 따라서 이것은 어떤 호환성 문제도 일으키지 않습니다. <code class="docutils literal notranslate"><span class="pre">?</span></code> 다음에 나오는 문자는 어떤 확장이 사용되는지 나타내므로, <code class="docutils literal notranslate"><span class="pre">(?=foo)</span></code> 는 한가지 확장이고 (긍정적인 미리 보기 어서션), <code class="docutils literal notranslate"><span class="pre">(?:foo)</span></code> 는 또 다른 것입니다 (서브 정규식 <code class="docutils literal notranslate"><span class="pre">foo</span></code>를 포함하는 비 포착 그룹).</p>
<p>파이썬은 여러 Perl의 확장을 지원하고 Perl의 확장 문법에 확장 문법을 추가합니다. 물음표 뒤의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">P</span></code>이면, 파이썬에 특유한 확장임을 알 수 있습니다.</p>
<p>이제 일반적인 확장 문법을 살펴보았으므로, 복잡한 RE에서 그룹 작업을 단순화하는 기능으로 돌아갈 수 있습니다.</p>
<p>때로 그룹을 사용하여 정규식의 일부를 나타내고 싶지만, 그룹의 내용을 꺼내는 데는 관심이 없습니다. 이 사실을 비 포착 그룹을 사용해서 명시적으로 만들 수 있습니다: <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>, 여기서 <code class="docutils literal notranslate"><span class="pre">...</span></code>을 다른 정규식으로 바꿀 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;([abc])+&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;c&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;(?:[abc])+&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">()</span>
</pre></div>
</div>
<p>그룹과 일치하는 내용을 꺼낼 수 없다는 점을 제외하면, 비 포착 그룹은 포착 그룹과 정확히 같게 작동합니다; 안에 어떤 것이든 넣을 수 있고, <code class="docutils literal notranslate"><span class="pre">*</span></code>와 같은 반복 메타 문자로 반복할 수 있고, 다른 그룹(포착이나 비 포착) 내에 중첩할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>는 기존 패턴을 수정할 때 특히 유용합니다. 다른 모든 그룹의 번호가 매겨지는 방식을 변경하지 않고 새 그룹을 추가 할 수 있기 때문입니다. 포착 그룹과 비 포착 그룹을 검색할 때 성능 차이가 없다는 점을 짚고 넘어가야 할 것 같습니다; 두 형태 중 어느 것도 다른 것보다 빠르지 않습니다.</p>
<p>더 중요한 기능은 이름 있는 그룹입니다: 번호로 참조하는 대신, 이름으로 그룹을 참조 할 수 있습니다.</p>
<p>이름 있는 그룹의 문법은 파이썬 특정 확장 중 하나입니다: <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>. <em>name</em>은, 당연히, 그룹의 이름입니다. 이름 있는 그룹은 포착 그룹과 똑같이 동작하며, 추가로 이름을 그룹과 연관시킵니다. 포착 그룹을 다루는 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 메서드는 모두 숫자로 그룹을 가리키는 정수나 원하는 그룹의 이름을 포함하는 문자열을 받아들입니다. 이름 있는 그룹에는 여전히 번호가 매겨지므로, 두 가지 방법으로 그룹에 대한 정보를 꺼낼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;word&gt;\b\w+\b)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="s1">&#39;(((( Lots of punctuation )))&#39;</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">&#39;Lots&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Lots&#39;</span>
</pre></div>
</div>
<p>또한, <a class="reference internal" href="../library/re.html#re.Match.groupdict" title="re.Match.groupdict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groupdict()</span></code></a>로 이름 있는 그룹을 딕셔너리로 꺼낼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;first&gt;\w+) (?P&lt;last&gt;\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Jane Doe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first&#39;: &#39;Jane&#39;, &#39;last&#39;: &#39;Doe&#39;}</span>
</pre></div>
</div>
<p>이름 있는 그룹은 숫자를 기억하는 대신 쉽게 기억할 수 있는 이름을 사용할 수 있어서 편리합니다. 다음은 <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 모듈에서 온 예제 RE입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">InternalDate</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;INTERNALDATE &quot;&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;year&gt;[0-9][0-9][0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39; (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39; (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>그룹 9를 꺼내는 것을 기억하는 대신, <code class="docutils literal notranslate"><span class="pre">m.group('zonem')</span></code>을 꺼내기가 훨씬 쉽습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">(...)\1</span></code>과 같은 정규식에서 역참조 문법은 그룹 번호를 나타냅니다. 자연스럽게 번호 대신 그룹 이름을 사용하는 변형이 있습니다. 이것은 다른 파이썬 확장입니다: <code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code>은 <em>name</em>이라는 그룹의 내용이 현재 위치에서 다시 일치해야 함을 나타냅니다. 중복된 단어를 찾는 정규식인 <code class="docutils literal notranslate"><span class="pre">\b(\w+)\s+\1\b</span></code>는 <code class="docutils literal notranslate"><span class="pre">\b(?P&lt;word&gt;\w+)\s+(?P=word)\b</span></code>로 표현할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(?P&lt;word&gt;\w+)\s+(?P=word)\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Paris in the the spring&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;the the&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="lookahead-assertions">
<h3>미리 보기 어서션<a class="headerlink" href="#lookahead-assertions" title="제목 주소">¶</a></h3>
<p>또 다른 폭이 없는 어서션은 미리 보기 어서션(lookahead assertion)입니다. 미리 보기 어서션은 긍정과 부정 형식 모두 제공되며, 다음과 같이 표시됩니다:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>긍정적인 미리 보기 어서션. 포함된 정규식(여기에서는 <code class="docutils literal notranslate"><span class="pre">...</span></code>로 표시되었습니다)이 현재 위치에서 성공적으로 일치하면 성공하고, 그렇지 않으면 실패합니다. 그러나, 일단 포함된 정규식이 시도되면, 일치 엔진은 전혀 앞으로 나아가지 않습니다; 어서선이 시작한 곳에서 나머지 패턴을 시도합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>부정적인 미리 보기 어서션. 이것은 긍정적인 어서션의 반대입니다; 포함된 정규식이 문자열의 현재 위치에서 일치하지 <em>않으면</em> 성공합니다.</p>
</dd>
</dl>
<p>이를 구체적으로 설명하기 위해, 미리 보기가 유용한 경우를 살펴보겠습니다. 파일 이름을 일치시키고 <code class="docutils literal notranslate"><span class="pre">.</span></code>로 구분된 기본 이름과 확장자로 분리하는 간단한 패턴을 생각해봅시다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">news.rc</span></code>에서, <code class="docutils literal notranslate"><span class="pre">news</span></code>는 기본 이름이고 <code class="docutils literal notranslate"><span class="pre">rc</span></code>는 파일명의 확장자입니다.</p>
<p>이것과 일치하는 패턴은 매우 간단합니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.].*$</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code>는 메타 문자이므로 특수하게 처리해야 하므로, 해당 문자에만 일치하기 위해 문자 클래스 내에 있습니다. 또한 후행 <code class="docutils literal notranslate"><span class="pre">$</span></code>도 유의하십시오; 나머지 문자열이 확장에 포함되어야 함을 보장하기 위해 추가됩니다. 이 정규식은 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>와 <code class="docutils literal notranslate"><span class="pre">autoexec.bat</span></code>와 <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>와 <code class="docutils literal notranslate"><span class="pre">printers.conf</span></code>와 일치합니다.</p>
<p>자, 문제를 조금 복잡하게 생각해보십시오; 확장자가 <code class="docutils literal notranslate"><span class="pre">bat</span></code>이 아닌 파일명을 일치시키려면 어떻게 해야 합니까? 몇 가지 잘못된 시도:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.][^b].*$</span></code> 위의 첫 번째 시도는 확장자의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">b</span></code>가 아니도록 요구하여 <code class="docutils literal notranslate"><span class="pre">bat</span></code>를 제외하려고 시도합니다. 패턴이 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>와도 일치하지 않기 때문에, 이것은 잘못된 것입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.]([^b]..|.[^a].|..[^t])$</span></code></p>
<p>다음에서 하나를 요구하여 첫 번째 해결 방법을 패치할 때 정규식이 더 복잡해집니다: 확장자의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">b</span></code>가 아닙니다; 두 번째 문자가 <code class="docutils literal notranslate"><span class="pre">a</span></code>가 아닙니다; 또는 세 번째 문자가 <code class="docutils literal notranslate"><span class="pre">t</span></code>가 아닙니다. 이것은 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>를 받아들이고 <code class="docutils literal notranslate"><span class="pre">autoexec.bat</span></code>를 거부하지만, 세 문자 확장자를 요구하고 <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>와 같은 두 문자로 된 확장자를 가진 파일명을 허용하지 않습니다. 문제를 해결하기 위해 패턴을 다시 복잡하게 만들 것입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</span></code></p>
<p>세 번째 시도에서, <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>와 같이 세 문자보다 짧은 확장자를 허용하기 위해 두 번째와 세 번째 문자는 모두 선택적입니다.</p>
<p>이제 패턴이 정말 복잡해져서, 읽고 이해하기 어렵습니다. 더욱이, 문제가 변경되어 확장자 <code class="docutils literal notranslate"><span class="pre">bat</span></code>와 <code class="docutils literal notranslate"><span class="pre">exe</span></code>를 모두 제외하려면, 패턴이 훨씬 복잡하고 혼란스러워집니다.</p>
<p>부정적인 미리 보기는 이 모든 혼란을 제거합니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.](?!bat$)[^.]*$</span></code> 부정적인 미리 보기는 다음과 같은 의미입니다: <code class="docutils literal notranslate"><span class="pre">bat</span></code> 정규식이 이 지점에서 일치하지 않으면, 나머지 패턴을 시도합니다; <code class="docutils literal notranslate"><span class="pre">bat$</span></code>가 일치하면, 전체 패턴이 실패합니다. 후행 <code class="docutils literal notranslate"><span class="pre">$</span></code>는 <code class="docutils literal notranslate"><span class="pre">sample.batch</span></code>와 같이 <code class="docutils literal notranslate"><span class="pre">bat</span></code>로 시작하기만 하는 확장자를 허용하기 위해 필요합니다. <code class="docutils literal notranslate"><span class="pre">[^.]*</span></code>는 파일명에 여러 점이 있을 때 패턴이 작동하도록 합니다.</p>
<p>다른 파일명 확장자를 제외하는 것이 이제는 쉽습니다; 단순히 어서션 안에 대안으로 추가하십시오. 다음 패턴은 <code class="docutils literal notranslate"><span class="pre">bat</span></code>나 <code class="docutils literal notranslate"><span class="pre">exe</span></code>로 끝나는 파일명을 제외합니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.](?!bat$|exe$)[^.]*$</span></code></p>
</div>
</div>
<div class="section" id="modifying-strings">
<h2>문자열 수정하기<a class="headerlink" href="#modifying-strings" title="제목 주소">¶</a></h2>
<p>지금까지는, 정적 문자열에 대한 검색만 수행했습니다. 정규식은 다음과 같은 패턴 메서드를 사용하여 다양한 방법으로 문자열을 수정하는 데 흔히 사용됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드/어트리뷰트</p></th>
<th class="head"><p>목적</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">split()</span></code></p></td>
<td><p>RE가 일치하는 모든 곳에서 분할하여, 문자열을 리스트로 분할합니다</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sub()</span></code></p></td>
<td><p>RE가 일치하는 모든 부분 문자열을 찾고, 다른 문자열로 대체합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">subn()</span></code></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code>와 같은 일을 하지만, 새로운 문자열과 치환 횟수를 반환합니다</p></td>
</tr>
</tbody>
</table>
<div class="section" id="splitting-strings">
<h3>문자열 분할하기<a class="headerlink" href="#splitting-strings" title="제목 주소">¶</a></h3>
<p>패턴의 <a class="reference internal" href="../library/re.html#re.Pattern.split" title="re.Pattern.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> 메서드는 RE가 일치하는 모든 곳에서 문자열을 분할하여, 조각의 리스트를 반환합니다. 이것은 <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> 문자열 메서드와 비슷하지만 분리하는 데 사용되는 구분자에 훨씬 더 일반성을 제공합니다; 문자열 <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code>는 공백이나 고정 문자열로의 분할 만 지원합니다. 예상대로, 모듈 수준의 <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> 함수도 있습니다.</p>
<dl class="method">
<dt>
<code class="sig-prename descclassname">.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">maxsplit=0</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>정규식과 일치하는 것으로 <em>string</em>을 분할합니다. RE에서 포착하는 괄호가 사용되면, 해당 내용도 결과 리스트의 일부로 반환됩니다. <em>maxsplit</em>가 0이 아니면, 최대 <em>maxsplit</em> 번 분할만 수행됩니다.</p>
</dd></dl>

<p><em>maxsplit</em> 값을 전달하여, 분할 수를 제한 할 수 있습니다. <em>maxsplit</em>가 0이 아니면, 최대 <em>maxsplit</em> 번 분할만 이루어지고, 나머지 문자열은 리스트의 마지막 요소로 반환됩니다. 다음 예제에서, 구분자는 영숫자가 아닌 문자 시퀀스입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This is a test, short and sweet, of split().&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;short&#39;, &#39;and&#39;, &#39;sweet&#39;, &#39;of&#39;, &#39;split&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This is a test, short and sweet, of split().&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test, short and sweet, of split().&#39;]</span>
</pre></div>
</div>
<p>때로는 구분자 사이의 텍스트가 무엇인지에 관심이 있을 뿐만 아니라, 구분자가 무엇인지도 알아야 할 필요가 있습니다. RE에서 포착하는 괄호가 사용되면, 해당 값도 리스트의 일부로 반환됩니다. 다음 호출을 비교하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This... is a test.&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This... is a test.&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;... &#39;, &#39;is&#39;, &#39; &#39;, &#39;a&#39;, &#39; &#39;, &#39;test&#39;, &#39;.&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>모듈 수준 함수 <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a>는 첫 번째 인자로 사용할 RE를 추가하지만, 이를 제외하고는 같습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W]+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([\W]+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W]+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="search-and-replace">
<h3>검색과 치환<a class="headerlink" href="#search-and-replace" title="제목 주소">¶</a></h3>
<p>또 다른 흔한 작업은 패턴에 대한 모든 일치를 찾아 다른 문자열로 치환하는 것입니다. <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> 메서드는 치환 값(문자열이나 함수일 수 있습니다)과 처리할 문자열을 취합니다.</p>
<dl class="method">
<dt>
<code class="sig-prename descclassname">.</code><code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">replacement</em>, <em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">count=0</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p><em>string</em>에서 가장 왼쪽에 나타나는 겹쳐지지 않은 RE의 일치를 <em>replacement</em>로 치환한 문자열을 반환합니다. 패턴이 없으면, <em>string</em>이 변경 없이 반환됩니다.</p>
<p>선택적 인자 <em>count</em>는 치환될 패턴 일치의 최대 수입니다; <em>count</em>는 음수가 아닌 정수여야 합니다. 기본값 0은 모든 일치를 치환하는 것을 의미합니다.</p>
</dd></dl>

<p>다음은 <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> 메서드를 사용하는 간단한 예제입니다. 색상 이름을 <code class="docutils literal notranslate"><span class="pre">colour</span></code>라는 단어로 바꿉니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(blue|white|red)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">)</span>
<span class="go">&#39;colour socks and colour shoes&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;colour socks and red shoes&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Pattern.subn" title="re.Pattern.subn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subn()</span></code></a> 메서드는 같은 작업을 수행하지만, 새 문자열 값과 수행된 치환 수가 포함된 2-튜플을 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(blue|white|red)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">)</span>
<span class="go">(&#39;colour socks and colour shoes&#39;, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;no colours at all&#39;</span><span class="p">)</span>
<span class="go">(&#39;no colours at all&#39;, 0)</span>
</pre></div>
</div>
<p>빈 일치는 이전의 빈 일치와 인접하지 않은 경우에만 치환됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;x*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;abxd&#39;</span><span class="p">)</span>
<span class="go">&#39;-a-b--d-&#39;</span>
</pre></div>
</div>
<p><em>replacement</em>가 문자열이면, 그 안에 있는 모든 역 슬래시 이스케이프가 처리됩니다. 즉, <code class="docutils literal notranslate"><span class="pre">\n</span></code>은 단일 개행 문자로 변환되고, <code class="docutils literal notranslate"><span class="pre">\r</span></code>은 캐리지 리턴으로 변환되고, 나머지도 마찬가지입니다. <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code>와 같은 알 수 없는 이스케이프는 그대로 남습니다. <code class="docutils literal notranslate"><span class="pre">\6</span></code>과 같은 역참조는 RE의 해당 그룹과 일치하는 부분 문자열로 치환됩니다. 이렇게 하면 결과 치환 문자열에 원본 텍스트의 일부를 통합할 수 있습니다.</p>
<p>이 예제는 뒤에 <code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>로 묶인 문자열이 오는 단어 <code class="docutils literal notranslate"><span class="pre">section</span></code>과 일치하고, <code class="docutils literal notranslate"><span class="pre">section</span></code>을 <code class="docutils literal notranslate"><span class="pre">subsection</span></code>으로 변경합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;section{ ( [^}]* ) }&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\1}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1"> section</span><span class="si">{second}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First} subsection{second}&#39;</span>
</pre></div>
</div>
<p>또한 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 문법으로 정의된 이름 있는 그룹을 참조하기 위한 문법이 있습니다. <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>은 <code class="docutils literal notranslate"><span class="pre">name</span></code> 그룹과 일치하는 부분 문자열을 사용하고, <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code>는 해당 그룹 번호를 사용합니다. 따라서 <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code>는 <code class="docutils literal notranslate"><span class="pre">\2</span></code>와 동등하지만, <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>과 같은 치환 문자열에서 모호하지 않습니다. (<code class="docutils literal notranslate"><span class="pre">\20</span></code>은 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>이 뒤에 오는 그룹 2에 대한 참조가 아닌, 그룹 20에 대한 참조로 해석됩니다.) 다음 치환은 모두 동등하지만, 치환 문자열의 세 가지 변형을 모두 사용합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;section{ (?P&lt;name&gt; [^}]* ) }&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\1}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\g&lt;1&gt;}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\g&lt;name&gt;}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
</pre></div>
</div>
<p><em>replacement</em>는 함수일 수도 있는데, 더 많은 제어를 제공합니다. <em>replacement</em>가 함수면, <em>pattern</em>의 겹쳐지지 않는 모든 일치에 대해 함수가 호출됩니다. 각 호출에서, 함수는 그 일치에 대한 <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">일치 객체</span></a> 인자를 전달받고, 이 정보를 사용하여 원하는 치환 문자열을 계산하고 이를 반환 할 수 있습니다.</p>
<p>다음 예제에서, 치환 함수는 십진수를 16진수로 변환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">hexrepl</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;십진수의 16진수 문자열을 반환합니다&quot;</span>
<span class="gp">... </span>    <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">hex</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">hexrepl</span><span class="p">,</span> <span class="s1">&#39;Call 65490 for printing, 49152 for user code.&#39;</span><span class="p">)</span>
<span class="go">&#39;Call 0xffd2 for printing, 0xc000 for user code.&#39;</span>
</pre></div>
</div>
<p>모듈 수준의 <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> 함수를 사용할 때, 패턴은 첫 번째 인자로 전달됩니다. 패턴은 객체나 문자열로 제공될 수 있습니다; 정규식 플래그를 지정해야 하면, 패턴 객체를 첫 번째 매개 변수로 사용하거나 패턴 문자열에 포함된 수정자를 사용해야 합니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">sub(&quot;(?i)b+&quot;,</span> <span class="pre">&quot;x&quot;,</span> <span class="pre">&quot;bbbb</span> <span class="pre">BBBB&quot;)</span></code>는 <code class="docutils literal notranslate"><span class="pre">'x</span> <span class="pre">x'</span></code>를 반환합니다.</p>
</div>
</div>
<div class="section" id="common-problems">
<h2>일반적인 문제들<a class="headerlink" href="#common-problems" title="제목 주소">¶</a></h2>
<p>정규식은 일부 응용을 위한 강력한 도구이지만, 어떤 면에서는 동작이 직관적이지 않고 때때로 예상대로 동작하지 않을 수도 있습니다. 이 절에서는 가장 일반적인 함정 중 일부를 지적합니다.</p>
<div class="section" id="use-string-methods">
<h3>문자열 메서드를 사용하십시오<a class="headerlink" href="#use-string-methods" title="제목 주소">¶</a></h3>
<p>때때로 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈을 사용하는 것은 실수입니다. 고정된 문자열이나 단일 문자 클래스와 일치시키려고 하고, <a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> 플래그와 같은 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 기능을 사용하지 않는다면, 정규식의 모든 기능이 필요하지 않을 수 있습니다. 문자열은 고정 문자열을 사용하는 연산을 수행하는 몇 가지 메서드를 가지고 있으며, 대개 훨씬 빠릅니다. 더 크고, 더 일반화된 정규식 엔진 대신, 구현이 목적에 맞게 최적화된 단일하고 작은 C 루프이기 때문입니다.</p>
<p>한가지 예는 하나의 고정 된 문자열을 다른 것으로 치환하는 것일 수 있습니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">word</span></code>를 <code class="docutils literal notranslate"><span class="pre">deed</span></code>로 바꿀 수 있습니다. <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a>가 이를 위한 함수인 것처럼 보이지만, <a class="reference internal" href="../library/stdtypes.html#str.replace" title="str.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> 메서드를 고려하십시오. <code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code>는 또한 단어 안에 있는 <code class="docutils literal notranslate"><span class="pre">word</span></code>를 치환해서, <code class="docutils literal notranslate"><span class="pre">swordfish</span></code>를 <code class="docutils literal notranslate"><span class="pre">sdeedfish</span></code>로 바꾸지만, 나이브한 RE <code class="docutils literal notranslate"><span class="pre">word</span></code>도 그렇게 했을 것입니다. (단어의 일부에 대한 치환을 수행하는 것을 피하고자, 패턴은 <code class="docutils literal notranslate"><span class="pre">word</span></code> 양쪽에 단어 경계가 있도록 <code class="docutils literal notranslate"><span class="pre">\bword\b</span></code>여야 합니다. 이 작업은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code>의 능력을 넘어섭니다.)</p>
<p>또 다른 일반적인 작업은 문자열에서 단일 문자를 모두 삭제하거나 다른 단일 문자로 바꾸는 것입니다. <code class="docutils literal notranslate"><span class="pre">re.sub('\n',</span> <span class="pre">'</span> <span class="pre">',</span> <span class="pre">S)</span></code>와 같은 방식으로 이 작업을 수행 할 수 있지만, <a class="reference internal" href="../library/stdtypes.html#str.translate" title="str.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>는 두 가지 작업을 모두 수행 할 수 있으며 정규식 연산보다 빠릅니다.</p>
<p>정리하면, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈을 사용하기 전에, 더 빠르고 간단한 문자열 메서드로 문제를 해결할 수 있는지 고려하십시오.</p>
</div>
<div class="section" id="match-versus-search">
<h3>match()와 search() 비교<a class="headerlink" href="#match-versus-search" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> 함수는 문자열 시작 부분에서 RE가 일치하는지만 확인하는 반면, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>는 일치를 찾기 위해 문자열을 정방향으로 검색합니다. 이 차이를 염두에 두는 것이 중요합니다. 기억하십시오, <code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code>는 0에서 시작하는 성공적인 일치만을 보고합니다; 일치가 0에서 시작하지 않으면, <code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code>는 이를 보고하지 <em>않습니다</em>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;superstition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;insuperable&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>반면에, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>는 문자열을 정방향으로 검색하여, 발견된 첫 번째 일치를 보고합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;superstition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;insuperable&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(2, 7)</span>
</pre></div>
</div>
<p>때로 <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>를 계속 사용하면서, 단지 <code class="docutils literal notranslate"><span class="pre">.*</span></code>를 RE 앞에 추가하고 싶을 수 있습니다. 이 유혹에 저항하고, 대신 <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>를 사용하십시오. 정규식 컴파일러는 일치를 찾는 프로세스의 속도를 높이기 위해 RE에 대한 분석을 수행합니다. 그러한 분석의 하나는 일치의 첫 번째 문자가 무엇인지 알아내는 것입니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">Crow</span></code>로 시작하는 패턴은 <code class="docutils literal notranslate"><span class="pre">'C'</span></code>로 시작하는 것과 일치해야 합니다. 이 분석을 통해 엔진은 시작 문자를 찾기 위해 문자열을 빠르게 검색하고, <code class="docutils literal notranslate"><span class="pre">'C'</span></code>가 발견될 때만 전체 일치를 시도합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*</span></code>를 추가하면 이 최적화가 실패하고, 문자열의 끝부분까지 스캔한 다음, RE의 나머지에 대한 일치를 찾기 위해 역 추적합니다. 대신 <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>를 사용하십시오.</p>
</div>
<div class="section" id="greedy-versus-non-greedy">
<h3>탐욕적 과 비 탐욕적 비교<a class="headerlink" href="#greedy-versus-non-greedy" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">a*</span></code>에서와같이 정규식을 반복할 때, 결과 동작은 가능한 한 많은 패턴을 소비하는 것입니다. 이 사실은 HTML 태그를 둘러싼 화살 괄호(angle brackets)와 같이 쌍을 이루는 구분 기호 쌍을 일치시키려고 할 때 여러분을 물어뜯을 수 있습니다. 하나의 HTML 태그를 일치하는 나이브한 패턴은 <code class="docutils literal notranslate"><span class="pre">.*</span></code>의 탐욕스러운 성격 때문에 작동하지 않습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="go">&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;</span>
</pre></div>
</div>
<p>RE는 <code class="docutils literal notranslate"><span class="pre">'&lt;html&gt;'</span></code>의 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>와 일치하고, <code class="docutils literal notranslate"><span class="pre">.*</span></code>는 나머지 문자열을 소비합니다. RE에는 여전히 남아있는 것이 있고, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>는 문자열의 끝에서 일치할 수 없기 때문에, 정규식 엔진은 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>와 일치하는 것을 찾을 때까지 문자 단위로 역 추적해야 합니다. 최종 일치는 <code class="docutils literal notranslate"><span class="pre">'&lt;html&gt;'</span></code>의 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>에서 <code class="docutils literal notranslate"><span class="pre">'&lt;/title&gt;'</span></code>의 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>까지 확장되는데, 이는 여러분이 원하는 것이 아닙니다.</p>
<p>이 경우, 해결 방법은 가능한 한 <em>적은</em> 텍스트에 일치하는 비 탐욕적 한정자 <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code>를 사용하는 것입니다. 위의 예에서, 첫 번째 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>가 일치하면 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>가 즉시 시도되고, 실패하면 엔진은 한 번에 한 문자씩 앞으로 이동하여 단계마다 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>를 다시 시도합니다. 이렇게 하면 올바른 결과를 얻을 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*?&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="go">&lt;html&gt;</span>
</pre></div>
</div>
<p>(정규식으로 HTML이나 XML을 구문 분석하기는 쉽지 않습니다. 빠르지만 지저분한 패턴은 일반적인 경우를 처리할 것이지만, HTML과 XML에는 명확한 정규식을 깨뜨릴 특수 사례가 있습니다; 모든 가능한 경우를 처리하도록 정규식을 작성하면, 패턴이 <em>아주</em> 복잡해질 수 있습니다. 이러한 작업에는 HTML이나 XML 구문 분석 모듈을 사용하십시오.)</p>
</div>
<div class="section" id="using-re-verbose">
<h3>re.VERBOSE 사용하기<a class="headerlink" href="#using-re-verbose" title="제목 주소">¶</a></h3>
<p>지금까지 정규식이 매우 콤팩트한 표기법이라는 사실을 눈치챘을 것입니다만, 극단적으로 읽기 어렵지는 않았습니다. 중간 정도의 복잡성을 가진 RE는 역 슬래시, 괄호 및 메타 문자의 긴 모음이 되어 읽고 이해하기 어려울 수 있습니다.</p>
<p>이러한 RE의 경우, 정규식을 컴파일할 때 <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a> 플래그를 지정하면 정규식을 보다 명확하게 포맷할 수 있어서 도움이 됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">re.VERBOSE</span></code> 플래그는 여러 가지 효과가 있습니다. 문자 클래스 안에 <em>있지 않은</em> 공백이 무시됩니다. 이것은, <code class="docutils literal notranslate"><span class="pre">dog</span> <span class="pre">|</span> <span class="pre">cat</span></code>과 같은 정규식은 가독성이 떨어지는 <code class="docutils literal notranslate"><span class="pre">dog|cat</span></code>과 동등하지만, <code class="docutils literal notranslate"><span class="pre">[a</span> <span class="pre">b]</span></code>는 여전히 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 또는 스페이스 문자와 일치함을 뜻합니다. 또한, 주석을 RE에 넣을 수도 있습니다; 주석은 <code class="docutils literal notranslate"><span class="pre">#</span></code> 문자에서 다음 줄 바꿈까지 확장됩니다. 삼중 따옴표로 묶은 문자열과 함께 사용하면, RE를 더 깔끔하게 포맷할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> \s*                 # 선행 공백을 건너뜁니다</span>
<span class="s2"> (?P&lt;header&gt;[^:]+)   # 헤더 이름</span>
<span class="s2"> \s* :               # 공백과 콜론</span>
<span class="s2"> (?P&lt;value&gt;.*?)      # 헤더의 값 -- *? 을 사용해서</span>
<span class="s2">                     # 뒤에 오는 공백을 버립니다</span>
<span class="s2"> \s*$                # 줄 끝까지의 후행 공백</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
</pre></div>
</div>
<p>이것이 다음보다 훨씬 읽기 쉽습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="feedback">
<h2>피드백<a class="headerlink" href="#feedback" title="제목 주소">¶</a></h2>
<p>정규식은 복잡한 주제입니다. 이 문서가 도움이 되었습니까? 불분명 한 부분이 있거나, 여기에서 다루지 않은 문제가 있습니까? 그렇다면 저자에게 개선을 위한 제안을 보내주십시오.</p>
<p>정규식에 대한 가장 완벽한 책은 거의 확실히 O'Reilly가 출판한 Jeffrey Friedl의 Mastering Regular Expressions 입니다. 불행히도, 이 책은 Perl과 Java의 정규식에만 집중하고, 파이썬 자료를 전혀 포함하지 않아서 파이썬 프로그래밍에 대한 참조로는 유용하지 않습니다. (첫 번째 판은 지금은 제거된 파이썬의 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 모듈을 다뤘습니다만, 큰 도움은 되지 못합니다.) 여러분의 도서관에서 확인해보십시오.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">정규식 HOWTO</a><ul>
<li><a class="reference internal" href="#introduction">소개</a></li>
<li><a class="reference internal" href="#simple-patterns">단순한 패턴</a><ul>
<li><a class="reference internal" href="#matching-characters">문자 일치</a></li>
<li><a class="reference internal" href="#repeating-things">반복하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-regular-expressions">정규식 사용하기</a><ul>
<li><a class="reference internal" href="#compiling-regular-expressions">정규식 컴파일하기</a></li>
<li><a class="reference internal" href="#the-backslash-plague">백 슬래시 전염병</a></li>
<li><a class="reference internal" href="#performing-matches">일치 수행하기</a></li>
<li><a class="reference internal" href="#module-level-functions">모듈 수준 함수</a></li>
<li><a class="reference internal" href="#compilation-flags">컴파일 플래그</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-pattern-power">더 많은 패턴 기능</a><ul>
<li><a class="reference internal" href="#more-metacharacters">메타 문자 더 보기</a></li>
<li><a class="reference internal" href="#grouping">그룹</a></li>
<li><a class="reference internal" href="#non-capturing-and-named-groups">비 포착 그룹과 이름 있는 그룹</a></li>
<li><a class="reference internal" href="#lookahead-assertions">미리 보기 어서션</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modifying-strings">문자열 수정하기</a><ul>
<li><a class="reference internal" href="#splitting-strings">문자열 분할하기</a></li>
<li><a class="reference internal" href="#search-and-replace">검색과 치환</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-problems">일반적인 문제들</a><ul>
<li><a class="reference internal" href="#use-string-methods">문자열 메서드를 사용하십시오</a></li>
<li><a class="reference internal" href="#match-versus-search">match()와 search() 비교</a></li>
<li><a class="reference internal" href="#greedy-versus-non-greedy">탐욕적 과 비 탐욕적 비교</a></li>
<li><a class="reference internal" href="#using-re-verbose">re.VERBOSE 사용하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#feedback">피드백</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="logging-cookbook.html"
                        title="이전 장">로깅 요리책</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="sockets.html"
                        title="다음 장">소켓 프로그래밍 HOWTO</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="소켓 프로그래밍 HOWTO"
             >다음</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="로깅 요리책"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>