
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>파이썬 2 코드를 파이썬 3으로 이식하기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="확장 모듈을 파이썬 3에 이식하기" href="cporting.html" />
    <link rel="prev" title="파이썬 HOWTO" href="index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/howto/pyporting.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="cporting.html" title="확장 모듈을 파이썬 3에 이식하기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="index.html" title="파이썬 HOWTO"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="porting-python-2-code-to-python-3">
<span id="pyporting-howto"></span><h1>파이썬 2 코드를 파이썬 3으로 이식하기<a class="headerlink" href="#porting-python-2-code-to-python-3" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">저자</dt>
<dd class="field-odd"><p>Brett Cannon</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title first">요약</p>
<p>파이썬 3이 파이썬의 미래이지만 파이썬 2가 여전히 활발하게 사용되고 있기 때문에, 두 가지 주요 파이썬 릴리스에서 프로젝트를 사용할 수있게하는 것이 좋습니다. 이 안내서는 파이썬 2와 3을 동시에 지원하는 가장 좋은 방법을 찾는 데 도움을 주려고 합니다.</p>
<p>순수 파이썬 코드 대신 확장 모듈을 이식하려고 한다면 <a class="reference internal" href="cporting.html#cporting-howto"><span class="std std-ref">확장 모듈을 파이썬 3에 이식하기</span></a>를 참조하십시오.</p>
<p>파이썬 3이 왜 등장했는지에 대한 핵심 파이썬 개발자의 글을 읽고 싶다면, Nick Coghlan의 <a class="reference external" href="https://ncoghlan-devs-python-notes.readthedocs.io/en/latest/python3/questions_and_answers.html">Python 3 Q &amp; A</a>나 Brett Cannon의 <a class="reference external" href="https://snarky.ca/why-python-3-exists">Why Python 3 exists</a>를 추천합니다.</p>
<p>이식에 도움이 필요하면, <a class="reference external" href="https://mail.python.org/mailman/listinfo/python-porting">python-porting</a> 메일링 리스트에 질문을 전자우편으로 보낼 수 있습니다.</p>
</div>
<div class="section" id="the-short-explanation">
<h2>짧은 설명<a class="headerlink" href="#the-short-explanation" title="제목 주소">¶</a></h2>
<p>프로젝트를 단일 소스 파이썬 2/3 호환으로 만들려면, 기본 단계는 다음과 같습니다:</p>
<ol class="arabic simple">
<li><p>파이썬 2.7 지원만 신경쓰십시오</p></li>
<li><p>테스트 커버리지가 양호한지 확인하십시오 (<a class="reference external" href="https://pypi.org/project/coverage">coverage.py</a>가 도움이 될 수 있습니다; <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">coverage</span></code>)</p></li>
<li><p>파이썬 2와 3의 차이점을 공부하십시오</p></li>
<li><p><a class="reference external" href="http://python-future.org/automatic_conversion.html">Futurize</a>(또는 <a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a>)를 사용하여 코드를 갱신하십시오 (예를 들어 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">future</span></code>)</p></li>
<li><p><a class="reference external" href="https://pypi.org/project/pylint">Pylint</a>를 사용하여 파이썬 3 지원의 회귀 테스트가 실패하지 않도록 점검하십시오 (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pylint</span></code>)</p></li>
<li><p><a class="reference external" href="https://pypi.org/project/caniusepython3">caniusepython3</a>을 사용하여 파이썬 3 사용을 막는 의존성(dependencies)을 찾으십시오 (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">caniusepython3</span></code>)</p></li>
<li><p>일단 의존성이 더는 여러분을 막지 않으면, 지속적인 통합을 사용하여 파이썬 2 &amp; 3와의 호환성을 유지하십시오 (<a class="reference external" href="https://pypi.org/project/tox">tox</a>는 여러 버전의 파이썬에서 테스트하는 데 도움이 됩니다; <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">tox</span></code>)</p></li>
<li><p>선택적으로 정적 형 검사를 사용하여 형 사용이 파이썬 2와 3에서 모두 작동하는지 확인하십시오 (예를 들어 <a class="reference external" href="http://mypy-lang.org/">mypy</a>를 사용하여 파이썬 2와 파이썬 3 모두에서 형 사용을 검사하십시오).</p></li>
</ol>
</div>
<div class="section" id="details">
<h2>세부 사항<a class="headerlink" href="#details" title="제목 주소">¶</a></h2>
<p>파이썬 2와 3을 동시에 지원하는 것에 대한 요점은 <strong>오늘</strong> 시작할 수 있다는 것입니다! 의존성이 아직 파이썬 3를 지원하지 않을 때 조차 여려분의 코드를 파이썬 3를 지원하도록 <strong>지금</strong> 현대화할 수 없다는 뜻은 아닙니다. 파이썬 3를 지원하는데 필요한 대부분의 변경은 파이썬 2 코드에서도 새로운 방법을 사용하여 더 깔끔한 코드를 만듭니다.</p>
<p>또 다른 요점은 파이썬 3도 지원하도록 파이썬 2 코드를 현대화하는 것이 대부분 자동화되어 있다는 것입니다. 여러분이 일부 API 결정을 내려야 할 수도 있지만, 텍스트 데이터와 바이너리 데이터를 명확히 구분하는 파이썬 3 덕분에, 이제 저수준 작업이 대부분 수행되므로 최소한 자동 변경의 이점을 즉시 누릴 수 있습니다.</p>
<p>파이썬 2와 3을 동시에 지원하기 위해 코드를 이식하는 것에 대한 자세한 내용을 읽는 동안 이러한 요점을 명심하십시오.</p>
<div class="section" id="drop-support-for-python-2-6-and-older">
<h3>파이썬 2.6이하에 대한 지원을 중단하십시오<a class="headerlink" href="#drop-support-for-python-2-6-and-older" title="제목 주소">¶</a></h3>
<p>파이썬 2.5를 파이썬 3에서 동작하게 만들 수 있지만, 파이썬 2.7만 지원한다면 <strong>훨씬</strong> 쉽습니다. 파이썬 2.5를 포기하는 것이 옵션이 아니면 <a class="reference external" href="https://pypi.org/project/six">six</a> 프로젝트를 사용해서 파이썬 2.5와 3을 동시에 지원할 수 있습니다 (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">six</span></code>). 그러나 이 HOWTO에 나열된 거의 모든 프로젝트를 이용할 수 없다는 것을 알고 계십시오.</p>
<p>파이썬 2.5와 그 이전 버전을 무시할 수 있다면, 코드에 필요한 변경 사항은 계속 관용적인 파이썬 코드처럼 보이고 느껴져야 합니다. 최악의 경우 일부 인스턴스에서 메서드 대신 함수를 사용해야하거나 내장 함수를 사용하는 대신 함수를 임포트해야 하지만, 그외에는 전체적인 변환이 이질적으로 느껴지지 않아야합니다.</p>
<p>그러나 파이썬 2.7 만 지원해야합니다. 파이썬 2.6은 더는 무료로 지원되지 않아서 버그 수정이 없습니다. 이것은 여러분이 만나는 파이썬 2.6의 문제를 <strong>여러분이</strong> 해결해야한다는 뜻입니다. 이 HOWTO에서 언급하는 몇가지 도구는 파이썬 2.6을 지원하지 않기도 하고 (예를 들어 <a class="reference external" href="https://pypi.org/project/pylint">Pylint</a>), 시간이 지남에 따라 더 늘어날 것입니다. 지원해야만 하는 파이썬 버전만 지원하는 것이 더 쉬울 것입니다.</p>
</div>
<div class="section" id="make-sure-you-specify-the-proper-version-support-in-your-setup-py-file">
<h3><code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 파일에서 올바른 버전 지원을 지정했는지 확인하십시오<a class="headerlink" href="#make-sure-you-specify-the-proper-version-support-in-your-setup-py-file" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 파일에는 여러분이 지원하는 파이썬 버전을 지정하는 적절한 <a class="reference external" href="https://pypi.org/classifiers">trove 분류</a>가 있어야합니다. 여러분의 프로젝트가 아직 파이썬 3을 지원하지 않으므로 최소한 <code class="docutils literal notranslate"><span class="pre">Programming</span> <span class="pre">Language</span> <span class="pre">::</span> <span class="pre">Python</span> <span class="pre">::</span> <span class="pre">2</span> <span class="pre">::</span> <span class="pre">Only</span></code>를 지정해야합니다. 이상적으로는 지원하는 각 주/부 버전의 파이썬을 지정해야합니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">Programming</span> <span class="pre">Language</span> <span class="pre">::</span> <span class="pre">Python</span> <span class="pre">::</span> <span class="pre">2.7</span></code>.</p>
</div>
<div class="section" id="have-good-test-coverage">
<h3>양호한 테스트 커버리지를 갖추십시오<a class="headerlink" href="#have-good-test-coverage" title="제목 주소">¶</a></h3>
<p>일단 여러분이 원하는 가장 오래된 파이썬 2 버전을 지원하는 코드를 확보하면, 테스트 스위트가 양호한 커버리지를 갖는지 확인해야합니다. 경험 규칙은 도구가 코드를 다시 작성한 후 나타나는 실패가 여러분의 코드가 아니라 도구에 있는 실제 버그라는 확신을 가질 만큼 테스트 스위트를 신뢰할 수 있는 수준입니다. 목표로 할 숫자가 필요하다면, 80% 이상의 커버리지를 시도하십시오 (그리고 90% 이상의 커버리지를 얻기 어려워도 실망하지 마십시오). 테스트 커버리지를 측정하는 도구가 없으면 <a class="reference external" href="https://pypi.org/project/coverage">coverage.py</a>를 추천합니다.</p>
</div>
<div class="section" id="learn-the-differences-between-python-2-3">
<h3>파이썬 2와 3의 차이점을 공부하십시오<a class="headerlink" href="#learn-the-differences-between-python-2-3" title="제목 주소">¶</a></h3>
<p>코드를 잘 테스트했으면, 코드를 파이썬 3으로 이식할 준비가 되었습니다! 그러나 코드가 어떻게 변경되고 코드를 작성하는 동안 무엇을 살펴야 하는지 완전히 이해하려면, 파이썬 3이 파이썬 2에 어떤 변경을 가했는지 배우고 싶을 것입니다. 일반적으로 두 가지 가장 좋은 방법은 각 파이썬 3 릴리스의 <a class="reference external" href="https://python.flowdas.com/whatsnew/index.html">&quot;새로운 기능&quot;</a> 문서와 <a class="reference external" href="http://python3porting.com/">Porting to Python 3</a> 책(온라인에서 무료로 제공됩니다)을 읽는 것입니다. Python-Future 프로젝트의 편리한 <a class="reference external" href="http://python-future.org/compatible_idioms.html">cheat sheet</a>도 있습니다.</p>
</div>
<div class="section" id="update-your-code">
<h3>여러분의 코드를 갱신하십시오<a class="headerlink" href="#update-your-code" title="제목 주소">¶</a></h3>
<p>일단 파이썬 3과 파이썬 2의 차이점이 무엇인지 안다고 느끼면, 코드를 갱신할 차례입니다! 여러분의 코드를 자동으로 이식하는 두 가지 도구 중에서 선택할 수 있습니다: <a class="reference external" href="http://python-future.org/automatic_conversion.html">Futurize</a>와 <a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a>. 어떤 도구를 선택 하느냐는 여러분의 코드를 얼마나 파이썬 3답게 만들고 싶은지에 달려 있습니다. <a class="reference external" href="http://python-future.org/automatic_conversion.html">Futurize</a>는 파이썬 3 관용구와 관행을 파이썬 2에 존재하도록 만들기 위해 최선을 다합니다, 예를 들어 파이썬 3의 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 형을 역 이식하여 파이썬의 주 버전들 간에 의미론적 일치가 이루어지도록 합니다. 반면 <a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a>는 더 보수적이며 호환성을 제공하기 위해 <a class="reference external" href="https://pypi.org/project/six">six</a>에 직접 의존하면서 파이썬의 파이썬 2/3 부분 집합을 타깃으로 합니다. 파이썬 3이 미래이기 때문에, 아직 익숙하지 않은 파이썬 3이 도입한 새로운 관행에 적응하기 시작하려면 Futurize를 고려하는 것이 가장 좋습니다.</p>
<p>어떤 도구를 선택하든, 파이썬 3에서 실행되도록 코드를 갱신하면서 여러분이 시작한 파이썬 2 버전과 호환되도록 유지합니다. 여러분이 얼마나 보수적이고 싶은지에 따라, 먼저 테스트 스위트에 도구를 실행하고 diff를 시각적으로 검사하여 변환이 정확한지 확인하고 싶을 수 있습니다. 테스트 스위트를 변환하고 모든 테스트가 여전히 예상대로 통과되는지 확인한 후에는, 실패한 모든 테스트가 변환 실패임을 아는 상태에서 응용 프로그램 코드를 변환할 수 있습니다.</p>
<p>불행히도 도구가 파이썬 3에서 코드가 작동하도록 모든 것을 자동화 할 수는 없기 때문에, 완전한 파이썬 3 지원을 얻기 위해 수동으로 갱신해야하는 몇 가지 사항이 있습니다 (이 단계의 어떤 것이 필요한지는 도구마다 다릅니다). 어떤 것이 자동으로 수정 되고 (또는 되지 않고) 어떤 것을 여러분이 직접 수정해야하는지 알기 위해, 기본적으로 수정되는 것과 선택적으로 수정되는 것에 대해 여러분이 선택한 도구의 설명서를 읽으십시오 (예를 들어 Modernize에서는 내장 <code class="docutils literal notranslate"><span class="pre">open()</span></code> 함수대신 <code class="docutils literal notranslate"><span class="pre">io.open()</span></code>을 사용하는 것은 기본적으로 꺼져 있습니다). 다행히, 주의하지 않으면 디버깅하기 어려운 큰 문제로 간주할 수 있는 주의해야 할 사항은 몇 가지 뿐입니다.</p>
<div class="section" id="division">
<h4>나누기<a class="headerlink" href="#division" title="제목 주소">¶</a></h4>
<p>파이썬 3에서, <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">2.5</span></code>이고 <code class="docutils literal notranslate"><span class="pre">2</span></code>가 아닙니다; <code class="docutils literal notranslate"><span class="pre">int</span></code> 값 간의 모든 나누기는 <code class="docutils literal notranslate"><span class="pre">float</span></code>가 됩니다. 이 변경은 실제로는 2002 년에 릴리스된 파이썬 2.2 부터 계획되었습니다. 그때 부터 <code class="docutils literal notranslate"><span class="pre">/</span></code>와 <code class="docutils literal notranslate"><span class="pre">//</span></code> 연산자를 사용하는 모든 파일에 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>을 추가하거나 <code class="docutils literal notranslate"><span class="pre">-Q</span></code> 플래그로 인터프리터를 실행하도록 권장되었습니다. 이 작업을 수행하지 않았으면 코드를 살펴보고 두 가지 작업을 수행해야합니다:</p>
<ol class="arabic simple">
<li><p>여러분의 파일에 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>을 추가하십시오</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">//</span></code>를 사용하여 정수 나눗셈을 사용하거나 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 계속 사용하고 float를 기대하도록 필요에 따라 나눗셈 연산자를 갱신하십시오</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">/</span></code>가 단순히 <code class="docutils literal notranslate"><span class="pre">//</span></code>로 자동 변환되지 않는 이유는 객체가 <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code> 메서드를 정의하지만 <code class="docutils literal notranslate"><span class="pre">__floordiv__</span></code>를 정의하지 않으면 코드가 실패하기 시작하기 때문입니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 사용하여 일부 작업을 나타내지만 <code class="docutils literal notranslate"><span class="pre">//</span></code>로는 같은 것을 하지 않거나 아예 지원하지 않는 사용자 정의 클래스).</p>
</div>
<div class="section" id="text-versus-binary-data">
<h4>텍스트 대 바이너리 데이터<a class="headerlink" href="#text-versus-binary-data" title="제목 주소">¶</a></h4>
<p>파이썬 2에서는 텍스트와 바이너리 데이터 모두에 <code class="docutils literal notranslate"><span class="pre">str</span></code> 형을 사용할 수 있습니다. 불행히도 이 두 가지 다른 개념의 합류로 인해 때로는 두 유형의 데이터 모두에서 동작하고 때로는 동작하지 않는 믿을 수 없는 코드가 만들어질 수 있습니다. 하나의 구체적인 형 대신에 <code class="docutils literal notranslate"><span class="pre">str</span></code>로 받아들인 것이 텍스트나 바이너리 데이터 중 어느 것을 받아들이는지 명시적으로 언급하지 않으면 혼란스러운 API가 될 수 있습니다. API가 텍스트 데이터 지원을 주장할 때 명시적으로 <code class="docutils literal notranslate"><span class="pre">unicode</span></code>를 지원하지 않을 수 있어서 여러 언어를 지원하는 사람에게는 특히 상황을 복잡하게 만듭니다.</p>
<p>텍스트와 바이너리 데이터의 구별을보다 명확하고 뚜렷하게하기 위해, 파이썬 3은 인터넷 시대에 만들어진 대부분의 언어가 수행한 작업을 수행했으며 텍스트와 바이너리 데이터를 맹목적으로 혼합할 수 없는 고유한 형으로 만들었습니다 (파이썬은 인터넷이 널리 퍼지기 전부터 존재해 왔습니다). 텍스트나 바이너리 데이터 어느 한가지 만 처리하는 코드의 경우, 이 분리는 문제를 일으키지 않습니다. 그러나 두 가지를 모두 다뤄야하는 코드의 경우, 언제 텍스트 데이터를, 언제 바이너리 데이터를 사용해야 할지 이제 신경 써야 할 수 있음을 뜻하고, 이것이 완전히 자동화 할 수 없는 이유입니다.</p>
<p>To start, you will need to decide which APIs take text and which take binary
(it is <strong>highly</strong> recommended you don't design APIs that can take both due to
the difficulty of keeping the code working; as stated earlier it is difficult to
do well). In Python 2 this means making sure the APIs that take text can work
with <code class="docutils literal notranslate"><span class="pre">unicode</span></code> and those that work with binary data work with the
<code class="docutils literal notranslate"><span class="pre">bytes</span></code> type from Python 3 (which is a subset of <code class="docutils literal notranslate"><span class="pre">str</span></code> in Python 2 and acts
as an alias for <code class="docutils literal notranslate"><span class="pre">bytes</span></code> type in Python 2). Usually the biggest issue is
realizing which methods exist on which types in Python 2 &amp; 3 simultaneously
(for text that's <code class="docutils literal notranslate"><span class="pre">unicode</span></code> in Python 2 and <code class="docutils literal notranslate"><span class="pre">str</span></code> in Python 3, for binary
that's <code class="docutils literal notranslate"><span class="pre">str</span></code>/<code class="docutils literal notranslate"><span class="pre">bytes</span></code> in Python 2 and <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in Python 3). The following
table lists the <strong>unique</strong> methods of each data type across Python 2 &amp; 3
(e.g., the <code class="docutils literal notranslate"><span class="pre">decode()</span></code> method is usable on the equivalent binary data type in
either Python 2 or 3, but it can't be used by the textual data type consistently
between Python 2 and 3 because <code class="docutils literal notranslate"><span class="pre">str</span></code> in Python 3 doesn't have the method). Do
note that as of Python 3.5 the <code class="docutils literal notranslate"><span class="pre">__mod__</span></code> method was added to the bytes type.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 47%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Text data</strong></p></td>
<td><p><strong>Binary data</strong></p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>decode</p></td>
</tr>
<tr class="row-odd"><td><p>encode</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>format</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>isdecimal</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>isnumeric</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Making the distinction easier to handle can be accomplished by encoding and
decoding between binary data and text at the edge of your code. This means that
when you receive text in binary data, you should immediately decode it. And if
your code needs to send text as binary data then encode it as late as possible.
This allows your code to work with only text internally and thus eliminates
having to keep track of what type of data you are working with.</p>
<p>The next issue is making sure you know whether the string literals in your code
represent text or binary data. You should add a <code class="docutils literal notranslate"><span class="pre">b</span></code> prefix to any
literal that presents binary data. For text you should add a <code class="docutils literal notranslate"><span class="pre">u</span></code> prefix to
the text literal. (there is a <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> import to force all unspecified
literals to be Unicode, but usage has shown it isn't as effective as adding a
<code class="docutils literal notranslate"><span class="pre">b</span></code> or <code class="docutils literal notranslate"><span class="pre">u</span></code> prefix to all literals explicitly)</p>
<p>As part of this dichotomy you also need to be careful about opening files.
Unless you have been working on Windows, there is a chance you have not always
bothered to add the <code class="docutils literal notranslate"><span class="pre">b</span></code> mode when opening a binary file (e.g., <code class="docutils literal notranslate"><span class="pre">rb</span></code> for
binary reading).  Under Python 3, binary files and text files are clearly
distinct and mutually incompatible; see the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> module for details.
Therefore, you <strong>must</strong> make a decision of whether a file will be used for
binary access (allowing binary data to be read and/or written) or textual access
(allowing text data to be read and/or written). You should also use <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a>
for opening files instead of the built-in <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> function as the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>
module is consistent from Python 2 to 3 while the built-in <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> function
is not (in Python 3 it's actually <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a>). Do not bother with the
outdated practice of using <a class="reference internal" href="../library/codecs.html#codecs.open" title="codecs.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.open()</span></code></a> as that's only necessary for
keeping compatibility with Python 2.5.</p>
<p>The constructors of both <code class="docutils literal notranslate"><span class="pre">str</span></code> and <code class="docutils literal notranslate"><span class="pre">bytes</span></code> have different semantics for the
same arguments between Python 2 &amp; 3. Passing an integer to <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in Python 2
will give you the string representation of the integer: <code class="docutils literal notranslate"><span class="pre">bytes(3)</span> <span class="pre">==</span> <span class="pre">'3'</span></code>.
But in Python 3, an integer argument to <code class="docutils literal notranslate"><span class="pre">bytes</span></code> will give you a bytes object
as long as the integer specified, filled with null bytes:
<code class="docutils literal notranslate"><span class="pre">bytes(3)</span> <span class="pre">==</span> <span class="pre">b'\x00\x00\x00'</span></code>. A similar worry is necessary when passing a
bytes object to <code class="docutils literal notranslate"><span class="pre">str</span></code>. In Python 2 you just get the bytes object back:
<code class="docutils literal notranslate"><span class="pre">str(b'3')</span> <span class="pre">==</span> <span class="pre">b'3'</span></code>. But in Python 3 you get the string representation of the
bytes object: <code class="docutils literal notranslate"><span class="pre">str(b'3')</span> <span class="pre">==</span> <span class="pre">&quot;b'3'&quot;</span></code>.</p>
<p>Finally, the indexing of binary data requires careful handling (slicing does
<strong>not</strong> require any special handling). In Python 2,
<code class="docutils literal notranslate"><span class="pre">b'123'[1]</span> <span class="pre">==</span> <span class="pre">b'2'</span></code> while in Python 3 <code class="docutils literal notranslate"><span class="pre">b'123'[1]</span> <span class="pre">==</span> <span class="pre">50</span></code>. Because binary data
is simply a collection of binary numbers, Python 3 returns the integer value for
the byte you index on. But in Python 2 because <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">==</span> <span class="pre">str</span></code>, indexing
returns a one-item slice of bytes. The <a class="reference external" href="https://pypi.org/project/six">six</a> project has a function
named <code class="docutils literal notranslate"><span class="pre">six.indexbytes()</span></code> which will return an integer like in Python 3:
<code class="docutils literal notranslate"><span class="pre">six.indexbytes(b'123',</span> <span class="pre">1)</span></code>.</p>
<p>To summarize:</p>
<ol class="arabic simple">
<li><p>Decide which of your APIs take text and which take binary data</p></li>
<li><p>Make sure that your code that works with text also works with <code class="docutils literal notranslate"><span class="pre">unicode</span></code> and
code for binary data works with <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in Python 2 (see the table above
for what methods you cannot use for each type)</p></li>
<li><p>Mark all binary literals with a <code class="docutils literal notranslate"><span class="pre">b</span></code> prefix, textual literals with a <code class="docutils literal notranslate"><span class="pre">u</span></code>
prefix</p></li>
<li><p>Decode binary data to text as soon as possible, encode text as binary data as
late as possible</p></li>
<li><p>Open files using <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a> and make sure to specify the <code class="docutils literal notranslate"><span class="pre">b</span></code> mode when
appropriate</p></li>
<li><p>Be careful when indexing into binary data</p></li>
</ol>
</div>
<div class="section" id="use-feature-detection-instead-of-version-detection">
<h4>Use feature detection instead of version detection<a class="headerlink" href="#use-feature-detection-instead-of-version-detection" title="제목 주소">¶</a></h4>
<p>Inevitably you will have code that has to choose what to do based on what
version of Python is running. The best way to do this is with feature detection
of whether the version of Python you're running under supports what you need.
If for some reason that doesn't work then you should make the version check be
against Python 2 and not Python 3. To help explain this, let's look at an
example.</p>
<p>Let's pretend that you need access to a feature of <a class="reference external" href="https://python.flowdas.com/library/importlib.html#module-importlib">importlib</a> that
is available in Python's standard library since Python 3.3 and available for
Python 2 through <a class="reference external" href="https://pypi.org/project/importlib2">importlib2</a> on PyPI. You might be tempted to write code to
access e.g. the <code class="docutils literal notranslate"><span class="pre">importlib.abc</span></code> module by doing the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib</span> <span class="k">import</span> <span class="n">abc</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib2</span> <span class="k">import</span> <span class="n">abc</span>
</pre></div>
</div>
<p>The problem with this code is what happens when Python 4 comes out? It would
be better to treat Python 2 as the exceptional case instead of Python 3 and
assume that future Python versions will be more compatible with Python 3 than
Python 2:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib</span> <span class="k">import</span> <span class="n">abc</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib2</span> <span class="k">import</span> <span class="n">abc</span>
</pre></div>
</div>
<p>The best solution, though, is to do no version detection at all and instead rely
on feature detection. That avoids any potential issues of getting the version
detection wrong and helps keep you future-compatible:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib</span> <span class="k">import</span> <span class="n">abc</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib2</span> <span class="k">import</span> <span class="n">abc</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="prevent-compatibility-regressions">
<h3>Prevent compatibility regressions<a class="headerlink" href="#prevent-compatibility-regressions" title="제목 주소">¶</a></h3>
<p>Once you have fully translated your code to be compatible with Python 3, you
will want to make sure your code doesn't regress and stop working under
Python 3. This is especially true if you have a dependency which is blocking you
from actually running under Python 3 at the moment.</p>
<p>To help with staying compatible, any new modules you create should have
at least the following block of code at the top of it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
</pre></div>
</div>
<p>You can also run Python 2 with the <code class="docutils literal notranslate"><span class="pre">-3</span></code> flag to be warned about various
compatibility issues your code triggers during execution. If you turn warnings
into errors with <code class="docutils literal notranslate"><span class="pre">-Werror</span></code> then you can make sure that you don't accidentally
miss a warning.</p>
<p>You can also use the <a class="reference external" href="https://pypi.org/project/pylint">Pylint</a> project and its <code class="docutils literal notranslate"><span class="pre">--py3k</span></code> flag to lint your code
to receive warnings when your code begins to deviate from Python 3
compatibility. This also prevents you from having to run <a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a> or <a class="reference external" href="http://python-future.org/automatic_conversion.html">Futurize</a>
over your code regularly to catch compatibility regressions. This does require
you only support Python 2.7 and Python 3.4 or newer as that is Pylint's
minimum Python version support.</p>
</div>
<div class="section" id="check-which-dependencies-block-your-transition">
<h3>Check which dependencies block your transition<a class="headerlink" href="#check-which-dependencies-block-your-transition" title="제목 주소">¶</a></h3>
<p><strong>After</strong> you have made your code compatible with Python 3 you should begin to
care about whether your dependencies have also been ported. The <a class="reference external" href="https://pypi.org/project/caniusepython3">caniusepython3</a>
project was created to help you determine which projects
-- directly or indirectly -- are blocking you from supporting Python 3. There
is both a command-line tool as well as a web interface at
<a class="reference external" href="https://caniusepython3.com">https://caniusepython3.com</a>.</p>
<p>The project also provides code which you can integrate into your test suite so
that you will have a failing test when you no longer have dependencies blocking
you from using Python 3. This allows you to avoid having to manually check your
dependencies and to be notified quickly when you can start running on Python 3.</p>
</div>
<div class="section" id="update-your-setup-py-file-to-denote-python-3-compatibility">
<h3>Update your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file to denote Python 3 compatibility<a class="headerlink" href="#update-your-setup-py-file-to-denote-python-3-compatibility" title="제목 주소">¶</a></h3>
<p>Once your code works under Python 3, you should update the classifiers in
your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> to contain <code class="docutils literal notranslate"><span class="pre">Programming</span> <span class="pre">Language</span> <span class="pre">::</span> <span class="pre">Python</span> <span class="pre">::</span> <span class="pre">3</span></code> and to not
specify sole Python 2 support. This will tell anyone using your code that you
support Python 2 <strong>and</strong> 3. Ideally you will also want to add classifiers for
each major/minor version of Python you now support.</p>
</div>
<div class="section" id="use-continuous-integration-to-stay-compatible">
<h3>Use continuous integration to stay compatible<a class="headerlink" href="#use-continuous-integration-to-stay-compatible" title="제목 주소">¶</a></h3>
<p>Once you are able to fully run under Python 3 you will want to make sure your
code always works under both Python 2 &amp; 3. Probably the best tool for running
your tests under multiple Python interpreters is <a class="reference external" href="https://pypi.org/project/tox">tox</a>. You can then integrate
tox with your continuous integration system so that you never accidentally break
Python 2 or 3 support.</p>
<p>You may also want to use the <code class="docutils literal notranslate"><span class="pre">-bb</span></code> flag with the Python 3 interpreter to
trigger an exception when you are comparing bytes to strings or bytes to an int
(the latter is available starting in Python 3.5). By default type-differing
comparisons simply return <code class="docutils literal notranslate"><span class="pre">False</span></code>, but if you made a mistake in your
separation of text/binary data handling or indexing on bytes you wouldn't easily
find the mistake. This flag will raise an exception when these kinds of
comparisons occur, making the mistake much easier to track down.</p>
<p>And that's mostly it! At this point your code base is compatible with both
Python 2 and 3 simultaneously. Your testing will also be set up so that you
don't accidentally break Python 2 or 3 compatibility regardless of which version
you typically run your tests under while developing.</p>
</div>
<div class="section" id="consider-using-optional-static-type-checking">
<h3>Consider using optional static type checking<a class="headerlink" href="#consider-using-optional-static-type-checking" title="제목 주소">¶</a></h3>
<p>Another way to help port your code is to use a static type checker like
<a class="reference external" href="http://mypy-lang.org/">mypy</a> or <a class="reference external" href="https://github.com/google/pytype">pytype</a> on your code. These tools can be used to analyze your code as
if it's being run under Python 2, then you can run the tool a second time as if
your code is running under Python 3. By running a static type checker twice like
this you can discover if you're e.g. misusing binary data type in one version
of Python compared to another. If you add optional type hints to your code you
can also explicitly state whether your APIs use textual or binary data, helping
to make sure everything functions as expected in both versions of Python.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">파이썬 2 코드를 파이썬 3으로 이식하기</a><ul>
<li><a class="reference internal" href="#the-short-explanation">짧은 설명</a></li>
<li><a class="reference internal" href="#details">세부 사항</a><ul>
<li><a class="reference internal" href="#drop-support-for-python-2-6-and-older">파이썬 2.6이하에 대한 지원을 중단하십시오</a></li>
<li><a class="reference internal" href="#make-sure-you-specify-the-proper-version-support-in-your-setup-py-file"><code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 파일에서 올바른 버전 지원을 지정했는지 확인하십시오</a></li>
<li><a class="reference internal" href="#have-good-test-coverage">양호한 테스트 커버리지를 갖추십시오</a></li>
<li><a class="reference internal" href="#learn-the-differences-between-python-2-3">파이썬 2와 3의 차이점을 공부하십시오</a></li>
<li><a class="reference internal" href="#update-your-code">여러분의 코드를 갱신하십시오</a><ul>
<li><a class="reference internal" href="#division">나누기</a></li>
<li><a class="reference internal" href="#text-versus-binary-data">텍스트 대 바이너리 데이터</a></li>
<li><a class="reference internal" href="#use-feature-detection-instead-of-version-detection">Use feature detection instead of version detection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prevent-compatibility-regressions">Prevent compatibility regressions</a></li>
<li><a class="reference internal" href="#check-which-dependencies-block-your-transition">Check which dependencies block your transition</a></li>
<li><a class="reference internal" href="#update-your-setup-py-file-to-denote-python-3-compatibility">Update your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file to denote Python 3 compatibility</a></li>
<li><a class="reference internal" href="#use-continuous-integration-to-stay-compatible">Use continuous integration to stay compatible</a></li>
<li><a class="reference internal" href="#consider-using-optional-static-type-checking">Consider using optional static type checking</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="index.html"
                        title="이전 장">파이썬 HOWTO</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="cporting.html"
                        title="다음 장">확장 모듈을 파이썬 3에 이식하기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="cporting.html" title="확장 모듈을 파이썬 3에 이식하기"
             >다음</a> |</li>
        <li class="right" >
          <a href="index.html" title="파이썬 HOWTO"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>