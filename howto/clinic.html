
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>인자 클리닉 How-To &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="DTrace와 SystemTap으로 CPython 계측하기" href="instrumentation.html" />
    <link rel="prev" title="ipaddress 모듈에 대한 소개" href="ipaddress.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/howto/clinic.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="instrumentation.html" title="DTrace와 SystemTap으로 CPython 계측하기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="ipaddress.html" title="ipaddress 모듈에 대한 소개"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="argument-clinic-how-to">
<h1>인자 클리닉 How-To<a class="headerlink" href="#argument-clinic-how-to" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">저자</dt>
<dd class="field-odd"><p>Larry Hastings</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title first">요약</p>
<p>인자 클리닉(Argument Clinic)은 CPython C 파일을 위한 전 처리기입니다. 그 목적은 &quot;내장&quot;에 대한 인자 구문 분석 코드 작성과 관련된 모든 상용구를 자동화하는 것입니다. 이 설명서는 여러분의 첫 번째 C 함수를 인자 클리닉과 함께 작동하도록 변환하는 방법을 보여준 다음, 인자 클리닉 사용에 대한 몇 가지 고급 주제를 소개합니다.</p>
<p>현재 인자 클리닉은 CPython에 내부 전용으로 간주됩니다. CPython 외부의 파일에 대해서는 사용이 지원되지 않으며, 향후 버전에서 이전 버전과의 호환성을 보장하지 않습니다. 즉: 여러분이 CPython에 대한 외부 C 확장을 유지한다면, 여러분의 자체 코드에서 인자 클리닉을 실험하는 것은 환영합니다. 그러나 다음 버전의 CPython과 함께 제공되는 인자 클리닉 버전은 완전히 호환되지 않고 여러분의 모든 코드를 망가뜨릴 수 <em>있습니다</em>.</p>
</div>
<div class="section" id="the-goals-of-argument-clinic">
<h2>인자 클리닉의 목표<a class="headerlink" href="#the-goals-of-argument-clinic" title="제목 주소">¶</a></h2>
<p>인자 클리닉의 주요 목표는 CPython 내부의 모든 인자 구문 분석 코드에 대한 책임을 인수하는 것입니다. 즉, 인자 클리닉에서 작동하도록 함수를 변환할 때, 해당 함수는 더는 자체 인자 구문 분석을 수행하지 않아야합니다 - 인자 클리닉에서 생성된 코드는 여러분에게 &quot;블랙 박스&quot;여야 합니다, CPython이 맨 위에서 호출하고, 맨 아래에서 여러분의 코드가 호출되고, <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*args</span></code> (그리고 아마도 <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*kwargs</span></code>)가 여러분이 필요로 하는 C 변수와 형으로 마술처럼 변환됩니다.</p>
<p>인자 클리닉이 기본 목표를 달성하려면, 사용하기 쉬워야합니다. 현재, CPython의 인자 구문 분석 라이브러리로 작업하는 것은 따분한 일이며, 놀랄 정도로 많은 장소에서 중복된 정보를 유지해야합니다. 인자 클리닉을 사용할 때, 여러분 스스로 반복 할 필요가 없습니다.</p>
<p>분명히, 자체적으로 새로운 문제를 만들지 않으면서 자신의 문제를 해결하지 않는 한 아무도 인자 클리닉을 사용하고 싶어하지 않을 것입니다. 따라서 인자 클리닉이 올바른 코드를 생성하는 것이 가장 중요합니다. 코드가 더 빠르면 좋겠지만, 최소한 주요 속도 회귀를 도입해서는 안됩니다. (결국 인자 클리닉은 대폭적인 속도 향상을 가능하게 해야 <em>합니다</em> - 범용 CPython 인자 구문 분석 라이브러리를 호출하는 대신 맞춤형 인자 구문 분석 코드를 생성하도록 코드 생성기를 다시 작성할 수 있습니다. 그러면 가능한 가장 빠른 인자 구문 분석이 될 것입니다!)</p>
<p>또한, 인자 클리닉은 인자 구문 분석에 대한 모든 접근 방식을 사용할 수 있을만큼 유연해야합니다. 파이썬에는 매우 이상한 구문 분석 동작을 가진 몇 가지 함수가 있습니다; 인자 클리닉의 목표는 이들 모두를 지원하는 것입니다.</p>
<p>마지막으로, 인자 클리닉의 원래 동기는 CPython 내장에 대한 인트로스펙션 &quot;서명&quot;을 제공하는 것이었습니다. 예전에는 내장을 전달하면 인트로스펙션 조회 함수에서 예외가 발생했습니다. 인자 클리닉을 사용하면, 그것은 과거의 일입니다!</p>
<p>인자 클리닉과 함께 일할 때, 명심해야 할 한 가지 아이디어가 있습니다: 더 많은 정보를 제공할수록, 더 나은 작업을 수행할 수 있습니다. 인자 클리닉은 현재 비교적 간단합니다. 그러나 진화함에 따라 더 정교해질 것이며, 여러분이 제공하는 모든 정보로 많은 흥미롭고 현명한 일을 할 수 있어야합니다.</p>
</div>
<div class="section" id="basic-concepts-and-usage">
<h2>기본 개념과 사용법<a class="headerlink" href="#basic-concepts-and-usage" title="제목 주소">¶</a></h2>
<p>인자 클리닉은 CPython과 함께 제공됩니다; <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>에서 찾을 수 있습니다. 해당 스크립트를 실행하면, C 파일을 인자로 지정합니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python3 Tools/clinic/clinic.py foo.c
</pre></div>
</div>
<p>인자 클리닉은 파일을 스캔하여 다음과 같은 줄을 찾습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*[clinic input]
</pre></div>
</div>
<p>찾으면, 다음과 같은 줄까지 모든 것을 읽습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[clinic start generated code]*/
</pre></div>
</div>
<p>이 두 줄 사이의 모든 것은 인자 클리닉에 대한 입력입니다. 시작과 끝 주석 줄을 포함하여, 이러한 모든 줄을 총칭하여 인자 클리닉 &quot;블록&quot;이라고 합니다.</p>
<p>인자 클리닉이 이러한 블록 중 하나를 구문 분석할 때, 출력을 생성합니다. 이 출력은 C 파일의 블록 바로 뒤에 다시 쓰여지고, 체크섬이 포함된 주석이 이어집니다. 인자 클리닉 블록은 이제 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*[clinic input]
... clinic input goes here ...
[clinic start generated code]*/
... clinic output goes here ...
/*[clinic end generated code: checksum=...]*/
</pre></div>
</div>
<p>같은 파일에서 인자 클리닉을 두 번 실행하면, 인자 클리닉은 이전 출력을 버리고 새로운 체크섬 줄로 새 출력을 작성합니다. 그러나, 입력이 변경되지 않았으면, 출력도 변경되지 않습니다.</p>
<p>인자 클리닉 블록의 출력 부분을 수정해서는 안됩니다. 대신, 원하는 출력을 생성 할 때까지 입력을 변경하십시오. (그것이 체크섬의 목적입니다 - 누군가 출력을 변경했는지 감지하는 것, 다음에 인자 클리닉이 새로운 출력을 작성할 때 이러한 편집이 손실되기 때문입니다.)</p>
<p>명확성을 위해, 인자 클리닉에서 사용할 용어는 다음과 같습니다:</p>
<ul class="simple">
<li><p>주석의 첫 번째 줄(<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">input]</span></code>)은 <em>시작 줄(start line)</em>입니다.</p></li>
<li><p>초기 주석의 마지막 줄(<code class="docutils literal notranslate"><span class="pre">[clinic</span> <span class="pre">start</span> <span class="pre">generated</span> <span class="pre">code]*/</span></code>)은 <em>끝 줄(end line)</em>입니다.</p></li>
<li><p>마지막 줄(<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">end</span> <span class="pre">generated</span> <span class="pre">code:</span> <span class="pre">checksum=...]*/</span></code>)은 <em>체크섬 줄(checksum line)</em>입니다.</p></li>
<li><p>시작 줄과 끝 줄 사이에 잇는 것이 <em>입력(input)</em>입니다.</p></li>
<li><p>끝 줄과 체크섬 줄 사이에 있는 것이 <em>출력(output)</em>입니다.</p></li>
<li><p>시작 줄에서 체크섬 줄까지 모든 텍스트는 총칭하여 <em>블록(block)</em>입니다. (인자 클리닉에서 성공적으로 처리되지 않은 블록은 아직 출력이나 체크섬 줄이 없지만, 여전히 블록으로 간주합니다.)</p></li>
</ul>
</div>
<div class="section" id="converting-your-first-function">
<h2>첫 번째 함수 변환하기<a class="headerlink" href="#converting-your-first-function" title="제목 주소">¶</a></h2>
<p>인자 클리닉의 작동 방식을 이해하는 가장 좋은 방법은 함수를 작동하도록 변환하는 것입니다. 다음은, 인자 클리닉에서 작동하도록 함수를 변환하기 위해 따라야 할 최소한의 단계입니다. CPython에 체크인하려는 코드의 경우, 살명서의 뒷부분에서 볼 수있는 고급 개념(&quot;반환 변환기&quot;와 &quot;self 변환기&quot;와 같은)을 사용하여 변환 작업을 더 진행해야합니다. 하지만 이 연습에서는 배우기 쉽도록 간단하게 유지하겠습니다.</p>
<p>뛰어 듭시다!</p>
<ol class="arabic" start="0">
<li><p>CPython trunk의 새로 갱신된 체크 아웃으로 작업하고 있는지 확인하십시오.</p></li>
<li><p><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>를 호출하고, 아직 인자 클리닉에서 작동하도록 변환되지 않은 파이썬 내장을 찾습니다. 제 예에서는 <code class="docutils literal notranslate"><span class="pre">_pickle.Pickler.dump()</span></code>를 사용하고 있습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyArg_Parse</span></code> 함수에 대한 호출이 다음 포맷 단위 중 하나를 사용하거나:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>O&amp;
O!
es
es#
et
et#
</pre></div>
</div>
<p>또는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>에 대한 여러 호출이 있으면, 다른 함수를 선택해야합니다. 인자 클리닉은 이러한 모든 시나리오를 <em>지원합니다</em>. 그러나 이것들은 고급 주제입니다 - 첫 번째 함수로 더 간단한 것을 해봅시다.</p>
<p>또한, 함수가 같은 인자에 대해 다른 형을 지원하는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>에 대한 여러 호출이 있거나, 함수가 인자를 구문 분석하기 위해 PyArg_Parse 함수 이외의 것을 사용하면, 인자 클리닉으로 변환하는 데 적합하지 않을 수 있습니다. 인자 클리닉은 제네릭 함수나 다형성 매개 변수를 지원하지 않습니다.</p>
</li>
<li><p>함수 위에 다음과 같은 상용구를 추가하여, 블록을 만듭니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>독스트링을 잘라내어 <code class="docutils literal notranslate"><span class="pre">[clinic]</span></code> 줄 사이에 붙여 넣고, 적절하게 인용된 C 문자열을 만드는 모든 정크들을 제거합니다. 완료되면 왼쪽 여백을 기준으로 텍스트가 80자보다 넓은 줄이 없는, 텍스트만 남게됩니다. (인자 클리닉은 독스트링 내부의 들여 쓰기를 유지합니다.)</p>
<p>이전 독스트링에 함수 서명처럼 보이는 첫 번째 줄이 있으면, 해당 줄을 버립니다. (독스트링은 이것이 더는 필요하지 않습니다 - 향후 내장에 <code class="docutils literal notranslate"><span class="pre">help()</span></code>를 사용할 때, 첫 번째 줄은 함수의 서명에 따라 자동으로 구축됩니다.)</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>독스트링에 &quot;요약&quot; 줄이 없으면, 인자 클리닉이 불평합니다. 그러니 하나 있도록 합시다. &quot;요약&quot; 줄은 독스트링의 시작 부분에 있는 단일 80열 줄로 구성된 단락이어야 합니다.</p>
<p>(예제 독스트링은 요약 줄로만 구성되어서, 이 단계에서 샘플 코드를 변경할 필요가 없습니다.)</p>
</li>
<li><p>독스트링 위에, 함수 이름을 입력 한 다음, 빈 줄을 입력합니다. 이것은 함수의 파이썬 이름이어야하며, 함수에 대한 전체 점표기법 경로여야 합니다 - 모듈 이름으로 시작하고, 모든 하위 모듈을 포함해야하며, 함수가 클래스의 메서드이면 클래스 이름도 포함해야합니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>이 C 파일에서 해당 모듈이나 클래스가 인자 클리닉과 함께 처음 사용된 것이면, 모듈 및/또는 클래스를 선언해야합니다. 적절한 인자 클리닉 위생법은 인클루드 파일과 정적 객체가 상단에 가는 것과 같은 방식으로 C 파일의 상단 근처에 있는 별도의 블록에 이를 선언하는 것을 선호합니다. (샘플 코드에서는 서로 옆에 있는 두 블록만 표시합니다.)</p>
<p>클래스와 모듈의 이름은 파이썬에서 보는 이름과 같아야합니다. <a class="reference internal" href="../c-api/module.html#c.PyModuleDef" title="PyModuleDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyModuleDef</span></code></a>나 <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>에 정의된 이름을 적절하게 확인하십시오.</p>
<p>클래스를 선언할 때, C에서 해당 형의 두 가지 측면을 지정해야합니다: 이 클래스의 인스턴스에 대한 포인터에 사용할 형 선언, 그리고 이 클래스를 위한 <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>에 대한 포인터.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>각 매개 변수를 함수에 선언합니다. 각 매개 변수는 자체 줄을 가져야합니다. 모든 매개 변수 줄은 함수 이름과 독스트링에서 들여 쓰기되어야합니다.</p>
<p>이러한 매개 변수 줄의 일반적인 형식은 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name_of_parameter: converter
</pre></div>
</div>
<p>매개 변수에 기본값이 있으면, 변환기(converter) 뒤에 추가하십시오:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name_of_parameter: converter = default_value
</pre></div>
</div>
<p>&quot;기본값&quot;에 대한 인자 클리닉의 지원은 매우 정교합니다; 자세한 내용은 <a class="reference internal" href="#default-values"><span class="std std-ref">아래의 기본값에 관한 섹션</span></a>을 참조하십시오.</p>
<p>매개 변수 아래에 빈 줄을 추가합니다.</p>
<p>&quot;변환기(converter)&quot;는 무엇일까요? C에서 사용되는 변수의 형과, 실행 시간에 파이썬 값을 C 값으로 변환하는 방법을 모두 설정합니다. 지금은 이전 코드를 인자 클리닉으로 더 쉽게 이식할 수 있도록 고안된 편의 문법인 &quot;레거시 변환기&quot;를 사용할 것입니다.</p>
<p>매개 변수마다, <code class="docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code> format 인자에서 해당 매개 변수의 &quot;포맷 단위&quot;를 복사하고 <em>그것을</em> (따옴표로 묶은 문자열로) 변환기로 지정하십시오. (&quot;포맷 단위&quot;는 인자 구문 분석 함수에 변수 형과 변환 방법을 알려주는 <code class="docutils literal notranslate"><span class="pre">format</span></code> 매개 변수의 1~3 문자 부분 문자열에 대한 공식 이름입니다. 포맷 단위에 대한 자세한 내용은 <a class="reference internal" href="../c-api/arg.html#arg-parsing"><span class="std std-ref">인자 구문 분석과 값 구축</span></a>을 참조하십시오. )</p>
<p><code class="docutils literal notranslate"><span class="pre">z#</span></code>과 같은 다중 문자 포맷 단위의 경우, 전체 2~3 문자 문자열 전체를 사용합니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span> <span class="cm">/*[clinic input]</span>
<span class="cm"> module _pickle</span>
<span class="cm"> class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm"> [clinic start generated code]*/</span>

 <span class="cm">/*[clinic input]</span>
<span class="cm"> _pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>함수의 포맷 문자열에 <code class="docutils literal notranslate"><span class="pre">|</span></code>가 있으면 (일부 매개 변수에 기본값이 있음을 의미합니다), 무시할 수 있습니다. 인자 클리닉은 기본값이 있는지에 따라 어떤 매개 변수가 선택적인지 유추합니다.</p>
<p>함수의 포맷 문자열에 <code class="docutils literal notranslate"><span class="pre">$</span></code>가 있으면 (키워드 전용 인자를 취함을 의미합니다), 첫 번째 키워드 전용 인자 앞에 <code class="docutils literal notranslate"><span class="pre">*</span></code>를 별도의 줄로 지정하고 매개 변수 줄과 같게 들여 쓰기합니다.</p>
<p>(<code class="docutils literal notranslate"><span class="pre">_pickle.Pickler.dump</span></code>에는 둘 다 없어서, 샘플은 변경되지 않습니다.)</p>
</li>
<li><p>기존 C 함수가 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>를 호출하면 (<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>가 아니라), 모든 인자는 위치 전용입니다.</p>
<p>인자 클리닉에서 모든 매개 변수를 위치 전용으로 표시하려면, 마지막 매개 변수 뒤에 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 추가하고 매개 변수 줄과 같게 들여 쓰기합니다.</p>
<p>현재 이것은 전부아니면 전무입니다; 모든 매개 변수가 위치 전용이거나, 아무 것도 아닙니다. (향후 인자 클리닉에서 이 제한을 완화할 수 있습니다.)</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>매개 변수마다 매개 변수 별 독스트링을 작성하는 것이 유용합니다. 그러나 매개 변수 별 독스트링은 선택 사항입니다; 원한다면 이 단계를 건너뛸 수 있습니다.</p>
<p>매개 변수 별 독스트링을 추가하는 방법은 다음과 같습니다. 매개 변수 별 독스트링의 첫 번째 줄은 매개 변수 정의보다 더 들여 써야합니다. 이 첫 번째 줄의 왼쪽 여백은 전체 매개 변수 별 독스트링에 대한 왼쪽 여백을 설정합니다; 작성하는 모든 텍스트는 이 양만큼 내어 쓰기됩니다. 원한다면 여러 줄에 걸쳐, 원하는만큼 텍스트를 작성할 수 있습니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>파일을 저장하고 닫은 다음, 그것에 대해 <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>를 실행합니다. 운 좋게도 모든 것이 작동했습니다---이제 블록에 출력이 있고 <code class="docutils literal notranslate"><span class="pre">.c.h</span></code> 파일이 생성되었습니다! 텍스트 편집기에서 파일을 다시 열어 다음을 확인하십시오:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="n">_pickle_Pickler_dump</span><span class="p">(</span><span class="n">PicklerObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/</span>
</pre></div>
</div>
<p>명백히, 인자 클리닉이 출력을 생성하지 않았다면, 입력에서 에러를 발견했기 때문입니다. 인자 클리닉이 불평 없이 파일을 처리할 때까지 에러를 수정하고 재시도하십시오.</p>
<p>가독성을 위해, 대부분의 글루 코드는 <code class="docutils literal notranslate"><span class="pre">.c.h</span></code> 파일에 생성되었습니다. 일반적으로 클리닉 모듈 블록 바로 뒤에서, 원본 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 파일에 포함해야할 필요가 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;clinic/_pickle.c.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</li>
<li><p>인자 클리닉에서 생성한 인자 구문 분석 코드가 기본적으로 기존 코드와 같은 지 다시 확인합니다.</p>
<p>먼저, 두 곳에서 같은 인자 구문 분석 함수를 사용하는지 확인하십시오. 기존 코드는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>를 호출해야합니다; 인자 클리닉에서 생성 한 코드가 <em>정확히</em> 같은 함수를 호출하는지 확인합니다.</p>
<p>둘째, <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>에 전달된 포맷 문자열은 콜론이나 세미콜론까지 기존 함수에서 손으로 쓴 것과 <em>정확히</em> 같아야 합니다.</p>
<p>(인자 클리닉은 항상 <code class="docutils literal notranslate"><span class="pre">:</span></code> 뒤에 함수 이름이 있는 포맷 문자열을 생성합니다. 기존 코드의 포맷 문자열이 <code class="docutils literal notranslate"><span class="pre">;</span></code>로 끝나면 (사용법 도움말을 제공하기 위해), 이 변경 사항은 무해합니다 - 걱정하지 마십시오.)</p>
<p>셋째, 포맷 단위가 두 개의 인자(가령 길이 변수, 인코딩 문자열 또는 변환 함수에 대한 포인터)를 요구하는 매개 변수의 경우, 두 번째 인자가 두 호출 간에 <em>정확히</em> 같은지 확인하십시오.</p>
<p>넷째, 블록의 출력 부분 내부에 이 내장에 적합한 정적 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체를 정의하는 전 처리기 매크로가 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __PICKLE_PICKLER_DUMP_METHODDEF    \</span>
<span class="cp">{&quot;dump&quot;, (PyCFunction)__pickle_Pickler_dump, METH_O, __pickle_Pickler_dump__doc__},</span>
</pre></div>
</div>
<p>이 정적 구조체는 이 내장의 기존 정적 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체와 <em>정확히</em> 같아야 합니다.</p>
<p>이러한 항목 중 <em>어떤 식으로</em>건 다른 항목이 있으면, 인자 클리닉 함수 명세를 조정하고 같아질 때 까지 <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>를 다시 실행합니다.</p>
</li>
<li><p>출력의 마지막 줄은 &quot;impl&quot; 함수의 선언임에 유의하십시오. 여기가 내장 구현이 들어가는 곳입니다. 수정중인 함수의 기존 프로토타입을 삭제하십시오, 하지만 여는 중괄호는 그대로 둡니다. 이제 인자 구문 분석 코드와 인자를 덤프하는 모든 변수의 선언을 삭제합니다. 이제 어떤 식으로 파이썬 인자가 이 impl 함수에 대한 인자가 되는지 주목하십시오; 구현에서 이러한 변수에 다른 이름을 사용했다면, 수정하십시오.</p>
<p>좀 괴상하니, 반복합시다. 이제 코드는 다음과 같아야합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">return_type</span>
<span class="nf">your_function_impl</span><span class="p">(...)</span>
<span class="cm">/*[clinic end generated code: checksum=...]*/</span>
<span class="p">{</span>
<span class="p">...</span>
</pre></div>
</div>
<p>인자 클리닉은 체크섬 줄과 그 바로 위에 함수 프로토타입을 생성했습니다. 함수와 내부 구현에 대한 여는 (그리고 닫는) 중괄호를 작성해야합니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>
<span class="cm">/*[clinic end generated code: checksum=da39a3ee5e6b4b0d3255bfef95601890afd80709]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="n">PyDoc_STRVAR</span><span class="p">(</span><span class="n">__pickle_Pickler_dump__doc__</span><span class="p">,</span>
<span class="s">&quot;Write a pickled representation of obj to the open file.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="p">...</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="n">_pickle_Pickler_dump_impl</span><span class="p">(</span><span class="n">PicklerObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: checksum=3bd30745bf206a48f8b576a1da3d90f55a0a4187]*/</span>
<span class="p">{</span>
    <span class="cm">/* Check whether the Pickler was initialized correctly (issue3664).</span>
<span class="cm">       Developers often forget to call __init__() in their subclasses, which</span>
<span class="cm">       would trigger a segfault without this check. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PicklingError</span><span class="p">,</span>
                     <span class="s">&quot;Pickler.__init__() was not called by %s.__init__()&quot;</span><span class="p">,</span>
                     <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_Pickler_ClearBuffer</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="p">...</span>
</pre></div>
</div>
</li>
<li><p>이 함수에 대한 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체의 매크로를 기억하십니까? 이 함수에 대한 기존 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체를 찾아 매크로에 대한 참조로 바꿉니다. (내장이 모듈 스코프에 있으면, 아마도 파일의 끝 부분에 가까울 것입니다; 내장이 클래스 메서드이면, 아마도 아래에 있지만 상대적으로 구현에 가까울 것입니다.)</p>
<p>매크로 본문에는 후행 쉼표가 포함되어 있음에 유의하십시오. 따라서 기존의 정적 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체를 매크로로 바꿀 때, 끝에 쉼표를 추가하지 <em>마십시오</em>.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="n">Pickler_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">__PICKLE_PICKLER_DUMP_METHODDEF</span>
    <span class="n">__PICKLE_PICKLER_CLEAR_MEMO_METHODDEF</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>                <span class="cm">/* sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p>컴파일 한 다음, 회귀 테스트 스위트의 관련 부분을 실행합니다. 이 변경으로 인해 새로운 컴파일 시간 경고나 에러가 발생해서는 안되며, 파이썬의 동작에 대해 외부에서 볼 수있는 변경 사항이 없어야합니다.</p>
<p>한 가지 차이점이 있습니다: 함수에대해 실행되는 <code class="docutils literal notranslate"><span class="pre">inspect.signature()</span></code>는 이제 유효한 서명을 제공해야합니다!</p>
<p>축하합니다, 인자 클리닉과 함께 작동하는 첫 번째 함수를 이식했습니다!</p>
</li>
</ol>
</div>
<div class="section" id="advanced-topics">
<h2>고급 주제<a class="headerlink" href="#advanced-topics" title="제목 주소">¶</a></h2>
<p>이제 인자 클리닉으로 작업한 경험이 있고, 몇 가지 고급 주제를 살펴볼 시간입니다.</p>
<div class="section" id="symbolic-default-values">
<h3>기호 기본값<a class="headerlink" href="#symbolic-default-values" title="제목 주소">¶</a></h3>
<p>매개 변수에 제공하는 기본값은 임의의 표현식이 될 수 없습니다. 현재 다음이 명시 적으로 지원됩니다:</p>
<ul class="simple">
<li><p>숫자 상수 (정수와 부동 소수점)</p></li>
<li><p>문자열 상수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> 및 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code>와 같은 간단한 기호 상수, 모듈 이름으로 시작해야합니다</p></li>
</ul>
<p>궁금한 점이 있을 때를 위해, 이것은 <code class="docutils literal notranslate"><span class="pre">Lib/inspect.py</span></code>의 <code class="docutils literal notranslate"><span class="pre">from_builtin()</span></code>에서 구현됩니다.</p>
<p>(미래에는, <code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">-</span> <span class="pre">1</span></code>와 같은 완전한 표현식을 허용하기 위해, 더 정교해질 필요가 있습니다.)</p>
</div>
<div class="section" id="renaming-the-c-functions-and-variables-generated-by-argument-clinic">
<h3>인자 클리닉에서 생성한 C 함수와 변수 이름 변경하기<a class="headerlink" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic" title="제목 주소">¶</a></h3>
<p>인자 클리닉은 자동으로 생성되는 함수의 이름을 지정합니다. 생성된 이름이 기존 C 함수의 이름과 충돌하면, 때때로 이로 인해 문제가 발생할 수 있습니다. 쉬운 해결책이 있습니다: C 함수에 사용되는 이름을 재정의하는 것입니다. 함수 선언 줄에 키워드 <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code>를 추가 한 다음 사용하려는 함수 이름을 추가하면됩니다. 인자 클리닉은 기본 (생성된) 함수에 해당 함수 이름을 사용한 다음, 끝에 <code class="docutils literal notranslate"><span class="pre">&quot;_impl&quot;</span></code>를 추가하고 이를 impl 함수의 이름에 사용합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">pickle.Pickler.dump</span></code>에 대해 생성된 C 함수 이름을 바꾸려면, 다음과 같이됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump as pickler_dumper</span>

<span class="cm">...</span>
</pre></div>
</div>
<p>이제 기본 함수의 이름은 <code class="docutils literal notranslate"><span class="pre">pickler_dumper()</span></code>이고 impl 함수의 이름은 <code class="docutils literal notranslate"><span class="pre">pickler_dumper_impl()</span></code>이 됩니다.</p>
<p>마찬가지로, 매개 변수에 특정 파이썬 이름을 지정하려고 하지만, 해당 이름이 C에서 불편할 수 있는 경우 문제가 있을 수 있습니다. 인자 클리닉에서는 같은 <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> 문법을 사용하여, 파이썬과 C에서 매개 변수에 다른 이름을 지정할 수 있도록 합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump</span>

<span class="cm">    obj: object</span>
<span class="cm">    file as file_obj: object</span>
<span class="cm">    protocol: object = NULL</span>
<span class="cm">    *</span>
<span class="cm">    fix_imports: bool = True</span>
</pre></div>
</div>
<p>여기서, 파이썬에서 사용되는 이름(서명과 <code class="docutils literal notranslate"><span class="pre">keywords</span></code> 배열에서)은 <code class="docutils literal notranslate"><span class="pre">file</span></code>이지만, C 변수의 이름은 <code class="docutils literal notranslate"><span class="pre">file_obj</span></code>입니다.</p>
<p>이것을 사용하여 <code class="docutils literal notranslate"><span class="pre">self</span></code> 매개 변수의 이름도 바꿀 수 있습니다!</p>
</div>
<div class="section" id="converting-functions-using-pyarg-unpacktuple">
<h3>PyArg_UnpackTuple을 사용하여 함수 변환하기<a class="headerlink" href="#converting-functions-using-pyarg-unpacktuple" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>로 인자를 구문 분석하는 함수를 변환하려면, 각 인자를 <code class="docutils literal notranslate"><span class="pre">object</span></code>로 지정하여 모든 인자를 작성하면됩니다. <code class="docutils literal notranslate"><span class="pre">type</span></code> 인자를 지정하여 형을 적절하게 캐스트 할 수 있습니다. 모든 인자는 위치 전용으로 표시되어야합니다 (마지막 인자 뒤에 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 자체 줄로 추가하십시오).</p>
<p>현재 생성된 코드는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>를 사용하지만, 곧 변경됩니다.</p>
</div>
<div class="section" id="optional-groups">
<h3>선택적 그룹<a class="headerlink" href="#optional-groups" title="제목 주소">¶</a></h3>
<p>일부 레거시 함수는 인자를 구문 분석하는 데 까다로운 접근 방식을 사용합니다: 위치 인자의 수를 계산한 다음 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 문을 사용하여 위치 인자의 수에 따라 여러 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 호출 중 하나를 호출합니다. (이러한 함수는 키워드 전용 인자를 받아들일 수 없습니다.) 이 접근 방식은 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>가 만들어지기 전에 선택적 인자를 시뮬레이션하는 데 사용되었습니다.</p>
<p>이 접근 방식을 사용하는 함수는 종종 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, 선택적 인자 및 기본값을 사용하도록 변환될 수 있지만, 항상 가능한 것은 아닙니다. 이러한 레거시 함수 중 일부에는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>가 직접 지원하지 않는 동작이 있습니다. 가장 명백한 예는 필수 인자의 <em>좌</em> 측에 선택적 인자가 있는 내장 함수 <code class="docutils literal notranslate"><span class="pre">range()</span></code>입니다! 또 다른 예는 항상 함께 지정되어야 하는 두 개의 인자 그룹이있는 <code class="docutils literal notranslate"><span class="pre">curses.window.addch()</span></code>입니다. (인자는 <code class="docutils literal notranslate"><span class="pre">x</span></code>와 <code class="docutils literal notranslate"><span class="pre">y</span></code>라고 합니다; 함수를 호출할 때 <code class="docutils literal notranslate"><span class="pre">x</span></code>를 전달하면 <code class="docutils literal notranslate"><span class="pre">y</span></code>도 전달해야 합니다 - 그리고 <code class="docutils literal notranslate"><span class="pre">x</span></code>를 전달하지 않으면 <code class="docutils literal notranslate"><span class="pre">y</span></code>도 전달할 수 없습니다.)</p>
<p>어쨌든, 인자 클리닉의 목표는 의미를 변경하지 않고 기존의 모든 CPython 내장에 대한 인자 구문 분석을 지원하는 것입니다. 따라서 인자 클리닉은 <em>선택적 그룹(optional groups)</em>이라는 것을 사용하여, 구문 분석에 대한 이러한 대체 접근 방식을 지원합니다. 선택적 그룹은 모두 함께 전달되어야 하는 인자 그룹입니다. 필수 인자의 왼쪽 또는 오른쪽에 있을 수 있습니다. 위치 전용 매개 변수에만 사용할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>선택적 그룹은 <em>오직</em> <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>를 여러 번 호출하는 함수를 변환 할 때 사용하려는 것입니다! 인자를 구문 분석하기 위해 <em>다른</em> 접근 방식을 사용하는 함수는 <em>거의 절대</em> 선택적 그룹을 사용하여 인자 클리닉으로 변환되지 않습니다. 선택적 그룹을 사용하는 함수는 현재 파이썬에서 정확한 서명을 가질 수 없습니다, 파이썬이 개념을 이해하지 못하기 때문입니다. 가능한 한 선택적 그룹을 사용하지 마십시오.</p>
</div>
<p>선택적 그룹을 지정하려면, 함께 그룹화하려는 매개 변수 앞에 <code class="docutils literal notranslate"><span class="pre">[</span></code>를 단독 줄로 추가하고, 이러한 매개 변수 뒤에 단독 줄로 <code class="docutils literal notranslate"><span class="pre">]</span></code>를 추가합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">curses.window.addch</span></code>가 선택적 그룹을 사용하여 처음 두 매개 변수와 마지막 매개 변수를 선택적으로 만드는 방법은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>

<span class="cm">curses.window.addch</span>

<span class="cm">    [</span>
<span class="cm">    x: int</span>
<span class="cm">      X-coordinate.</span>
<span class="cm">    y: int</span>
<span class="cm">      Y-coordinate.</span>
<span class="cm">    ]</span>

<span class="cm">    ch: object</span>
<span class="cm">      Character to add.</span>

<span class="cm">    [</span>
<span class="cm">    attr: long</span>
<span class="cm">      Attributes for the character.</span>
<span class="cm">    ]</span>
<span class="cm">    /</span>

<span class="cm">...</span>
</pre></div>
</div>
<p>노트:</p>
<ul class="simple">
<li><p>모든 선택적 그룹에 대해, 하나의 추가 매개 변수가 impl 함수로 전달되어 그룹을 나타냅니다. 매개 변수는 <code class="docutils literal notranslate"><span class="pre">group_{direction}_{number}</span></code>라는 이름의 정수입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">{direction}</span></code>은 그룹이 필수 매개 변수 앞인지 뒤인지에 따라 <code class="docutils literal notranslate"><span class="pre">right</span></code>나 <code class="docutils literal notranslate"><span class="pre">left</span></code>이고, <code class="docutils literal notranslate"><span class="pre">{number}</span></code>는 그룹이 필수 매개 변수에서 얼마나 멀리 떨어져 있는지를 나타내는 단조 증가하는 숫자(1에서 시작)입니다. impl이 호출 될 때, 이 그룹이 사용되지 않았으면 이 매개 변수는 0으로 설정되고, 이 그룹이 사용 되면 0이 아닌 값으로 설정됩니다. (사용했다는 표현은, 매개 변수가 이 호출에서 인자를 받았는지를 의미합니다.)</p></li>
<li><p>필수 인자가 없으면, 선택적 그룹은 필수 인자의 오른쪽에 있는 것처럼 작동합니다.</p></li>
<li><p>모호한 경우, 인자 구문 분석 코드는 왼쪽(필수 매개 변수 앞)의 매개 변수를 선호합니다.</p></li>
<li><p>선택적 그룹은 위치 전용 매개 변수 만 포함할 수 있습니다.</p></li>
<li><p>선택적 그룹은 <em>오직</em> 레거시 코드를 위한 것입니다. 새 코드에 선택적 그룹을 사용하지 마십시오.</p></li>
</ul>
</div>
<div class="section" id="using-real-argument-clinic-converters-instead-of-legacy-converters">
<h3>&quot;레거시 변환기&quot; 대신 실제 인자 클리닉 변환기 사용하기<a class="headerlink" href="#using-real-argument-clinic-converters-instead-of-legacy-converters" title="제목 주소">¶</a></h3>
<p>To save time, and to minimize how much you need to learn
to achieve your first port to Argument Clinic, the walkthrough above tells
you to use &quot;legacy converters&quot;.  &quot;Legacy converters&quot; are a convenience,
designed explicitly to make porting existing code to Argument Clinic
easier.  And to be clear, their use is acceptable when porting code for
Python 3.4.</p>
<p>그러나, 장기적으로 우리는 모든 블록이 변환기를 위한 인자 클리닉의 실제 문법을 사용하기를 원할 것입니다. 왜일까요? 몇 가지 이유가 있습니다:</p>
<ul class="simple">
<li><p>적절한 변환기는 읽기가 훨씬 쉽고 의도가 명확합니다.</p></li>
<li><p>인자가 필요한데, 레거시 변환기 문법이 인자 지정을 지원하지 않아서, &quot;레거시 변환기&quot;로 지원되지 않는 일부 포맷 단위가 있습니다.</p></li>
<li><p>미래에 우리는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>가 지원하는 것에 제한되지 않는 새로운 인자 구문 분석 라이브러리를 가질 수 있습니다; 이러한 유연성은 레거시 변환기를 사용하는 매개 변수에는 제공되지 않을 것입니다.</p></li>
</ul>
<p>따라서, 약간의 추가 노력을 꺼리지 않는다면, 레거시 변환기 대신 일반 변환기를 사용하십시오.</p>
<p>간단히 말해서, 인자 클리닉 (비 레거시) 변환기의 문법은 파이썬 함수 호출처럼 보입니다; 그러나, 함수에 대한 명시적 인자가 없으면 (모든 함수가 기본값을 취함), 괄호를 생략할 수 있습니다. 따라서 <code class="docutils literal notranslate"><span class="pre">bool</span></code>과 <code class="docutils literal notranslate"><span class="pre">bool()</span></code>은 정확히 같은 변환기입니다.</p>
<p>인자 클리닉 변환기에 대한 모든 인자는 키워드 전용입니다. 모든 인자 클리닉 변환기는 다음 인자를 받아들입니다:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">c_default</span></code></dt><dd><p>C에서 정의될 때 이 매개 변수의 기본값. 특히, 이것은 &quot;구문 분석 함수&quot;에서 선언된 변수의 초기화자가 됩니다. 이것을 사용하는 방법은 <a class="reference internal" href="#default-values"><span class="std std-ref">기본값에 관한 섹션</span></a>을 참조하십시오. 문자열로 지정됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">annotation</span></code></dt><dd><p>이 매개 변수의 어노테이션 값. <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a>은 파이썬 라이브러리가 어노테이션을 사용하지 않도록 요구하므로, 현재 지원되지 않습니다.</p>
</dd>
</dl>
</div></blockquote>
<p>또한, 일부 변환기는 추가 인자를 받아들입니다. 다음은 의미와 함께, 이러한 인자들의 목록입니다:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">accept</span></code></dt><dd><p>파이썬 형(그리고 의사 형도 가능)의 집합; 이는 허용 가능한 파이썬 인자를 이러한 형의 값으로 제한합니다. (이것은 범용 기능이 아닙니다; 일반적으로 레거시 변환기 표에 표시된 특정 형 리스트만 지원합니다.)</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code>을 받아들이려면, 이 집합에 <code class="docutils literal notranslate"><span class="pre">NoneType</span></code>을 추가하십시오.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitwise</span></code></dt><dd><p>부호 없는 정수에 대해서만 지원됩니다. 이 파이썬 인자의 네이티브 정수 값은 음수 값에 대해서조차 범위 검사없이 매개 변수에 기록됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">converter</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">object</span></code> 변환기에서만 지원됩니다. 이 객체를 네이티브 형으로 변환하는 데 사용할 <a class="reference internal" href="../c-api/arg.html#o-ampersand"><span class="std std-ref">C &quot;변환기 함수&quot;</span></a>의 이름을 지정합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoding</span></code></dt><dd><p>문자열에 대해서만 지원됩니다. 이 문자열을 파이썬 str (유니코드) 값에서 C <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> 값으로 변환할 때 사용할 인코딩을 지정합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subclass_of</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">object</span></code> 변환기에 대해서만 지원됩니다. 파이썬 값은 C로 표현 된 파이썬 형의 서브 클래스여야 합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">object</span></code>와 <code class="docutils literal notranslate"><span class="pre">self</span></code> 변환기에 대해서만 지원됩니다. 변수를 선언하는 데 사용할 C 형을 지정합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">&quot;PyObject</span> <span class="pre">*&quot;</span></code>입니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zeroes</span></code></dt><dd><p>문자열에 대해서만 지원됩니다. 참이면, 값 내에 내장된 NUL 바이트(<code class="docutils literal notranslate"><span class="pre">'\\0'</span></code>)가 허용됩니다. 문자열의 길이는 문자열 매개 변수 바로 뒤에 <code class="docutils literal notranslate"><span class="pre">&lt;parameter_name&gt;_length</span></code>라는 이름의 매개 변수로 impl 함수에 전달됩니다.</p>
</dd>
</dl>
</div></blockquote>
<p>가능한 모든 인자 조합이 작동하는 것은 아님에 유의하십시오. 일반적으로 이러한 인자는 특정 동작을 갖는 특정 <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple</span></code> <em>포맷 단위</em>에 의해 구현됩니다. 예를 들어, 현재 <code class="docutils literal notranslate"><span class="pre">bitwise=True</span></code>를 지정하지 않고 <code class="docutils literal notranslate"><span class="pre">unsigned_short</span></code>를 호출할 수 없습니다. 이것이 작동할 것이라고 생각하는 것이 합리적이지만, 이러한 의미는 기존 포맷 단위에 매핑되지 않습니다. 그래서 인자 클리닉은 이것을 지원하지 않습니다. (또는, 적어도 아직은 아닙니다.)</p>
<p>다음은 레거시 변환기를 실제 인자 클리닉 변환기에 매핑하는 표입니다. 왼쪽에는 레거시 변환기가 있고, 오른쪽에는 교체 할 텍스트가 있습니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'B'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_char(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_char</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'c'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'C'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int(accept={str})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'d'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'D'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_complex</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'es'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding')</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'es#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'et'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">accept={bytes,</span> <span class="pre">bytearray,</span> <span class="pre">str})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'et#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">accept={bytes,</span> <span class="pre">bytearray,</span> <span class="pre">str},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'h'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">short</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'H'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_short(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'i'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'I'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_int(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'k'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_long(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'K'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_long_long(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'l'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'L'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'n'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'O'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'O!'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object(subclass_of='&amp;PySomething_Type')</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'O&amp;'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object(converter='name_of_c_function')</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'p'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'S'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyBytesObject</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'s#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={buffer,</span> <span class="pre">str})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'U'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unicode</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'u'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'u#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={rwbuffer})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'Y'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyByteArrayObject</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'y'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={bytes})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'y#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={robuffer},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'y*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'Z'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(accept={str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'Z#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(accept={str,</span> <span class="pre">NoneType},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'z'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'z#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={str,</span> <span class="pre">NoneType},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'z*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={buffer,</span> <span class="pre">str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
</tbody>
</table>
<p>예를 들어, 적절한 변환기를 사용하는 샘플 <code class="docutils literal notranslate"><span class="pre">pickle.Pickler.dump</span></code>는 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump</span>

<span class="cm">    obj: object</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>실제 변환기의 한 가지 장점은 레거시 변환기보다 유연하다는 것입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">unsigned_int</span></code> 변환기(그리고 모든 <code class="docutils literal notranslate"><span class="pre">unsigned_</span></code> 변환기)는 <code class="docutils literal notranslate"><span class="pre">bitwise=True</span></code>없이 지정될 수 있습니다. 기본 동작은 값에 대해 범위 검사를 수행하며, 음수를 허용하지 않습니다. 레거시 변환기로는 그렇게 할 수 없습니다!</p>
<p>인자 클리닉은 사용 가능한 모든 변환기를 보여줍니다. 각 변환기에 대해 허용되는 모든 매개 변수와 각 매개 변수의 기본값이 표시됩니다. 전체 목록을 보려면 <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span> <span class="pre">--converters</span></code>를 실행하십시오.</p>
</div>
<div class="section" id="py-buffer">
<h3>Py_buffer<a class="headerlink" href="#py-buffer" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code> 변환기(또는 <code class="docutils literal notranslate"><span class="pre">'s*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'w*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*y'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'z*'</span></code> 레거시 변환기)를 사용할 때, 제공된 버퍼에서 <a class="reference internal" href="../c-api/buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>를 호출하지 <em>않아야</em> 합니다. 인자 클리닉은 (구문 분석 함수에서) 이를 수행하는 코드를 생성합니다.</p>
</div>
<div class="section" id="advanced-converters">
<h3>고급 변환기<a class="headerlink" href="#advanced-converters" title="제목 주소">¶</a></h3>
<p>고급이기 때문에 처음에는 건너 뛴 포맷 단위를 기억하십니까? 다음은 이것도 처리하는 방법입니다.</p>
<p>트릭은, 모든 포맷 단위가 인자를 취한다는 것입니다 - 변환 함수, 형 또는 인코딩을 지정하는 문자열. (그러나 &quot;레거시 변환기&quot;는 인자를 지원하지 않습니다. 이것이 바로 첫 번째 함수에서 건너 뛴 이유입니다.) 포맷 단위에 지정한 인자는 이제 변환기에 대한 인자입니다; 이 인자는 <code class="docutils literal notranslate"><span class="pre">converter</span></code> (<code class="docutils literal notranslate"><span class="pre">O&amp;</span></code>의 경우), <code class="docutils literal notranslate"><span class="pre">subclass_of</span></code> (<code class="docutils literal notranslate"><span class="pre">O!</span></code>의 경우) 또는 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> (<code class="docutils literal notranslate"><span class="pre">e</span></code>로 시작하는 모든 포맷 단위의 경우)입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">subclass_of</span></code>를 사용할 때, <code class="docutils literal notranslate"><span class="pre">object()</span></code>에 대한 다른 사용자 정의 인자를 사용고 싶을 수도 있습니다: 매개 변수에 실제로 사용되는 형을 설정할 수 있는 <code class="docutils literal notranslate"><span class="pre">type</span></code>. 예를 들어, 객체가 <code class="docutils literal notranslate"><span class="pre">PyUnicode_Type</span></code>의 서브 클래스인지 확인하려면, <code class="docutils literal notranslate"><span class="pre">object(type='PyUnicodeObject</span> <span class="pre">*',</span> <span class="pre">subclass_of='&amp;PyUnicode_Type')</span></code> 변환기를 사용할 수 있습니다.</p>
<p>인자 클리닉을 사용할 때 발생할 수 있는 한 가지 문제: <code class="docutils literal notranslate"><span class="pre">e</span></code>로 시작하는 포맷 단위에 대해 일부 가능한 유연성을 제거합니다. <code class="docutils literal notranslate"><span class="pre">PyArg_Parse</span></code> 호출을 직접 작성할 때, 이론적으로 실행 시간에 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>에 전달할 인코딩 문자열을 결정할 수 있습니다. 그러나 이제 이 문자열은 인자 클리닉 처리 시점에 하드 코딩되어야 합니다. 이 제한은 의도적인 것입니다; 이 포맷 단위를 지원하는 것을 훨씬 쉽게만들고, 향후 최적화를 허용할 수 있습니다. 이 제한은 비합리적으로 보이지 않습니다; CPython 자체는 항상 포맷 단위가 <code class="docutils literal notranslate"><span class="pre">e</span></code>로 시작하는 매개 변수에 대해 정적 하드 코딩된 인코딩 문자열을 전달합니다.</p>
</div>
<div class="section" id="parameter-default-values">
<span id="default-values"></span><h3>매개 변수 기본값<a class="headerlink" href="#parameter-default-values" title="제목 주소">¶</a></h3>
<p>매개 변수의 기본값은 여러 값 중 하나일 수 있습니다. 가장 간단하게는, 문자열, 정수 또는 부동 소수점 리터럴일 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: str = &quot;abc&quot;
bar: int = 123
bat: float = 45.6
</pre></div>
</div>
<p>또한 파이썬의 내장 상수를 사용할 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>yep:  bool = True
nope: bool = False
nada: object = None
</pre></div>
</div>
<p>또한 다음 섹션에 설명 된 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>과 단순 표현식 기본값에 대한 특별 지원도 있습니다.</p>
</div>
<div class="section" id="the-null-default-value">
<h3><code class="docutils literal notranslate"><span class="pre">NULL</span></code> 기본값<a class="headerlink" href="#the-null-default-value" title="제목 주소">¶</a></h3>
<p>문자열과 객체 매개 변수의 경우, <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하여 기본값이 없음을 나타낼 수 있습니다. 그러나, 이는 C 변수가 <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>으로 초기화됨을 의미합니다. 편의상, 이 이유로 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이라는 특수 값이 있습니다: 파이썬의 관점에서 보면 <code class="docutils literal notranslate"><span class="pre">None</span></code>의 기본값처럼 동작하지만, C 변수는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 초기화됩니다.</p>
</div>
<div class="section" id="expressions-specified-as-default-values">
<h3>기본값으로 지정된 표현식<a class="headerlink" href="#expressions-specified-as-default-values" title="제목 주소">¶</a></h3>
<p>매개 변수의 기본값은 단순한 리터럴 값 이상이 될 수 있습니다. 수학 연산자를 사용하고 객체의 어트리뷰트를 조회하는 전체 표현식이 될 수 있습니다. 그러나, 이 지원은 일부 명확하지 않은 의미로 인해 간단하지 않습니다.</p>
<p>다음 예를 고려하십시오:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t = sys.maxsize - 1
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code>는 플랫폼마다 다른 값을 가질 수 있습니다. 따라서 인자 클리닉은 단순히 해당 표현식을 로컬에서 평가하고 C로 하드 코딩할 수 없습니다. 따라서 사용자가 함수의 서명을 요청할 때, 실행 시간에 평가되는 방식으로 기본값을 저장합니다.</p>
<p>식을 평가할 때 사용할 수 있는 이름 공간은 무엇입니까? 내장이 온 모듈의 컨텍스트에서 평가됩니다. 따라서, 모듈에 &quot;<code class="docutils literal notranslate"><span class="pre">max_widgets</span></code>&quot;라는 어트리뷰트가 있으면, 간단히 사용할 수 있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t = max_widgets
</pre></div>
</div>
<p>심볼이 현재 모듈에서 발견되지 않으면, <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>를 찾는 것으로 폴백됩니다. 이것이 예를 들어 <code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code>를 찾는 방법입니다. (사용자가 인터프리터에 로드할 모듈을 미리 알지 못하므로, 파이썬 자체에 의해 미리로드된 모듈로 제한하는 것이 가장 좋습니다.)</p>
<p>실행 시간에만 기본값을 평가한다는 것은 인자 클리닉이 올바른 동등한 C 기본값을 계산할 수 없음을 의미합니다. 그래서 여러분은 그것을 명시적으로 말할 필요가 있습니다. 표현식을 사용할 때, 변환기에 대한 <code class="docutils literal notranslate"><span class="pre">c_default</span></code> 매개 변수를 사용하여 C에서 동등한 표현식도 지정해야합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t(c_default=&quot;PY_SSIZE_T_MAX - 1&quot;) = sys.maxsize - 1
</pre></div>
</div>
<p>또 다른 복잡함: 인자 클리닉은 여러분이 제공한 표현식이 유효한지를 미리 알 수 없습니다. 올바르게 보이는지 확인하기 위해 구문 분석하지만, <em>실제로</em> 올바른지 알 수는 없습니다. 실행 시간에 유효하다고 보장되는 값을 지정하기 위해 표현식을 사용할 때 매우 주의해야합니다!</p>
<p>마지막으로, 표현식은 정적 C 값으로 표현할 수 있어야하므로, 유효한 표현식에는 많은 제한이 있습니다. 다음은 사용이 허용되지 않는 파이썬 기능 목록입니다:</p>
<ul class="simple">
<li><p>함수 호출.</p></li>
<li><p>인라인 if 문 (<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">if</span> <span class="pre">foo</span> <span class="pre">else</span> <span class="pre">5</span></code>).</p></li>
<li><p>자동 시퀀스 언패킹 (<code class="docutils literal notranslate"><span class="pre">*[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>).</p></li>
<li><p>리스트/집합/딕셔너리 컴프리헨션과 제너레이터 표현식.</p></li>
<li><p>튜플/이스트/집합/딕셔너리 리터럴.</p></li>
</ul>
</div>
<div class="section" id="using-a-return-converter">
<h3>반환 변환기 사용하기<a class="headerlink" href="#using-a-return-converter" title="제목 주소">¶</a></h3>
<p>기본적으로 인자 클리닉이 생성하는 impl 함수는 <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>를 반환합니다. 그러나 여러분의 C 함수는 종종 어떤 C 형을 계산한 다음, 마지막 순간에 <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>로 변환합니다. 인자 클리닉은 파이썬 형의 입력을 네이티브 C 형으로 변환하는 작업을 처리합니다 - 반환 값을 네이티브 C 형에서 파이썬 형으로 변환하지 않을 이유가 무엇입니까?</p>
<p>이것이 &quot;반환 변환기(return converter)&quot;가 하는 일입니다. C 형을 반환하도록 impl 함수를 변경한 다음, 생성된 (impl이 아닌) 함수에 코드를 추가하여 해당 값을 적절한 <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>로 변환합니다.</p>
<p>반환 변환기의 문법은 매개 변수 변환기의 것과 유사합니다. 함수 자체에 대한 반환 어노테이션처럼 반환 변환기를 지정합니다. 반환 변환기는 매개 변수 변환기와 거의 같게 작동합니다; 인자를 취하고, 인자는 모두 키워드 전용이며, 기본 인자를 변경하지 않으면 괄호를 생략할 수 있습니다.</p>
<p>(함수에 대해 <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code>와 반환 변환기를 <em>모두</em> 사용하면, <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code>가 반환 변환기 앞에 와야합니다.)</p>
<p>반환 변환기를 사용할 때 한 가지 추가적인 문제가 있습니다: 에러가 발생했음을 어떻게 표시합니까? 일반적으로, 함수는 성공에 대해 유효한 (<code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닌) 포인터를 반환하고, 실패에 대해 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. 그러나 정수 반환 변환기를 사용하면, 모든 정수가 유효합니다. 인자 클리닉은 어떻게 에러를 감지할까요? 해결책: 각 반환 변환기는 에러를 나타내는 특수 값을 묵시적으로 찾습니다. 해당 값을 반환하고 에러가 설정되면 (<code class="docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code>는 참 값을 반환합니다), 생성된 코드가 에러를 전파합니다. 그렇지 않으면 정상일 때처럼 반환되는 값을 인코딩합니다.</p>
<p>현재 인자 클리닉은 단지 몇 가지 반환 변환기만 지원합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool
int
unsigned int
long
unsigned int
size_t
Py_ssize_t
float
double
DecodeFSDefault
</pre></div>
</div>
<p>이들 중 어느 것도 매개 변수를 취하지 않습니다. 처음 세 개의 경우, -1을 반환하여 에러를 나타냅니다. <code class="docutils literal notranslate"><span class="pre">DecodeFSDefault</span></code>의 경우, 반환 형은 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>입니다; 에러를 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터를 반환합니다.</p>
<p>(<code class="docutils literal notranslate"><span class="pre">Py_None</span></code>에 대한 참조 횟수를 늘리지 않고, 성공시 <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>을 반환하거나 실패시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환할 수 있는, 실험적인 <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> 변환기도 있습니다. 사용할 가치가 있을만큼 명확성을 추가할 수 있을지 모르겠습니다.)</p>
<p>인자 클리닉이 지원하는 모든 반환 변환기를 매개 변수 (있다면)와 함께 보려면, 전체 목록을 위해 <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span> <span class="pre">--converters</span></code>를 실행하십시오.</p>
</div>
<div class="section" id="cloning-existing-functions">
<h3>기존 함수 복제하기<a class="headerlink" href="#cloning-existing-functions" title="제목 주소">¶</a></h3>
<p>유사해 보이는 함수가 여러 개이면, 클리닉의 &quot;복제(clone)&quot; 기능을 사용할 수 있습니다. 기존 함수를 복제할 때, 다음을 재사용합니다:</p>
<ul class="simple">
<li><p>다음을 포함하는 매개 변수</p>
<ul>
<li><p>그들의 이름,</p></li>
<li><p>모든 매개 변수와 함께, 그들의 변환기,</p></li>
<li><p>그들의 기본값,</p></li>
<li><p>그들의 매개 변수 별 독스트링,</p></li>
<li><p>그들의 <em>종류(kind)</em> (위치 전용, 위치-키워드 또는 키워드 전용인지), 그리고</p></li>
</ul>
</li>
<li><p>반환 변환기.</p></li>
</ul>
<p>원래 함수에서 복사되지 않는 유일한 것은 독스트링입니다; 문법은 새 독스트링을 지정할 수 있도록 합니다.</p>
<p>다음은 함수 복제 문법입니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module.class.new_function [as c_basename] = module.class.existing_function</span>

<span class="cm">Docstring for new_function goes here.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>(함수는 다른 모듈이나 클래스에 있을 수 있습니다. <em>두</em> 함수에 전체 경로를 사용해야 함을 예시하기 위해 샘플에 <code class="docutils literal notranslate"><span class="pre">module.class</span></code>를 작성했습니다.)</p>
<p>죄송합니다, 함수를 부분적으로 복제하거나, 함수를 복제한 다음 수정하는 문법은 없습니다. 복제는 전부 아니면 전무입니다.</p>
<p>또한, 복제하려는 함수는 현재 파일에 이전에 정의되어 있어야합니다.</p>
</div>
<div class="section" id="calling-python-code">
<h3>파이썬 코드 호출하기<a class="headerlink" href="#calling-python-code" title="제목 주소">¶</a></h3>
<p>나머지 고급 주제에서는 C 파일에서 파이썬 코드를 작성하고 인자 클리닉의 실행 시간 상태를 수정해야합니다. 이것은 간단합니다: 파이썬 블록을 정의하기만 하면됩니다.</p>
<p>파이썬 블록은 인자 클리닉 함수 블록과 다른 구분자 줄을 사용합니다. 다음과 같이 보입니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm"># python code goes here</span>
<span class="cm">[python start generated code]*/</span>
</pre></div>
</div>
<p>파이썬 블록 내부의 모든 코드는 구문 분석될 때 실행됩니다. 블록 내부에서 stdout에 기록된 모든 텍스트는 블록 뒤의 &quot;출력&quot;으로 리디렉션됩니다.</p>
<p>예를 들어, 다음은 C 코드에 정적 정수 변수를 추가하는 파이썬 블록입니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm">print(&#39;static int __ignored_unused_variable__ = 0;&#39;)</span>
<span class="cm">[python start generated code]*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__ignored_unused_variable__</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/*[python checksum:...]*/</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-self-converter">
<h3>Using a &quot;self converter&quot;<a class="headerlink" href="#using-a-self-converter" title="제목 주소">¶</a></h3>
<p>Argument Clinic automatically adds a &quot;self&quot; parameter for you
using a default converter.  It automatically sets the <code class="docutils literal notranslate"><span class="pre">type</span></code>
of this parameter to the &quot;pointer to an instance&quot; you specified
when you declared the type.  However, you can override
Argument Clinic's converter and specify one yourself.
Just add your own <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter as the first parameter in a
block, and ensure that its converter is an instance of
<code class="docutils literal notranslate"><span class="pre">self_converter</span></code> or a subclass thereof.</p>
<p>What's the point?  This lets you override the type of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
or give it a different default name.</p>
<p>How do you specify the custom type you want to cast <code class="docutils literal notranslate"><span class="pre">self</span></code> to?
If you only have one or two functions with the same type for <code class="docutils literal notranslate"><span class="pre">self</span></code>,
you can directly use Argument Clinic's existing <code class="docutils literal notranslate"><span class="pre">self</span></code> converter,
passing in the type you want to use as the <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>

<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">  self: self(type=&quot;PicklerObject *&quot;)</span>
<span class="cm">  obj: object</span>
<span class="cm">  /</span>

<span class="cm">Write a pickled representation of the given object to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>On the other hand, if you have a lot of functions that will use the same
type for <code class="docutils literal notranslate"><span class="pre">self</span></code>, it's best to create your own converter, subclassing
<code class="docutils literal notranslate"><span class="pre">self_converter</span></code> but overwriting the <code class="docutils literal notranslate"><span class="pre">type</span></code> member:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm">class PicklerObject_converter(self_converter):</span>
<span class="cm">    type = &quot;PicklerObject *&quot;</span>
<span class="cm">[python start generated code]*/</span>

<span class="cm">/*[clinic input]</span>

<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">  self: PicklerObject</span>
<span class="cm">  obj: object</span>
<span class="cm">  /</span>

<span class="cm">Write a pickled representation of the given object to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-a-custom-converter">
<h3>Writing a custom converter<a class="headerlink" href="#writing-a-custom-converter" title="제목 주소">¶</a></h3>
<p>As we hinted at in the previous section... you can write your own converters!
A converter is simply a Python class that inherits from <code class="docutils literal notranslate"><span class="pre">CConverter</span></code>.
The main purpose of a custom converter is if you have a parameter using
the <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> format unit—parsing this parameter means calling
a <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> &quot;converter function&quot;.</p>
<p>Your converter class should be named <code class="docutils literal notranslate"><span class="pre">*something*_converter</span></code>.
If the name follows this convention, then your converter class
will be automatically registered with Argument Clinic; its name
will be the name of your class with the <code class="docutils literal notranslate"><span class="pre">_converter</span></code> suffix
stripped off.  (This is accomplished with a metaclass.)</p>
<p>You shouldn't subclass <code class="docutils literal notranslate"><span class="pre">CConverter.__init__</span></code>.  Instead, you should
write a <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code> function.  <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code>
always accepts a <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter; after that, all additional
parameters <em>must</em> be keyword-only.  Any arguments passed in to
the converter in Argument Clinic will be passed along to your
<code class="docutils literal notranslate"><span class="pre">converter_init()</span></code>.</p>
<p>There are some additional members of <code class="docutils literal notranslate"><span class="pre">CConverter</span></code> you may wish
to specify in your subclass.  Here's the current list:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>The C type to use for this variable.
<code class="docutils literal notranslate"><span class="pre">type</span></code> should be a Python string specifying the type, e.g. <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If this is a pointer type, the type string should end with <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">*'</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code></dt><dd><p>The Python default value for this parameter, as a Python value.
Or the magic value <code class="docutils literal notranslate"><span class="pre">unspecified</span></code> if there is no default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">py_default</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">default</span></code> as it should appear in Python code,
as a string.
Or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is no default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_default</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">default</span></code> as it should appear in C code,
as a string.
Or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is no default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_ignored_default</span></code></dt><dd><p>The default value used to initialize the C variable when
there is no default, but not specifying a default may
result in an &quot;uninitialized variable&quot; warning.  This can
easily happen when using option groups—although
properly-written code will never actually use this value,
the variable does get passed in to the impl, and the
C compiler will complain about the &quot;use&quot; of the
uninitialized value.  This value should always be a
non-empty string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">converter</span></code></dt><dd><p>The name of the C converter function, as a string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">impl_by_reference</span></code></dt><dd><p>A boolean value.  If true,
Argument Clinic will add a <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> in front of the name of
the variable when passing it into the impl function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parse_by_reference</span></code></dt><dd><p>A boolean value.  If true,
Argument Clinic will add a <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> in front of the name of
the variable when passing it into <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>.</p>
</dd>
</dl>
<p>Here's the simplest example of a custom converter, from <code class="docutils literal notranslate"><span class="pre">Modules/zlibmodule.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>

<span class="cm">class ssize_t_converter(CConverter):</span>
<span class="cm">    type = &#39;Py_ssize_t&#39;</span>
<span class="cm">    converter = &#39;ssize_t_converter&#39;</span>

<span class="cm">[python start generated code]*/</span>
<span class="cm">/*[python end generated code: output=da39a3ee5e6b4b0d input=35521e4e733823c7]*/</span>
</pre></div>
</div>
<p>This block adds a converter to Argument Clinic named <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code>.  Parameters
declared as <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> will be declared as type <code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>, and will
be parsed by the <code class="docutils literal notranslate"><span class="pre">'O&amp;'</span></code> format unit, which will call the
<code class="docutils literal notranslate"><span class="pre">ssize_t_converter</span></code> converter function.  <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> variables
automatically support default values.</p>
<p>More sophisticated custom converters can insert custom C code to
handle initialization and cleanup.
You can see more examples of custom converters in the CPython
source tree; grep the C files for the string <code class="docutils literal notranslate"><span class="pre">CConverter</span></code>.</p>
</div>
<div class="section" id="writing-a-custom-return-converter">
<h3>Writing a custom return converter<a class="headerlink" href="#writing-a-custom-return-converter" title="제목 주소">¶</a></h3>
<p>Writing a custom return converter is much like writing
a custom converter.  Except it's somewhat simpler, because return
converters are themselves much simpler.</p>
<p>Return converters must subclass <code class="docutils literal notranslate"><span class="pre">CReturnConverter</span></code>.
There are no examples yet of custom return converters,
because they are not widely used yet.  If you wish to
write your own return converter, please read <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>,
specifically the implementation of <code class="docutils literal notranslate"><span class="pre">CReturnConverter</span></code> and
all its subclasses.</p>
</div>
<div class="section" id="meth-o-and-meth-noargs">
<h3>METH_O and METH_NOARGS<a class="headerlink" href="#meth-o-and-meth-noargs" title="제목 주소">¶</a></h3>
<p>To convert a function using <code class="docutils literal notranslate"><span class="pre">METH_O</span></code>, make sure the function's
single argument is using the <code class="docutils literal notranslate"><span class="pre">object</span></code> converter, and mark the
arguments as positional-only:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">meth_o_sample</span>

<span class="cm">     argument: object</span>
<span class="cm">     /</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>To convert a function using <code class="docutils literal notranslate"><span class="pre">METH_NOARGS</span></code>, just don't specify
any arguments.</p>
<p>You can still use a self converter, a return converter, and specify
a <code class="docutils literal notranslate"><span class="pre">type</span></code> argument to the object converter for <code class="docutils literal notranslate"><span class="pre">METH_O</span></code>.</p>
</div>
<div class="section" id="tp-new-and-tp-init-functions">
<h3>tp_new and tp_init functions<a class="headerlink" href="#tp-new-and-tp-init-functions" title="제목 주소">¶</a></h3>
<p>You can convert <code class="docutils literal notranslate"><span class="pre">tp_new</span></code> and <code class="docutils literal notranslate"><span class="pre">tp_init</span></code> functions.  Just name
them <code class="docutils literal notranslate"><span class="pre">__new__</span></code> or <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as appropriate.  Notes:</p>
<ul class="simple">
<li><p>The function name generated for <code class="docutils literal notranslate"><span class="pre">__new__</span></code> doesn't end in <code class="docutils literal notranslate"><span class="pre">__new__</span></code>
like it would by default.  It's just the name of the class, converted
into a valid C identifier.</p></li>
<li><p>No <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> <code class="docutils literal notranslate"><span class="pre">#define</span></code> is generated for these functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> functions return <code class="docutils literal notranslate"><span class="pre">int</span></code>, not <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>.</p></li>
<li><p>Use the docstring as the class docstring.</p></li>
<li><p>Although <code class="docutils literal notranslate"><span class="pre">__new__</span></code> and <code class="docutils literal notranslate"><span class="pre">__init__</span></code> functions must always
accept both the <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> objects, when converting
you may specify any signature for these functions that you like.
(If your function doesn't support keywords, the parsing function
generated will throw an exception if it receives any.)</p></li>
</ul>
</div>
<div class="section" id="changing-and-redirecting-clinic-s-output">
<h3>Changing and redirecting Clinic's output<a class="headerlink" href="#changing-and-redirecting-clinic-s-output" title="제목 주소">¶</a></h3>
<p>It can be inconvenient to have Clinic's output interspersed with
your conventional hand-edited C code.  Luckily, Clinic is configurable:
you can buffer up its output for printing later (or earlier!), or write
its output to a separate file.  You can also add a prefix or suffix to
every line of Clinic's generated output.</p>
<p>While changing Clinic's output in this manner can be a boon to readability,
it may result in Clinic code using types before they are defined, or
your code attempting to use Clinic-generated code before it is defined.
These problems can be easily solved by rearranging the declarations in your file,
or moving where Clinic's generated code goes.  (This is why the default behavior
of Clinic is to output everything into the current block; while many people
consider this hampers readability, it will never require rearranging your
code to fix definition-before-use problems.)</p>
<p>Let's start with defining some terminology:</p>
<dl>
<dt><em>field</em></dt><dd><p>A field, in this context, is a subsection of Clinic's output.
For example, the <code class="docutils literal notranslate"><span class="pre">#define</span></code> for the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure
is a field, called <code class="docutils literal notranslate"><span class="pre">methoddef_define</span></code>.  Clinic has seven
different fields it can output per function definition:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docstring_prototype
docstring_definition
methoddef_define
impl_prototype
parser_prototype
parser_definition
impl_definition
</pre></div>
</div>
<p>All the names are of the form <code class="docutils literal notranslate"><span class="pre">&quot;&lt;a&gt;_&lt;b&gt;&quot;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">&quot;&lt;a&gt;&quot;</span></code> is the semantic object represented (the parsing function,
the impl function, the docstring, or the methoddef structure) and <code class="docutils literal notranslate"><span class="pre">&quot;&lt;b&gt;&quot;</span></code>
represents what kind of statement the field is.  Field names that end in
<code class="docutils literal notranslate"><span class="pre">&quot;_prototype&quot;</span></code>
represent forward declarations of that thing, without the actual body/data
of the thing; field names that end in <code class="docutils literal notranslate"><span class="pre">&quot;_definition&quot;</span></code> represent the actual
definition of the thing, with the body/data of the thing.  (<code class="docutils literal notranslate"><span class="pre">&quot;methoddef&quot;</span></code>
is special, it's the only one that ends with <code class="docutils literal notranslate"><span class="pre">&quot;_define&quot;</span></code>, representing that
it's a preprocessor #define.)</p>
</dd>
<dt><em>destination</em></dt><dd><p>A destination is a place Clinic can write output to.  There are
five built-in destinations:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">block</span></code></dt><dd><p>The default destination: printed in the output section of
the current Clinic block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>A text buffer where you can save text for later.  Text sent
here is appended to the end of any existing text.  It's an
error to have any text left in the buffer when Clinic finishes
processing a file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>A separate &quot;clinic file&quot; that will be created automatically by Clinic.
The filename chosen for the file is <code class="docutils literal notranslate"><span class="pre">{basename}.clinic{extension}</span></code>,
where <code class="docutils literal notranslate"><span class="pre">basename</span></code> and <code class="docutils literal notranslate"><span class="pre">extension</span></code> were assigned the output
from <code class="docutils literal notranslate"><span class="pre">os.path.splitext()</span></code> run on the current file.  (Example:
the <code class="docutils literal notranslate"><span class="pre">file</span></code> destination for <code class="docutils literal notranslate"><span class="pre">_pickle.c</span></code> would be written to
<code class="docutils literal notranslate"><span class="pre">_pickle.clinic.c</span></code>.)</p>
<p><strong>Important: When using a</strong> <code class="docutils literal notranslate"><span class="pre">file</span></code> <strong>destination, you</strong>
<em>must check in</em> <strong>the generated file!</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>A buffer like <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.  However, a two-pass buffer can only
be dumped once, and it prints out all text sent to it during
all processing, even from Clinic blocks <em>after</em> the dumping point.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suppress</span></code></dt><dd><p>The text is suppressed—thrown away.</p>
</dd>
</dl>
</dd>
</dl>
<p>Clinic defines five new directives that let you reconfigure its output.</p>
<p>The first new directive is <code class="docutils literal notranslate"><span class="pre">dump</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dump &lt;destination&gt;
</pre></div>
</div>
<p>This dumps the current contents of the named destination into the output of
the current block, and empties it.  This only works with <code class="docutils literal notranslate"><span class="pre">buffer</span></code> and
<code class="docutils literal notranslate"><span class="pre">two-pass</span></code> destinations.</p>
<p>The second new directive is <code class="docutils literal notranslate"><span class="pre">output</span></code>.  The most basic form of <code class="docutils literal notranslate"><span class="pre">output</span></code>
is like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output &lt;field&gt; &lt;destination&gt;
</pre></div>
</div>
<p>This tells Clinic to output <em>field</em> to <em>destination</em>.  <code class="docutils literal notranslate"><span class="pre">output</span></code> also
supports a special meta-destination, called <code class="docutils literal notranslate"><span class="pre">everything</span></code>, which tells
Clinic to output <em>all</em> fields to that <em>destination</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">output</span></code> has a number of other functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output push
output pop
output preset &lt;preset&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">push</span></code> and <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">pop</span></code> allow you to push and pop
configurations on an internal configuration stack, so that you
can temporarily modify the output configuration, then easily restore
the previous configuration.  Simply push before your change to save
the current configuration, then pop when you wish to restore the
previous configuration.</p>
<p><code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">preset</span></code> sets Clinic's output to one of several built-in
preset configurations, as follows:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">block</span></code></dt><dd><p>Clinic's original starting configuration.  Writes everything
immediately after the input block.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write everything else to <code class="docutils literal notranslate"><span class="pre">block</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>Designed to write everything to the &quot;clinic file&quot; that it can.
You then <code class="docutils literal notranslate"><span class="pre">#include</span></code> this file near the top of your file.
You may need to rearrange your file to make this work, though
usually this just means creating forward declarations for various
<code class="docutils literal notranslate"><span class="pre">typedef</span></code> and <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> definitions.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code> to
<code class="docutils literal notranslate"><span class="pre">block</span></code>, and write everything else to <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p>
<p>The default filename is <code class="docutils literal notranslate"><span class="pre">&quot;{dirname}/clinic/{basename}.h&quot;</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Save up most of the output from Clinic, to be written into
your file near the end.  For Python files implementing modules
or builtin types, it's recommended that you dump the buffer
just above the static structures for your module or
builtin type; these are normally very near the end.  Using
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> may require even more editing than <code class="docutils literal notranslate"><span class="pre">file</span></code>, if
your file has static <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> arrays defined in the
middle of the file.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>, <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>,
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code> to
<code class="docutils literal notranslate"><span class="pre">block</span></code>, and write everything else to <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>Similar to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset, but writes forward declarations to
the <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> buffer, and definitions to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.
This is similar to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset, but may require
less editing than <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.  Dump the <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> buffer
near the top of your file, and dump the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> near
the end just like you would when using the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset.</p>
<p>Suppresses the <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code>
to <code class="docutils literal notranslate"><span class="pre">block</span></code>, write <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, <code class="docutils literal notranslate"><span class="pre">methoddef_define</span></code>,
and <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code> to <code class="docutils literal notranslate"><span class="pre">two-pass</span></code>, write everything else
to <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">partial-buffer</span></code></dt><dd><p>Similar to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset, but writes more things to <code class="docutils literal notranslate"><span class="pre">block</span></code>,
only writing the really big chunks of generated code to <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.
This avoids the definition-before-use problem of <code class="docutils literal notranslate"><span class="pre">buffer</span></code> completely,
at the small cost of having slightly more stuff in the block's output.
Dump the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> near the end, just like you would when using
the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset.</p>
<p>Suppresses the <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">docstring_definition</span></code>
and <code class="docutils literal notranslate"><span class="pre">parser_definition</span></code> to <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, write everything else to <code class="docutils literal notranslate"><span class="pre">block</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>The third new directive is <code class="docutils literal notranslate"><span class="pre">destination</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; &lt;command&gt; [...]
</pre></div>
</div>
<p>This performs an operation on the destination named <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>There are two defined subcommands: <code class="docutils literal notranslate"><span class="pre">new</span></code> and <code class="docutils literal notranslate"><span class="pre">clear</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">new</span></code> subcommand works like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; new &lt;type&gt;
</pre></div>
</div>
<p>This creates a new destination with name <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> and type <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>.</p>
<p>There are five destination types:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">suppress</span></code></dt><dd><p>Throws the text away.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block</span></code></dt><dd><p>Writes the text to the current block.  This is what Clinic
originally did.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>A simple text buffer, like the &quot;buffer&quot; builtin destination above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>A text file.  The file destination takes an extra argument,
a template to use for building the filename, like so:</p>
<blockquote>
<div><p>destination &lt;name&gt; new &lt;type&gt; &lt;file_template&gt;</p>
</div></blockquote>
<p>The template can use three strings internally that will be replaced
by bits of the filename:</p>
<blockquote>
<div><dl class="simple">
<dt>{path}</dt><dd><p>The full path to the file, including directory and full filename.</p>
</dd>
<dt>{dirname}</dt><dd><p>The name of the directory the file is in.</p>
</dd>
<dt>{basename}</dt><dd><p>Just the name of the file, not including the directory.</p>
</dd>
<dt>{basename_root}</dt><dd><p>Basename with the extension clipped off
(everything up to but not including the last '.').</p>
</dd>
<dt>{basename_extension}</dt><dd><p>The last '.' and everything after it.  If the basename
does not contain a period, this will be the empty string.</p>
</dd>
</dl>
</div></blockquote>
<p>If there are no periods in the filename, {basename} and {filename}
are the same, and {extension} is empty.  &quot;{basename}{extension}&quot;
is always exactly the same as &quot;{filename}&quot;.&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>A two-pass buffer, like the &quot;two-pass&quot; builtin destination above.</p>
</dd>
</dl>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">clear</span></code> subcommand works like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; clear
</pre></div>
</div>
<p>It removes all the accumulated text up to this point in the destination.
(I don't know what you'd need this for, but I thought maybe it'd be
useful while someone's experimenting.)</p>
<p>The fourth new directive is <code class="docutils literal notranslate"><span class="pre">set</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set line_prefix &quot;string&quot;
set line_suffix &quot;string&quot;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">set</span></code> lets you set two internal variables in Clinic.
<code class="docutils literal notranslate"><span class="pre">line_prefix</span></code> is a string that will be prepended to every line of Clinic's output;
<code class="docutils literal notranslate"><span class="pre">line_suffix</span></code> is a string that will be appended to every line of Clinic's output.</p>
<p>Both of these support two format strings:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">comment</span> <span class="pre">start}</span></code></dt><dd><p>Turns into the string <code class="docutils literal notranslate"><span class="pre">/*</span></code>, the start-comment text sequence for C files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">comment</span> <span class="pre">end}</span></code></dt><dd><p>Turns into the string <code class="docutils literal notranslate"><span class="pre">*/</span></code>, the end-comment text sequence for C files.</p>
</dd>
</dl>
</div></blockquote>
<p>The final new directive is one you shouldn't need to use directly,
called <code class="docutils literal notranslate"><span class="pre">preserve</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>preserve
</pre></div>
</div>
<p>This tells Clinic that the current contents of the output should be kept, unmodified.
This is used internally by Clinic when dumping output into <code class="docutils literal notranslate"><span class="pre">file</span></code> files; wrapping
it in a Clinic block lets Clinic use its existing checksum functionality to ensure
the file was not modified by hand before it gets overwritten.</p>
</div>
<div class="section" id="the-ifdef-trick">
<h3>The #ifdef trick<a class="headerlink" href="#the-ifdef-trick" title="제목 주소">¶</a></h3>
<p>If you're converting a function that isn't available on all platforms,
there's a trick you can use to make life a little easier.  The existing
code probably looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAVE_FUNCTIONNAME</span>
<span class="k">static</span> <span class="nf">module_functionname</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_FUNCTIONNAME */</span><span class="cp"></span>
</pre></div>
</div>
<p>And then in the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure at the bottom the existing code
will have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ifdef HAVE_FUNCTIONNAME
{&#39;functionname&#39;, ... },
#endif /* HAVE_FUNCTIONNAME */
</pre></div>
</div>
<p>In this scenario, you should enclose the body of your impl function inside the <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>,
like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAVE_FUNCTIONNAME</span>
<span class="cm">/*[clinic input]</span>
<span class="cm">module.functionname</span>
<span class="cm">...</span>
<span class="cm">[clinic start generated code]*/</span>
<span class="k">static</span> <span class="nf">module_functionname</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_FUNCTIONNAME */</span><span class="cp"></span>
</pre></div>
</div>
<p>Then, remove those three lines from the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure,
replacing them with the macro Argument Clinic generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODULE_FUNCTIONNAME_METHODDEF
</pre></div>
</div>
<p>(You can find the real name for this macro inside the generated code.
Or you can calculate it yourself: it's the name of your function as defined
on the first line of your block, but with periods changed to underscores,
uppercased, and <code class="docutils literal notranslate"><span class="pre">&quot;_METHODDEF&quot;</span></code> added to the end.)</p>
<p>Perhaps you're wondering: what if <code class="docutils literal notranslate"><span class="pre">HAVE_FUNCTIONNAME</span></code> isn't defined?
The <code class="docutils literal notranslate"><span class="pre">MODULE_FUNCTIONNAME_METHODDEF</span></code> macro won't be defined either!</p>
<p>Here's where Argument Clinic gets very clever.  It actually detects that the
Argument Clinic block might be deactivated by the <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>.  When that
happens, it generates a little extra code that looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef MODULE_FUNCTIONNAME_METHODDEF</span>
    <span class="cp">#define MODULE_FUNCTIONNAME_METHODDEF</span>
<span class="cp">#endif </span><span class="cm">/* !defined(MODULE_FUNCTIONNAME_METHODDEF) */</span><span class="cp"></span>
</pre></div>
</div>
<p>That means the macro always works.  If the function is defined, this turns
into the correct structure, including the trailing comma.  If the function is
undefined, this turns into nothing.</p>
<p>However, this causes one ticklish problem: where should Argument Clinic put this
extra code when using the &quot;block&quot; output preset?  It can't go in the output block,
because that could be deactivated by the <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>.  (That's the whole point!)</p>
<p>In this situation, Argument Clinic writes the extra code to the &quot;buffer&quot; destination.
This may mean that you get a complaint from Argument Clinic:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Warning in file &quot;Modules/posixmodule.c&quot; on line 12357:
Destination buffer &#39;buffer&#39; not empty at end of file, emptying.
</pre></div>
</div>
<p>When this happens, just open your file, find the <code class="docutils literal notranslate"><span class="pre">dump</span> <span class="pre">buffer</span></code> block that
Argument Clinic added to your file (it'll be at the very bottom), then
move it above the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure where that macro is used.</p>
</div>
<div class="section" id="using-argument-clinic-in-python-files">
<h3>Using Argument Clinic in Python files<a class="headerlink" href="#using-argument-clinic-in-python-files" title="제목 주소">¶</a></h3>
<p>It's actually possible to use Argument Clinic to preprocess Python files.
There's no point to using Argument Clinic blocks, of course, as the output
wouldn't make any sense to the Python interpreter.  But using Argument Clinic
to run Python blocks lets you use Python as a Python preprocessor!</p>
<p>Since Python comments are different from C comments, Argument Clinic
blocks embedded in Python files look slightly different.  They look like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#/*[python input]</span>
<span class="c1">#print(&quot;def foo(): pass&quot;)</span>
<span class="c1">#[python start generated code]*/</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span> <span class="k">pass</span>
<span class="c1">#/*[python checksum:...]*/</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">인자 클리닉 How-To</a><ul>
<li><a class="reference internal" href="#the-goals-of-argument-clinic">인자 클리닉의 목표</a></li>
<li><a class="reference internal" href="#basic-concepts-and-usage">기본 개념과 사용법</a></li>
<li><a class="reference internal" href="#converting-your-first-function">첫 번째 함수 변환하기</a></li>
<li><a class="reference internal" href="#advanced-topics">고급 주제</a><ul>
<li><a class="reference internal" href="#symbolic-default-values">기호 기본값</a></li>
<li><a class="reference internal" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic">인자 클리닉에서 생성한 C 함수와 변수 이름 변경하기</a></li>
<li><a class="reference internal" href="#converting-functions-using-pyarg-unpacktuple">PyArg_UnpackTuple을 사용하여 함수 변환하기</a></li>
<li><a class="reference internal" href="#optional-groups">선택적 그룹</a></li>
<li><a class="reference internal" href="#using-real-argument-clinic-converters-instead-of-legacy-converters">&quot;레거시 변환기&quot; 대신 실제 인자 클리닉 변환기 사용하기</a></li>
<li><a class="reference internal" href="#py-buffer">Py_buffer</a></li>
<li><a class="reference internal" href="#advanced-converters">고급 변환기</a></li>
<li><a class="reference internal" href="#parameter-default-values">매개 변수 기본값</a></li>
<li><a class="reference internal" href="#the-null-default-value"><code class="docutils literal notranslate"><span class="pre">NULL</span></code> 기본값</a></li>
<li><a class="reference internal" href="#expressions-specified-as-default-values">기본값으로 지정된 표현식</a></li>
<li><a class="reference internal" href="#using-a-return-converter">반환 변환기 사용하기</a></li>
<li><a class="reference internal" href="#cloning-existing-functions">기존 함수 복제하기</a></li>
<li><a class="reference internal" href="#calling-python-code">파이썬 코드 호출하기</a></li>
<li><a class="reference internal" href="#using-a-self-converter">Using a &quot;self converter&quot;</a></li>
<li><a class="reference internal" href="#writing-a-custom-converter">Writing a custom converter</a></li>
<li><a class="reference internal" href="#writing-a-custom-return-converter">Writing a custom return converter</a></li>
<li><a class="reference internal" href="#meth-o-and-meth-noargs">METH_O and METH_NOARGS</a></li>
<li><a class="reference internal" href="#tp-new-and-tp-init-functions">tp_new and tp_init functions</a></li>
<li><a class="reference internal" href="#changing-and-redirecting-clinic-s-output">Changing and redirecting Clinic's output</a></li>
<li><a class="reference internal" href="#the-ifdef-trick">The #ifdef trick</a></li>
<li><a class="reference internal" href="#using-argument-clinic-in-python-files">Using Argument Clinic in Python files</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="ipaddress.html"
                        title="이전 장">ipaddress 모듈에 대한 소개</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="instrumentation.html"
                        title="다음 장">DTrace와 SystemTap으로 CPython 계측하기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="instrumentation.html" title="DTrace와 SystemTap으로 CPython 계측하기"
             >다음</a> |</li>
        <li class="right" >
          <a href="ipaddress.html" title="ipaddress 모듈에 대한 소개"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>