
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>인자 클리닉 How-To &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="DTrace와 SystemTap으로 CPython 계측하기" href="instrumentation.html" />
    <link rel="prev" title="ipaddress 모듈에 대한 소개" href="ipaddress.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/howto/clinic.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="instrumentation.html" title="DTrace와 SystemTap으로 CPython 계측하기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="ipaddress.html" title="ipaddress 모듈에 대한 소개"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="argument-clinic-how-to">
<h1>인자 클리닉 How-To<a class="headerlink" href="#argument-clinic-how-to" title="제목 주소">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">저자</dt>
<dd class="field-odd"><p>Larry Hastings</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title first">요약</p>
<p>인자 클리닉(Argument Clinic)은 CPython C 파일을 위한 전 처리기입니다. 그 목적은 &quot;내장&quot;에 대한 인자 구문 분석 코드 작성과 관련된 모든 상용구를 자동화하는 것입니다. 이 설명서는 여러분의 첫 번째 C 함수를 인자 클리닉과 함께 작동하도록 변환하는 방법을 보여준 다음, 인자 클리닉 사용에 대한 몇 가지 고급 주제를 소개합니다.</p>
<p>현재 인자 클리닉은 CPython에 내부 전용으로 간주됩니다. CPython 외부의 파일에 대해서는 사용이 지원되지 않으며, 향후 버전에서 이전 버전과의 호환성을 보장하지 않습니다. 즉: 여러분이 CPython에 대한 외부 C 확장을 유지한다면, 여러분의 자체 코드에서 인자 클리닉을 실험하는 것은 환영합니다. 그러나 다음 버전의 CPython과 함께 제공되는 인자 클리닉 버전은 완전히 호환되지 않고 여러분의 모든 코드를 망가뜨릴 수 <em>있습니다</em>.</p>
</div>
<div class="section" id="the-goals-of-argument-clinic">
<h2>인자 클리닉의 목표<a class="headerlink" href="#the-goals-of-argument-clinic" title="제목 주소">¶</a></h2>
<p>인자 클리닉의 주요 목표는 CPython 내부의 모든 인자 구문 분석 코드에 대한 책임을 인수하는 것입니다. 즉, 인자 클리닉에서 작동하도록 함수를 변환할 때, 해당 함수는 더는 자체 인자 구문 분석을 수행하지 않아야합니다 - 인자 클리닉에서 생성된 코드는 여러분에게 &quot;블랙 박스&quot;여야 합니다, CPython이 맨 위에서 호출하고, 맨 아래에서 여러분의 코드가 호출되고, <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*args</span></code> (그리고 아마도 <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*kwargs</span></code>)가 여러분이 필요로 하는 C 변수와 형으로 마술처럼 변환됩니다.</p>
<p>인자 클리닉이 기본 목표를 달성하려면, 사용하기 쉬워야합니다. 현재, CPython의 인자 구문 분석 라이브러리로 작업하는 것은 따분한 일이며, 놀랄 정도로 많은 장소에서 중복된 정보를 유지해야합니다. 인자 클리닉을 사용할 때, 여러분 스스로 반복 할 필요가 없습니다.</p>
<p>분명히, 자체적으로 새로운 문제를 만들지 않으면서 자신의 문제를 해결하지 않는 한 아무도 인자 클리닉을 사용하고 싶어하지 않을 것입니다. 따라서 인자 클리닉이 올바른 코드를 생성하는 것이 가장 중요합니다. 코드가 더 빠르면 좋겠지만, 최소한 주요 속도 회귀를 도입해서는 안됩니다. (결국 인자 클리닉은 대폭적인 속도 향상을 가능하게 해야 <em>합니다</em> - 범용 CPython 인자 구문 분석 라이브러리를 호출하는 대신 맞춤형 인자 구문 분석 코드를 생성하도록 코드 생성기를 다시 작성할 수 있습니다. 그러면 가능한 가장 빠른 인자 구문 분석이 될 것입니다!)</p>
<p>또한, 인자 클리닉은 인자 구문 분석에 대한 모든 접근 방식을 사용할 수 있을만큼 유연해야합니다. 파이썬에는 매우 이상한 구문 분석 동작을 가진 몇 가지 함수가 있습니다; 인자 클리닉의 목표는 이들 모두를 지원하는 것입니다.</p>
<p>마지막으로, 인자 클리닉의 원래 동기는 CPython 내장에 대한 인트로스펙션 &quot;서명&quot;을 제공하는 것이었습니다. 예전에는 내장을 전달하면 인트로스펙션 조회 함수에서 예외가 발생했습니다. 인자 클리닉을 사용하면, 그것은 과거의 일입니다!</p>
<p>인자 클리닉과 함께 일할 때, 명심해야 할 한 가지 아이디어가 있습니다: 더 많은 정보를 제공할수록, 더 나은 작업을 수행할 수 있습니다. 인자 클리닉은 현재 비교적 간단합니다. 그러나 진화함에 따라 더 정교해질 것이며, 여러분이 제공하는 모든 정보로 많은 흥미롭고 현명한 일을 할 수 있어야합니다.</p>
</div>
<div class="section" id="basic-concepts-and-usage">
<h2>기본 개념과 사용법<a class="headerlink" href="#basic-concepts-and-usage" title="제목 주소">¶</a></h2>
<p>인자 클리닉은 CPython과 함께 제공됩니다; <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>에서 찾을 수 있습니다. 해당 스크립트를 실행하면, C 파일을 인자로 지정합니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python3 Tools/clinic/clinic.py foo.c
</pre></div>
</div>
<p>인자 클리닉은 파일을 스캔하여 다음과 같은 줄을 찾습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*[clinic input]
</pre></div>
</div>
<p>찾으면, 다음과 같은 줄까지 모든 것을 읽습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[clinic start generated code]*/
</pre></div>
</div>
<p>이 두 줄 사이의 모든 것은 인자 클리닉에 대한 입력입니다. 시작과 끝 주석 줄을 포함하여, 이러한 모든 줄을 총칭하여 인자 클리닉 &quot;블록&quot;이라고 합니다.</p>
<p>인자 클리닉이 이러한 블록 중 하나를 구문 분석할 때, 출력을 생성합니다. 이 출력은 C 파일의 블록 바로 뒤에 다시 쓰여지고, 체크섬이 포함된 주석이 이어집니다. 인자 클리닉 블록은 이제 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*[clinic input]
... clinic input goes here ...
[clinic start generated code]*/
... clinic output goes here ...
/*[clinic end generated code: checksum=...]*/
</pre></div>
</div>
<p>같은 파일에서 인자 클리닉을 두 번 실행하면, 인자 클리닉은 이전 출력을 버리고 새로운 체크섬 줄로 새 출력을 작성합니다. 그러나, 입력이 변경되지 않았으면, 출력도 변경되지 않습니다.</p>
<p>인자 클리닉 블록의 출력 부분을 수정해서는 안됩니다. 대신, 원하는 출력을 생성 할 때까지 입력을 변경하십시오. (그것이 체크섬의 목적입니다 - 누군가 출력을 변경했는지 감지하는 것, 다음에 인자 클리닉이 새로운 출력을 작성할 때 이러한 편집이 손실되기 때문입니다.)</p>
<p>명확성을 위해, 인자 클리닉에서 사용할 용어는 다음과 같습니다:</p>
<ul class="simple">
<li><p>주석의 첫 번째 줄(<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">input]</span></code>)은 <em>시작 줄(start line)</em>입니다.</p></li>
<li><p>초기 주석의 마지막 줄(<code class="docutils literal notranslate"><span class="pre">[clinic</span> <span class="pre">start</span> <span class="pre">generated</span> <span class="pre">code]*/</span></code>)은 <em>끝 줄(end line)</em>입니다.</p></li>
<li><p>마지막 줄(<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">end</span> <span class="pre">generated</span> <span class="pre">code:</span> <span class="pre">checksum=...]*/</span></code>)은 <em>체크섬 줄(checksum line)</em>입니다.</p></li>
<li><p>시작 줄과 끝 줄 사이에 잇는 것이 <em>입력(input)</em>입니다.</p></li>
<li><p>끝 줄과 체크섬 줄 사이에 있는 것이 <em>출력(output)</em>입니다.</p></li>
<li><p>시작 줄에서 체크섬 줄까지 모든 텍스트는 총칭하여 <em>블록(block)</em>입니다. (인자 클리닉에서 성공적으로 처리되지 않은 블록은 아직 출력이나 체크섬 줄이 없지만, 여전히 블록으로 간주합니다.)</p></li>
</ul>
</div>
<div class="section" id="converting-your-first-function">
<h2>첫 번째 함수 변환하기<a class="headerlink" href="#converting-your-first-function" title="제목 주소">¶</a></h2>
<p>인자 클리닉의 작동 방식을 이해하는 가장 좋은 방법은 함수를 작동하도록 변환하는 것입니다. 다음은, 인자 클리닉에서 작동하도록 함수를 변환하기 위해 따라야 할 최소한의 단계입니다. CPython에 체크인하려는 코드의 경우, 살명서의 뒷부분에서 볼 수있는 고급 개념(&quot;반환 변환기&quot;와 &quot;self 변환기&quot;와 같은)을 사용하여 변환 작업을 더 진행해야합니다. 하지만 이 연습에서는 배우기 쉽도록 간단하게 유지하겠습니다.</p>
<p>뛰어 듭시다!</p>
<ol class="arabic" start="0">
<li><p>CPython trunk의 새로 갱신된 체크 아웃으로 작업하고 있는지 확인하십시오.</p></li>
<li><p><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>를 호출하고, 아직 인자 클리닉에서 작동하도록 변환되지 않은 파이썬 내장을 찾습니다. 제 예에서는 <code class="docutils literal notranslate"><span class="pre">_pickle.Pickler.dump()</span></code>를 사용하고 있습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyArg_Parse</span></code> 함수에 대한 호출이 다음 포맷 단위 중 하나를 사용하거나:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>O&amp;
O!
es
es#
et
et#
</pre></div>
</div>
<p>또는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>에 대한 여러 호출이 있으면, 다른 함수를 선택해야합니다. 인자 클리닉은 이러한 모든 시나리오를 <em>지원합니다</em>. 그러나 이것들은 고급 주제입니다 - 첫 번째 함수로 더 간단한 것을 해봅시다.</p>
<p>또한, 함수가 같은 인자에 대해 다른 형을 지원하는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>에 대한 여러 호출이 있거나, 함수가 인자를 구문 분석하기 위해 PyArg_Parse 함수 이외의 것을 사용하면, 인자 클리닉으로 변환하는 데 적합하지 않을 수 있습니다. 인자 클리닉은 제네릭 함수나 다형성 매개 변수를 지원하지 않습니다.</p>
</li>
<li><p>함수 위에 다음과 같은 상용구를 추가하여, 블록을 만듭니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>독스트링을 잘라내어 <code class="docutils literal notranslate"><span class="pre">[clinic]</span></code> 줄 사이에 붙여 넣고, 적절하게 인용된 C 문자열을 만드는 모든 정크들을 제거합니다. 완료되면 왼쪽 여백을 기준으로 텍스트가 80자보다 넓은 줄이 없는, 텍스트만 남게됩니다. (인자 클리닉은 독스트링 내부의 들여 쓰기를 유지합니다.)</p>
<p>이전 독스트링에 함수 서명처럼 보이는 첫 번째 줄이 있으면, 해당 줄을 버립니다. (독스트링은 이것이 더는 필요하지 않습니다 - 향후 내장에 <code class="docutils literal notranslate"><span class="pre">help()</span></code>를 사용할 때, 첫 번째 줄은 함수의 서명에 따라 자동으로 구축됩니다.)</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>독스트링에 &quot;요약&quot; 줄이 없으면, 인자 클리닉이 불평합니다. 그러니 하나 있도록 합시다. &quot;요약&quot; 줄은 독스트링의 시작 부분에 있는 단일 80열 줄로 구성된 단락이어야 합니다.</p>
<p>(예제 독스트링은 요약 줄로만 구성되어서, 이 단계에서 샘플 코드를 변경할 필요가 없습니다.)</p>
</li>
<li><p>독스트링 위에, 함수 이름을 입력 한 다음, 빈 줄을 입력합니다. 이것은 함수의 파이썬 이름이어야하며, 함수에 대한 전체 점표기법 경로여야 합니다 - 모듈 이름으로 시작하고, 모든 하위 모듈을 포함해야하며, 함수가 클래스의 메서드이면 클래스 이름도 포함해야합니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>이 C 파일에서 해당 모듈이나 클래스가 인자 클리닉과 함께 처음 사용된 것이면, 모듈 및/또는 클래스를 선언해야합니다. 적절한 인자 클리닉 위생법은 인클루드 파일과 정적 객체가 상단에 가는 것과 같은 방식으로 C 파일의 상단 근처에 있는 별도의 블록에 이를 선언하는 것을 선호합니다. (샘플 코드에서는 서로 옆에 있는 두 블록만 표시합니다.)</p>
<p>클래스와 모듈의 이름은 파이썬에서 보는 이름과 같아야합니다. <a class="reference internal" href="../c-api/module.html#c.PyModuleDef" title="PyModuleDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyModuleDef</span></code></a>나 <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>에 정의된 이름을 적절하게 확인하십시오.</p>
<p>클래스를 선언할 때, C에서 해당 형의 두 가지 측면을 지정해야합니다: 이 클래스의 인스턴스에 대한 포인터에 사용할 형 선언, 그리고 이 클래스를 위한 <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>에 대한 포인터.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>각 매개 변수를 함수에 선언합니다. 각 매개 변수는 자체 줄을 가져야합니다. 모든 매개 변수 줄은 함수 이름과 독스트링에서 들여 쓰기되어야합니다.</p>
<p>이러한 매개 변수 줄의 일반적인 형식은 다음과 같습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name_of_parameter: converter
</pre></div>
</div>
<p>매개 변수에 기본값이 있으면, 변환기(converter) 뒤에 추가하십시오:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name_of_parameter: converter = default_value
</pre></div>
</div>
<p>&quot;기본값&quot;에 대한 인자 클리닉의 지원은 매우 정교합니다; 자세한 내용은 <a class="reference internal" href="#default-values"><span class="std std-ref">아래의 기본값에 관한 섹션</span></a>을 참조하십시오.</p>
<p>매개 변수 아래에 빈 줄을 추가합니다.</p>
<p>&quot;변환기(converter)&quot;는 무엇일까요? C에서 사용되는 변수의 형과, 실행 시간에 파이썬 값을 C 값으로 변환하는 방법을 모두 설정합니다. 지금은 이전 코드를 인자 클리닉으로 더 쉽게 이식할 수 있도록 고안된 편의 문법인 &quot;레거시 변환기&quot;를 사용할 것입니다.</p>
<p>매개 변수마다, <code class="docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code> format 인자에서 해당 매개 변수의 &quot;포맷 단위&quot;를 복사하고 <em>그것을</em> (따옴표로 묶은 문자열로) 변환기로 지정하십시오. (&quot;포맷 단위&quot;는 인자 구문 분석 함수에 변수 형과 변환 방법을 알려주는 <code class="docutils literal notranslate"><span class="pre">format</span></code> 매개 변수의 1~3 문자 부분 문자열에 대한 공식 이름입니다. 포맷 단위에 대한 자세한 내용은 <a class="reference internal" href="../c-api/arg.html#arg-parsing"><span class="std std-ref">인자 구문 분석과 값 구축</span></a>을 참조하십시오. )</p>
<p><code class="docutils literal notranslate"><span class="pre">z#</span></code>과 같은 다중 문자 포맷 단위의 경우, 전체 2~3 문자 문자열 전체를 사용합니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span> <span class="cm">/*[clinic input]</span>
<span class="cm"> module _pickle</span>
<span class="cm"> class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm"> [clinic start generated code]*/</span>

 <span class="cm">/*[clinic input]</span>
<span class="cm"> _pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>함수의 포맷 문자열에 <code class="docutils literal notranslate"><span class="pre">|</span></code>가 있으면 (일부 매개 변수에 기본값이 있음을 의미합니다), 무시할 수 있습니다. 인자 클리닉은 기본값이 있는지에 따라 어떤 매개 변수가 선택적인지 유추합니다.</p>
<p>함수의 포맷 문자열에 <code class="docutils literal notranslate"><span class="pre">$</span></code>가 있으면 (키워드 전용 인자를 취함을 의미합니다), 첫 번째 키워드 전용 인자 앞에 <code class="docutils literal notranslate"><span class="pre">*</span></code>를 별도의 줄로 지정하고 매개 변수 줄과 같게 들여 쓰기합니다.</p>
<p>(<code class="docutils literal notranslate"><span class="pre">_pickle.Pickler.dump</span></code>에는 둘 다 없어서, 샘플은 변경되지 않습니다.)</p>
</li>
<li><p>기존 C 함수가 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>를 호출하면 (<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>가 아니라), 모든 인자는 위치 전용입니다.</p>
<p>인자 클리닉에서 모든 매개 변수를 위치 전용으로 표시하려면, 마지막 매개 변수 뒤에 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 추가하고 매개 변수 줄과 같게 들여 쓰기합니다.</p>
<p>현재 이것은 전부아니면 전무입니다; 모든 매개 변수가 위치 전용이거나, 아무 것도 아닙니다. (향후 인자 클리닉에서 이 제한을 완화할 수 있습니다.)</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>매개 변수마다 매개 변수 별 독스트링을 작성하는 것이 유용합니다. 그러나 매개 변수 별 독스트링은 선택 사항입니다; 원한다면 이 단계를 건너뛸 수 있습니다.</p>
<p>매개 변수 별 독스트링을 추가하는 방법은 다음과 같습니다. 매개 변수 별 독스트링의 첫 번째 줄은 매개 변수 정의보다 더 들여 써야합니다. 이 첫 번째 줄의 왼쪽 여백은 전체 매개 변수 별 독스트링에 대한 왼쪽 여백을 설정합니다; 작성하는 모든 텍스트는 이 양만큼 내어 쓰기됩니다. 원한다면 여러 줄에 걸쳐, 원하는만큼 텍스트를 작성할 수 있습니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>파일을 저장하고 닫은 다음, 그것에 대해 <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>를 실행합니다. 운 좋게도 모든 것이 작동했습니다---이제 블록에 출력이 있고 <code class="docutils literal notranslate"><span class="pre">.c.h</span></code> 파일이 생성되었습니다! 텍스트 편집기에서 파일을 다시 열어 다음을 확인하십시오:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="n">_pickle_Pickler_dump</span><span class="p">(</span><span class="n">PicklerObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/</span>
</pre></div>
</div>
<p>명백히, 인자 클리닉이 출력을 생성하지 않았다면, 입력에서 에러를 발견했기 때문입니다. 인자 클리닉이 불평 없이 파일을 처리할 때까지 에러를 수정하고 재시도하십시오.</p>
<p>가독성을 위해, 대부분의 글루 코드는 <code class="docutils literal notranslate"><span class="pre">.c.h</span></code> 파일에 생성되었습니다. 일반적으로 클리닉 모듈 블록 바로 뒤에서, 원본 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 파일에 포함해야할 필요가 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;clinic/_pickle.c.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</li>
<li><p>인자 클리닉에서 생성한 인자 구문 분석 코드가 기본적으로 기존 코드와 같은 지 다시 확인합니다.</p>
<p>먼저, 두 곳에서 같은 인자 구문 분석 함수를 사용하는지 확인하십시오. 기존 코드는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>를 호출해야합니다; 인자 클리닉에서 생성 한 코드가 <em>정확히</em> 같은 함수를 호출하는지 확인합니다.</p>
<p>둘째, <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이나 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>에 전달된 포맷 문자열은 콜론이나 세미콜론까지 기존 함수에서 손으로 쓴 것과 <em>정확히</em> 같아야 합니다.</p>
<p>(인자 클리닉은 항상 <code class="docutils literal notranslate"><span class="pre">:</span></code> 뒤에 함수 이름이 있는 포맷 문자열을 생성합니다. 기존 코드의 포맷 문자열이 <code class="docutils literal notranslate"><span class="pre">;</span></code>로 끝나면 (사용법 도움말을 제공하기 위해), 이 변경 사항은 무해합니다 - 걱정하지 마십시오.)</p>
<p>셋째, 포맷 단위가 두 개의 인자(가령 길이 변수, 인코딩 문자열 또는 변환 함수에 대한 포인터)를 요구하는 매개 변수의 경우, 두 번째 인자가 두 호출 간에 <em>정확히</em> 같은지 확인하십시오.</p>
<p>넷째, 블록의 출력 부분 내부에 이 내장에 적합한 정적 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체를 정의하는 전 처리기 매크로가 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __PICKLE_PICKLER_DUMP_METHODDEF    \</span>
<span class="cp">{&quot;dump&quot;, (PyCFunction)__pickle_Pickler_dump, METH_O, __pickle_Pickler_dump__doc__},</span>
</pre></div>
</div>
<p>이 정적 구조체는 이 내장의 기존 정적 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체와 <em>정확히</em> 같아야 합니다.</p>
<p>이러한 항목 중 <em>어떤 식으로</em>건 다른 항목이 있으면, 인자 클리닉 함수 명세를 조정하고 같아질 때 까지 <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>를 다시 실행합니다.</p>
</li>
<li><p>출력의 마지막 줄은 &quot;impl&quot; 함수의 선언임에 유의하십시오. 여기가 내장 구현이 들어가는 곳입니다. 수정중인 함수의 기존 프로토타입을 삭제하십시오, 하지만 여는 중괄호는 그대로 둡니다. 이제 인자 구문 분석 코드와 인자를 덤프하는 모든 변수의 선언을 삭제합니다. 이제 어떤 식으로 파이썬 인자가 이 impl 함수에 대한 인자가 되는지 주목하십시오; 구현에서 이러한 변수에 다른 이름을 사용했다면, 수정하십시오.</p>
<p>좀 괴상하니, 반복합시다. 이제 코드는 다음과 같아야합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">return_type</span>
<span class="nf">your_function_impl</span><span class="p">(...)</span>
<span class="cm">/*[clinic end generated code: checksum=...]*/</span>
<span class="p">{</span>
<span class="p">...</span>
</pre></div>
</div>
<p>인자 클리닉은 체크섬 줄과 그 바로 위에 함수 프로토타입을 생성했습니다. 함수와 내부 구현에 대한 여는 (그리고 닫는) 중괄호를 작성해야합니다.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>
<span class="cm">/*[clinic end generated code: checksum=da39a3ee5e6b4b0d3255bfef95601890afd80709]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="n">PyDoc_STRVAR</span><span class="p">(</span><span class="n">__pickle_Pickler_dump__doc__</span><span class="p">,</span>
<span class="s">&quot;Write a pickled representation of obj to the open file.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="p">...</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="n">_pickle_Pickler_dump_impl</span><span class="p">(</span><span class="n">PicklerObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: checksum=3bd30745bf206a48f8b576a1da3d90f55a0a4187]*/</span>
<span class="p">{</span>
    <span class="cm">/* Check whether the Pickler was initialized correctly (issue3664).</span>
<span class="cm">       Developers often forget to call __init__() in their subclasses, which</span>
<span class="cm">       would trigger a segfault without this check. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PicklingError</span><span class="p">,</span>
                     <span class="s">&quot;Pickler.__init__() was not called by %s.__init__()&quot;</span><span class="p">,</span>
                     <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_Pickler_ClearBuffer</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="p">...</span>
</pre></div>
</div>
</li>
<li><p>이 함수에 대한 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체의 매크로를 기억하십니까? 이 함수에 대한 기존 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체를 찾아 매크로에 대한 참조로 바꿉니다. (내장이 모듈 스코프에 있으면, 아마도 파일의 끝 부분에 가까울 것입니다; 내장이 클래스 메서드이면, 아마도 아래에 있지만 상대적으로 구현에 가까울 것입니다.)</p>
<p>매크로 본문에는 후행 쉼표가 포함되어 있음에 유의하십시오. 따라서 기존의 정적 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체를 매크로로 바꿀 때, 끝에 쉼표를 추가하지 <em>마십시오</em>.</p>
<p>샘플:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="n">Pickler_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">__PICKLE_PICKLER_DUMP_METHODDEF</span>
    <span class="n">__PICKLE_PICKLER_CLEAR_MEMO_METHODDEF</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>                <span class="cm">/* sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p>컴파일 한 다음, 회귀 테스트 스위트의 관련 부분을 실행합니다. 이 변경으로 인해 새로운 컴파일 시간 경고나 에러가 발생해서는 안되며, 파이썬의 동작에 대해 외부에서 볼 수있는 변경 사항이 없어야합니다.</p>
<p>한 가지 차이점이 있습니다: 함수에대해 실행되는 <code class="docutils literal notranslate"><span class="pre">inspect.signature()</span></code>는 이제 유효한 서명을 제공해야합니다!</p>
<p>축하합니다, 인자 클리닉과 함께 작동하는 첫 번째 함수를 이식했습니다!</p>
</li>
</ol>
</div>
<div class="section" id="advanced-topics">
<h2>고급 주제<a class="headerlink" href="#advanced-topics" title="제목 주소">¶</a></h2>
<p>이제 인자 클리닉으로 작업한 경험이 있고, 몇 가지 고급 주제를 살펴볼 시간입니다.</p>
<div class="section" id="symbolic-default-values">
<h3>기호 기본값<a class="headerlink" href="#symbolic-default-values" title="제목 주소">¶</a></h3>
<p>매개 변수에 제공하는 기본값은 임의의 표현식이 될 수 없습니다. 현재 다음이 명시 적으로 지원됩니다:</p>
<ul class="simple">
<li><p>숫자 상수 (정수와 부동 소수점)</p></li>
<li><p>문자열 상수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> 및 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code>와 같은 간단한 기호 상수, 모듈 이름으로 시작해야합니다</p></li>
</ul>
<p>궁금한 점이 있을 때를 위해, 이것은 <code class="docutils literal notranslate"><span class="pre">Lib/inspect.py</span></code>의 <code class="docutils literal notranslate"><span class="pre">from_builtin()</span></code>에서 구현됩니다.</p>
<p>(미래에는, <code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">-</span> <span class="pre">1</span></code>와 같은 완전한 표현식을 허용하기 위해, 더 정교해질 필요가 있습니다.)</p>
</div>
<div class="section" id="renaming-the-c-functions-and-variables-generated-by-argument-clinic">
<h3>인자 클리닉에서 생성한 C 함수와 변수 이름 변경하기<a class="headerlink" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic" title="제목 주소">¶</a></h3>
<p>인자 클리닉은 자동으로 생성되는 함수의 이름을 지정합니다. 생성된 이름이 기존 C 함수의 이름과 충돌하면, 때때로 이로 인해 문제가 발생할 수 있습니다. 쉬운 해결책이 있습니다: C 함수에 사용되는 이름을 재정의하는 것입니다. 함수 선언 줄에 키워드 <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code>를 추가 한 다음 사용하려는 함수 이름을 추가하면됩니다. 인자 클리닉은 기본 (생성된) 함수에 해당 함수 이름을 사용한 다음, 끝에 <code class="docutils literal notranslate"><span class="pre">&quot;_impl&quot;</span></code>를 추가하고 이를 impl 함수의 이름에 사용합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">pickle.Pickler.dump</span></code>에 대해 생성된 C 함수 이름을 바꾸려면, 다음과 같이됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump as pickler_dumper</span>

<span class="cm">...</span>
</pre></div>
</div>
<p>이제 기본 함수의 이름은 <code class="docutils literal notranslate"><span class="pre">pickler_dumper()</span></code>이고 impl 함수의 이름은 <code class="docutils literal notranslate"><span class="pre">pickler_dumper_impl()</span></code>이 됩니다.</p>
<p>마찬가지로, 매개 변수에 특정 파이썬 이름을 지정하려고 하지만, 해당 이름이 C에서 불편할 수 있는 경우 문제가 있을 수 있습니다. 인자 클리닉에서는 같은 <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> 문법을 사용하여, 파이썬과 C에서 매개 변수에 다른 이름을 지정할 수 있도록 합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump</span>

<span class="cm">    obj: object</span>
<span class="cm">    file as file_obj: object</span>
<span class="cm">    protocol: object = NULL</span>
<span class="cm">    *</span>
<span class="cm">    fix_imports: bool = True</span>
</pre></div>
</div>
<p>여기서, 파이썬에서 사용되는 이름(서명과 <code class="docutils literal notranslate"><span class="pre">keywords</span></code> 배열에서)은 <code class="docutils literal notranslate"><span class="pre">file</span></code>이지만, C 변수의 이름은 <code class="docutils literal notranslate"><span class="pre">file_obj</span></code>입니다.</p>
<p>이것을 사용하여 <code class="docutils literal notranslate"><span class="pre">self</span></code> 매개 변수의 이름도 바꿀 수 있습니다!</p>
</div>
<div class="section" id="converting-functions-using-pyarg-unpacktuple">
<h3>PyArg_UnpackTuple을 사용하여 함수 변환하기<a class="headerlink" href="#converting-functions-using-pyarg-unpacktuple" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>로 인자를 구문 분석하는 함수를 변환하려면, 각 인자를 <code class="docutils literal notranslate"><span class="pre">object</span></code>로 지정하여 모든 인자를 작성하면됩니다. <code class="docutils literal notranslate"><span class="pre">type</span></code> 인자를 지정하여 형을 적절하게 캐스트 할 수 있습니다. 모든 인자는 위치 전용으로 표시되어야합니다 (마지막 인자 뒤에 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 자체 줄로 추가하십시오).</p>
<p>현재 생성된 코드는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>를 사용하지만, 곧 변경됩니다.</p>
</div>
<div class="section" id="optional-groups">
<h3>선택적 그룹<a class="headerlink" href="#optional-groups" title="제목 주소">¶</a></h3>
<p>일부 레거시 함수는 인자를 구문 분석하는 데 까다로운 접근 방식을 사용합니다: 위치 인자의 수를 계산한 다음 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 문을 사용하여 위치 인자의 수에 따라 여러 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 호출 중 하나를 호출합니다. (이러한 함수는 키워드 전용 인자를 받아들일 수 없습니다.) 이 접근 방식은 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>가 만들어지기 전에 선택적 인자를 시뮬레이션하는 데 사용되었습니다.</p>
<p>이 접근 방식을 사용하는 함수는 종종 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, 선택적 인자 및 기본값을 사용하도록 변환될 수 있지만, 항상 가능한 것은 아닙니다. 이러한 레거시 함수 중 일부에는 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>가 직접 지원하지 않는 동작이 있습니다. 가장 명백한 예는 필수 인자의 <em>좌</em> 측에 선택적 인자가 있는 내장 함수 <code class="docutils literal notranslate"><span class="pre">range()</span></code>입니다! 또 다른 예는 항상 함께 지정되어야 하는 두 개의 인자 그룹이있는 <code class="docutils literal notranslate"><span class="pre">curses.window.addch()</span></code>입니다. (인자는 <code class="docutils literal notranslate"><span class="pre">x</span></code>와 <code class="docutils literal notranslate"><span class="pre">y</span></code>라고 합니다; 함수를 호출할 때 <code class="docutils literal notranslate"><span class="pre">x</span></code>를 전달하면 <code class="docutils literal notranslate"><span class="pre">y</span></code>도 전달해야 합니다 - 그리고 <code class="docutils literal notranslate"><span class="pre">x</span></code>를 전달하지 않으면 <code class="docutils literal notranslate"><span class="pre">y</span></code>도 전달할 수 없습니다.)</p>
<p>어쨌든, 인자 클리닉의 목표는 의미를 변경하지 않고 기존의 모든 CPython 내장에 대한 인자 구문 분석을 지원하는 것입니다. 따라서 인자 클리닉은 <em>선택적 그룹(optional groups)</em>이라는 것을 사용하여, 구문 분석에 대한 이러한 대체 접근 방식을 지원합니다. 선택적 그룹은 모두 함께 전달되어야 하는 인자 그룹입니다. 필수 인자의 왼쪽 또는 오른쪽에 있을 수 있습니다. 위치 전용 매개 변수에만 사용할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>선택적 그룹은 <em>오직</em> <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>를 여러 번 호출하는 함수를 변환 할 때 사용하려는 것입니다! 인자를 구문 분석하기 위해 <em>다른</em> 접근 방식을 사용하는 함수는 <em>거의 절대</em> 선택적 그룹을 사용하여 인자 클리닉으로 변환되지 않습니다. 선택적 그룹을 사용하는 함수는 현재 파이썬에서 정확한 서명을 가질 수 없습니다, 파이썬이 개념을 이해하지 못하기 때문입니다. 가능한 한 선택적 그룹을 사용하지 마십시오.</p>
</div>
<p>선택적 그룹을 지정하려면, 함께 그룹화하려는 매개 변수 앞에 <code class="docutils literal notranslate"><span class="pre">[</span></code>를 단독 줄로 추가하고, 이러한 매개 변수 뒤에 단독 줄로 <code class="docutils literal notranslate"><span class="pre">]</span></code>를 추가합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">curses.window.addch</span></code>가 선택적 그룹을 사용하여 처음 두 매개 변수와 마지막 매개 변수를 선택적으로 만드는 방법은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>

<span class="cm">curses.window.addch</span>

<span class="cm">    [</span>
<span class="cm">    x: int</span>
<span class="cm">      X-coordinate.</span>
<span class="cm">    y: int</span>
<span class="cm">      Y-coordinate.</span>
<span class="cm">    ]</span>

<span class="cm">    ch: object</span>
<span class="cm">      Character to add.</span>

<span class="cm">    [</span>
<span class="cm">    attr: long</span>
<span class="cm">      Attributes for the character.</span>
<span class="cm">    ]</span>
<span class="cm">    /</span>

<span class="cm">...</span>
</pre></div>
</div>
<p>노트:</p>
<ul class="simple">
<li><p>모든 선택적 그룹에 대해, 하나의 추가 매개 변수가 impl 함수로 전달되어 그룹을 나타냅니다. 매개 변수는 <code class="docutils literal notranslate"><span class="pre">group_{direction}_{number}</span></code>라는 이름의 정수입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">{direction}</span></code>은 그룹이 필수 매개 변수 앞인지 뒤인지에 따라 <code class="docutils literal notranslate"><span class="pre">right</span></code>나 <code class="docutils literal notranslate"><span class="pre">left</span></code>이고, <code class="docutils literal notranslate"><span class="pre">{number}</span></code>는 그룹이 필수 매개 변수에서 얼마나 멀리 떨어져 있는지를 나타내는 단조 증가하는 숫자(1에서 시작)입니다. impl이 호출 될 때, 이 그룹이 사용되지 않았으면 이 매개 변수는 0으로 설정되고, 이 그룹이 사용 되면 0이 아닌 값으로 설정됩니다. (사용했다는 표현은, 매개 변수가 이 호출에서 인자를 받았는지를 의미합니다.)</p></li>
<li><p>필수 인자가 없으면, 선택적 그룹은 필수 인자의 오른쪽에 있는 것처럼 작동합니다.</p></li>
<li><p>모호한 경우, 인자 구문 분석 코드는 왼쪽(필수 매개 변수 앞)의 매개 변수를 선호합니다.</p></li>
<li><p>선택적 그룹은 위치 전용 매개 변수 만 포함할 수 있습니다.</p></li>
<li><p>선택적 그룹은 <em>오직</em> 레거시 코드를 위한 것입니다. 새 코드에 선택적 그룹을 사용하지 마십시오.</p></li>
</ul>
</div>
<div class="section" id="using-real-argument-clinic-converters-instead-of-legacy-converters">
<h3>Using real Argument Clinic converters, instead of &quot;legacy converters&quot;<a class="headerlink" href="#using-real-argument-clinic-converters-instead-of-legacy-converters" title="제목 주소">¶</a></h3>
<p>To save time, and to minimize how much you need to learn
to achieve your first port to Argument Clinic, the walkthrough above tells
you to use &quot;legacy converters&quot;.  &quot;Legacy converters&quot; are a convenience,
designed explicitly to make porting existing code to Argument Clinic
easier.  And to be clear, their use is acceptable when porting code for
Python 3.4.</p>
<p>However, in the long term we probably want all our blocks to
use Argument Clinic's real syntax for converters.  Why?  A couple
reasons:</p>
<ul class="simple">
<li><p>The proper converters are far easier to read and clearer in their intent.</p></li>
<li><p>There are some format units that are unsupported as &quot;legacy converters&quot;,
because they require arguments, and the legacy converter syntax doesn't
support specifying arguments.</p></li>
<li><p>In the future we may have a new argument parsing library that isn't
restricted to what <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> supports; this flexibility
won't be available to parameters using legacy converters.</p></li>
</ul>
<p>Therefore, if you don't mind a little extra effort, please use the normal
converters instead of legacy converters.</p>
<p>In a nutshell, the syntax for Argument Clinic (non-legacy) converters
looks like a Python function call.  However, if there are no explicit
arguments to the function (all functions take their default values),
you may omit the parentheses.  Thus <code class="docutils literal notranslate"><span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">bool()</span></code> are exactly
the same converters.</p>
<p>All arguments to Argument Clinic converters are keyword-only.
All Argument Clinic converters accept the following arguments:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">c_default</span></code></dt><dd><p>The default value for this parameter when defined in C.
Specifically, this will be the initializer for the variable declared
in the &quot;parse function&quot;.  See <a class="reference internal" href="#default-values"><span class="std std-ref">the section on default values</span></a>
for how to use this.
Specified as a string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">annotation</span></code></dt><dd><p>The annotation value for this parameter.  Not currently supported,
because <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> mandates that the Python library may not use
annotations.</p>
</dd>
</dl>
</div></blockquote>
<p>In addition, some converters accept additional arguments.  Here is a list
of these arguments, along with their meanings:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">accept</span></code></dt><dd><p>A set of Python types (and possibly pseudo-types);
this restricts the allowable Python argument to values of these types.
(This is not a general-purpose facility; as a rule it only supports
specific lists of types as shown in the legacy converter table.)</p>
<p>To accept <code class="docutils literal notranslate"><span class="pre">None</span></code>, add <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> to this set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitwise</span></code></dt><dd><p>Only supported for unsigned integers.  The native integer value of this
Python argument will be written to the parameter without any range checking,
even for negative values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">converter</span></code></dt><dd><p>Only supported by the <code class="docutils literal notranslate"><span class="pre">object</span></code> converter.  Specifies the name of a
<a class="reference internal" href="../c-api/arg.html#o-ampersand"><span class="std std-ref">C &quot;converter function&quot;</span></a>
to use to convert this object to a native type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoding</span></code></dt><dd><p>Only supported for strings.  Specifies the encoding to use when converting
this string from a Python str (Unicode) value into a C <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subclass_of</span></code></dt><dd><p>Only supported for the <code class="docutils literal notranslate"><span class="pre">object</span></code> converter.  Requires that the Python
value be a subclass of a Python type, as expressed in C.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Only supported for the <code class="docutils literal notranslate"><span class="pre">object</span></code> and <code class="docutils literal notranslate"><span class="pre">self</span></code> converters.  Specifies
the C type that will be used to declare the variable.  Default value is
<code class="docutils literal notranslate"><span class="pre">&quot;PyObject</span> <span class="pre">*&quot;</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zeroes</span></code></dt><dd><p>Only supported for strings.  If true, embedded NUL bytes (<code class="docutils literal notranslate"><span class="pre">'\\0'</span></code>) are
permitted inside the value.  The length of the string will be passed in
to the impl function, just after the string parameter, as a parameter named
<code class="docutils literal notranslate"><span class="pre">&lt;parameter_name&gt;_length</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>Please note, not every possible combination of arguments will work.
Usually these arguments are implemented by specific <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple</span></code>
<em>format units</em>, with specific behavior.  For example, currently you cannot
call <code class="docutils literal notranslate"><span class="pre">unsigned_short</span></code> without also specifying <code class="docutils literal notranslate"><span class="pre">bitwise=True</span></code>.
Although it's perfectly reasonable to think this would work, these semantics don't
map to any existing format unit.  So Argument Clinic doesn't support it.  (Or, at
least, not yet.)</p>
<p>Below is a table showing the mapping of legacy converters into real
Argument Clinic converters.  On the left is the legacy converter,
on the right is the text you'd replace it with.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'B'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_char(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_char</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'c'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'C'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int(accept={str})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'d'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'D'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_complex</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'es'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding')</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'es#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'et'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">accept={bytes,</span> <span class="pre">bytearray,</span> <span class="pre">str})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'et#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">accept={bytes,</span> <span class="pre">bytearray,</span> <span class="pre">str},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'h'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">short</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'H'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_short(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'i'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'I'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_int(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'k'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_long(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'K'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_long_long(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'l'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'L'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'n'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'O'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'O!'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object(subclass_of='&amp;PySomething_Type')</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'O&amp;'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object(converter='name_of_c_function')</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'p'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'S'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyBytesObject</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'s#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={buffer,</span> <span class="pre">str})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'U'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unicode</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'u'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'u#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={rwbuffer})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'Y'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyByteArrayObject</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'y'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={bytes})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'y#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={robuffer},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'y*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'Z'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(accept={str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'Z#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(accept={str,</span> <span class="pre">NoneType},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'z'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'z#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={str,</span> <span class="pre">NoneType},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'z*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={buffer,</span> <span class="pre">str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
</tbody>
</table>
<p>As an example, here's our sample <code class="docutils literal notranslate"><span class="pre">pickle.Pickler.dump</span></code> using the proper
converter:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump</span>

<span class="cm">    obj: object</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>One advantage of real converters is that they're more flexible than legacy
converters.  For example, the <code class="docutils literal notranslate"><span class="pre">unsigned_int</span></code> converter (and all the
<code class="docutils literal notranslate"><span class="pre">unsigned_</span></code> converters) can be specified without <code class="docutils literal notranslate"><span class="pre">bitwise=True</span></code>.  Their
default behavior performs range checking on the value, and they won't accept
negative numbers.  You just can't do that with a legacy converter!</p>
<p>Argument Clinic will show you all the converters it has
available.  For each converter it'll show you all the parameters
it accepts, along with the default value for each parameter.
Just run <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span> <span class="pre">--converters</span></code> to see the full list.</p>
</div>
<div class="section" id="py-buffer">
<h3>Py_buffer<a class="headerlink" href="#py-buffer" title="제목 주소">¶</a></h3>
<p>When using the <code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code> converter
(or the <code class="docutils literal notranslate"><span class="pre">'s*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'w*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*y'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'z*'</span></code> legacy converters),
you <em>must</em> not call <a class="reference internal" href="../c-api/buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> on the provided buffer.
Argument Clinic generates code that does it for you (in the parsing function).</p>
</div>
<div class="section" id="advanced-converters">
<h3>Advanced converters<a class="headerlink" href="#advanced-converters" title="제목 주소">¶</a></h3>
<p>Remember those format units you skipped for your first
time because they were advanced?  Here's how to handle those too.</p>
<p>The trick is, all those format units take arguments—either
conversion functions, or types, or strings specifying an encoding.
(But &quot;legacy converters&quot; don't support arguments.  That's why we
skipped them for your first function.)  The argument you specified
to the format unit is now an argument to the converter; this
argument is either <code class="docutils literal notranslate"><span class="pre">converter</span></code> (for <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code>), <code class="docutils literal notranslate"><span class="pre">subclass_of</span></code> (for <code class="docutils literal notranslate"><span class="pre">O!</span></code>),
or <code class="docutils literal notranslate"><span class="pre">encoding</span></code> (for all the format units that start with <code class="docutils literal notranslate"><span class="pre">e</span></code>).</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">subclass_of</span></code>, you may also want to use the other
custom argument for <code class="docutils literal notranslate"><span class="pre">object()</span></code>: <code class="docutils literal notranslate"><span class="pre">type</span></code>, which lets you set the type
actually used for the parameter.  For example, if you want to ensure
that the object is a subclass of <code class="docutils literal notranslate"><span class="pre">PyUnicode_Type</span></code>, you probably want
to use the converter <code class="docutils literal notranslate"><span class="pre">object(type='PyUnicodeObject</span> <span class="pre">*',</span> <span class="pre">subclass_of='&amp;PyUnicode_Type')</span></code>.</p>
<p>One possible problem with using Argument Clinic: it takes away some possible
flexibility for the format units starting with <code class="docutils literal notranslate"><span class="pre">e</span></code>.  When writing a
<code class="docutils literal notranslate"><span class="pre">PyArg_Parse</span></code> call by hand, you could theoretically decide at runtime what
encoding string to pass in to <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>.   But now this string must
be hard-coded at Argument-Clinic-preprocessing-time.  This limitation is deliberate;
it made supporting this format unit much easier, and may allow for future optimizations.
This restriction doesn't seem unreasonable; CPython itself always passes in static
hard-coded encoding strings for parameters whose format units start with <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
</div>
<div class="section" id="parameter-default-values">
<span id="default-values"></span><h3>Parameter default values<a class="headerlink" href="#parameter-default-values" title="제목 주소">¶</a></h3>
<p>Default values for parameters can be any of a number of values.
At their simplest, they can be string, int, or float literals:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: str = &quot;abc&quot;
bar: int = 123
bat: float = 45.6
</pre></div>
</div>
<p>They can also use any of Python's built-in constants:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>yep:  bool = True
nope: bool = False
nada: object = None
</pre></div>
</div>
<p>There's also special support for a default value of <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and
for simple expressions, documented in the following sections.</p>
</div>
<div class="section" id="the-null-default-value">
<h3>The <code class="docutils literal notranslate"><span class="pre">NULL</span></code> default value<a class="headerlink" href="#the-null-default-value" title="제목 주소">¶</a></h3>
<p>For string and object parameters, you can set them to <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate
that there's no default.  However, that means the C variable will be
initialized to <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.  For convenience's sakes, there's a special
value called <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for just this reason: from Python's perspective it
behaves like a default value of <code class="docutils literal notranslate"><span class="pre">None</span></code>, but the C variable is initialized
with <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<div class="section" id="expressions-specified-as-default-values">
<h3>Expressions specified as default values<a class="headerlink" href="#expressions-specified-as-default-values" title="제목 주소">¶</a></h3>
<p>The default value for a parameter can be more than just a literal value.
It can be an entire expression, using math operators and looking up attributes
on objects.  However, this support isn't exactly simple, because of some
non-obvious semantics.</p>
<p>Consider the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t = sys.maxsize - 1
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code> can have different values on different platforms.  Therefore
Argument Clinic can't simply evaluate that expression locally and hard-code it
in C.  So it stores the default in such a way that it will get evaluated at
runtime, when the user asks for the function's signature.</p>
<p>What namespace is available when the expression is evaluated?  It's evaluated
in the context of the module the builtin came from.  So, if your module has an
attribute called &quot;<code class="docutils literal notranslate"><span class="pre">max_widgets</span></code>&quot;, you may simply use it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t = max_widgets
</pre></div>
</div>
<p>If the symbol isn't found in the current module, it fails over to looking in
<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.  That's how it can find <code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code> for example.  (Since you
don't know in advance what modules the user will load into their interpreter,
it's best to restrict yourself to modules that are preloaded by Python itself.)</p>
<p>Evaluating default values only at runtime means Argument Clinic can't compute
the correct equivalent C default value.  So you need to tell it explicitly.
When you use an expression, you must also specify the equivalent expression
in C, using the <code class="docutils literal notranslate"><span class="pre">c_default</span></code> parameter to the converter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t(c_default=&quot;PY_SSIZE_T_MAX - 1&quot;) = sys.maxsize - 1
</pre></div>
</div>
<p>Another complication: Argument Clinic can't know in advance whether or not the
expression you supply is valid.  It parses it to make sure it looks legal, but
it can't <em>actually</em> know.  You must be very careful when using expressions to
specify values that are guaranteed to be valid at runtime!</p>
<p>Finally, because expressions must be representable as static C values, there
are many restrictions on legal expressions.  Here's a list of Python features
you're not permitted to use:</p>
<ul class="simple">
<li><p>Function calls.</p></li>
<li><p>Inline if statements (<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">if</span> <span class="pre">foo</span> <span class="pre">else</span> <span class="pre">5</span></code>).</p></li>
<li><p>Automatic sequence unpacking (<code class="docutils literal notranslate"><span class="pre">*[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>).</p></li>
<li><p>List/set/dict comprehensions and generator expressions.</p></li>
<li><p>Tuple/list/set/dict literals.</p></li>
</ul>
</div>
<div class="section" id="using-a-return-converter">
<h3>Using a return converter<a class="headerlink" href="#using-a-return-converter" title="제목 주소">¶</a></h3>
<p>By default the impl function Argument Clinic generates for you returns <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>.
But your C function often computes some C type, then converts it into the <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>
at the last moment.  Argument Clinic handles converting your inputs from Python types
into native C types—why not have it convert your return value from a native C type
into a Python type too?</p>
<p>That's what a &quot;return converter&quot; does.  It changes your impl function to return
some C type, then adds code to the generated (non-impl) function to handle converting
that value into the appropriate <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>.</p>
<p>The syntax for return converters is similar to that of parameter converters.
You specify the return converter like it was a return annotation on the
function itself.  Return converters behave much the same as parameter converters;
they take arguments, the arguments are all keyword-only, and if you're not changing
any of the default arguments you can omit the parentheses.</p>
<p>(If you use both <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> <em>and</em> a return converter for your function,
the <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> should come before the return converter.)</p>
<p>There's one additional complication when using return converters: how do you
indicate an error has occurred?  Normally, a function returns a valid (non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>)
pointer for success, and <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for failure.  But if you use an integer return converter,
all integers are valid.  How can Argument Clinic detect an error?  Its solution: each return
converter implicitly looks for a special value that indicates an error.  If you return
that value, and an error has been set (<code class="docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code> returns a true
value), then the generated code will propagate the error.  Otherwise it will
encode the value you return like normal.</p>
<p>Currently Argument Clinic supports only a few return converters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool
int
unsigned int
long
unsigned int
size_t
Py_ssize_t
float
double
DecodeFSDefault
</pre></div>
</div>
<p>None of these take parameters.  For the first three, return -1 to indicate
error.  For <code class="docutils literal notranslate"><span class="pre">DecodeFSDefault</span></code>, the return type is <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>; return a <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
pointer to indicate an error.</p>
<p>(There's also an experimental <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> converter, which lets you
return <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> on success or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure, without having
to increment the reference count on <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.  I'm not sure it adds
enough clarity to be worth using.)</p>
<p>To see all the return converters Argument Clinic supports, along with
their parameters (if any),
just run <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span> <span class="pre">--converters</span></code> for the full list.</p>
</div>
<div class="section" id="cloning-existing-functions">
<h3>Cloning existing functions<a class="headerlink" href="#cloning-existing-functions" title="제목 주소">¶</a></h3>
<p>If you have a number of functions that look similar, you may be able to
use Clinic's &quot;clone&quot; feature.  When you clone an existing function,
you reuse:</p>
<ul class="simple">
<li><p>its parameters, including</p>
<ul>
<li><p>their names,</p></li>
<li><p>their converters, with all parameters,</p></li>
<li><p>their default values,</p></li>
<li><p>their per-parameter docstrings,</p></li>
<li><p>their <em>kind</em> (whether they're positional only,
positional or keyword, or keyword only), and</p></li>
</ul>
</li>
<li><p>its return converter.</p></li>
</ul>
<p>The only thing not copied from the original function is its docstring;
the syntax allows you to specify a new docstring.</p>
<p>Here's the syntax for cloning a function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module.class.new_function [as c_basename] = module.class.existing_function</span>

<span class="cm">Docstring for new_function goes here.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>(The functions can be in different modules or classes.  I wrote
<code class="docutils literal notranslate"><span class="pre">module.class</span></code> in the sample just to illustrate that you must
use the full path to <em>both</em> functions.)</p>
<p>Sorry, there's no syntax for partially-cloning a function, or cloning a function
then modifying it.  Cloning is an all-or nothing proposition.</p>
<p>Also, the function you are cloning from must have been previously defined
in the current file.</p>
</div>
<div class="section" id="calling-python-code">
<h3>Calling Python code<a class="headerlink" href="#calling-python-code" title="제목 주소">¶</a></h3>
<p>The rest of the advanced topics require you to write Python code
which lives inside your C file and modifies Argument Clinic's
runtime state.  This is simple: you simply define a Python block.</p>
<p>A Python block uses different delimiter lines than an Argument
Clinic function block.  It looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm"># python code goes here</span>
<span class="cm">[python start generated code]*/</span>
</pre></div>
</div>
<p>All the code inside the Python block is executed at the
time it's parsed.  All text written to stdout inside the block
is redirected into the &quot;output&quot; after the block.</p>
<p>As an example, here's a Python block that adds a static integer
variable to the C code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm">print(&#39;static int __ignored_unused_variable__ = 0;&#39;)</span>
<span class="cm">[python start generated code]*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__ignored_unused_variable__</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/*[python checksum:...]*/</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-self-converter">
<h3>Using a &quot;self converter&quot;<a class="headerlink" href="#using-a-self-converter" title="제목 주소">¶</a></h3>
<p>Argument Clinic automatically adds a &quot;self&quot; parameter for you
using a default converter.  It automatically sets the <code class="docutils literal notranslate"><span class="pre">type</span></code>
of this parameter to the &quot;pointer to an instance&quot; you specified
when you declared the type.  However, you can override
Argument Clinic's converter and specify one yourself.
Just add your own <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter as the first parameter in a
block, and ensure that its converter is an instance of
<code class="docutils literal notranslate"><span class="pre">self_converter</span></code> or a subclass thereof.</p>
<p>What's the point?  This lets you override the type of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
or give it a different default name.</p>
<p>How do you specify the custom type you want to cast <code class="docutils literal notranslate"><span class="pre">self</span></code> to?
If you only have one or two functions with the same type for <code class="docutils literal notranslate"><span class="pre">self</span></code>,
you can directly use Argument Clinic's existing <code class="docutils literal notranslate"><span class="pre">self</span></code> converter,
passing in the type you want to use as the <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>

<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">  self: self(type=&quot;PicklerObject *&quot;)</span>
<span class="cm">  obj: object</span>
<span class="cm">  /</span>

<span class="cm">Write a pickled representation of the given object to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>On the other hand, if you have a lot of functions that will use the same
type for <code class="docutils literal notranslate"><span class="pre">self</span></code>, it's best to create your own converter, subclassing
<code class="docutils literal notranslate"><span class="pre">self_converter</span></code> but overwriting the <code class="docutils literal notranslate"><span class="pre">type</span></code> member:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm">class PicklerObject_converter(self_converter):</span>
<span class="cm">    type = &quot;PicklerObject *&quot;</span>
<span class="cm">[python start generated code]*/</span>

<span class="cm">/*[clinic input]</span>

<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">  self: PicklerObject</span>
<span class="cm">  obj: object</span>
<span class="cm">  /</span>

<span class="cm">Write a pickled representation of the given object to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-a-custom-converter">
<h3>Writing a custom converter<a class="headerlink" href="#writing-a-custom-converter" title="제목 주소">¶</a></h3>
<p>As we hinted at in the previous section... you can write your own converters!
A converter is simply a Python class that inherits from <code class="docutils literal notranslate"><span class="pre">CConverter</span></code>.
The main purpose of a custom converter is if you have a parameter using
the <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> format unit—parsing this parameter means calling
a <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> &quot;converter function&quot;.</p>
<p>Your converter class should be named <code class="docutils literal notranslate"><span class="pre">*something*_converter</span></code>.
If the name follows this convention, then your converter class
will be automatically registered with Argument Clinic; its name
will be the name of your class with the <code class="docutils literal notranslate"><span class="pre">_converter</span></code> suffix
stripped off.  (This is accomplished with a metaclass.)</p>
<p>You shouldn't subclass <code class="docutils literal notranslate"><span class="pre">CConverter.__init__</span></code>.  Instead, you should
write a <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code> function.  <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code>
always accepts a <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter; after that, all additional
parameters <em>must</em> be keyword-only.  Any arguments passed in to
the converter in Argument Clinic will be passed along to your
<code class="docutils literal notranslate"><span class="pre">converter_init()</span></code>.</p>
<p>There are some additional members of <code class="docutils literal notranslate"><span class="pre">CConverter</span></code> you may wish
to specify in your subclass.  Here's the current list:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>The C type to use for this variable.
<code class="docutils literal notranslate"><span class="pre">type</span></code> should be a Python string specifying the type, e.g. <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If this is a pointer type, the type string should end with <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">*'</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code></dt><dd><p>The Python default value for this parameter, as a Python value.
Or the magic value <code class="docutils literal notranslate"><span class="pre">unspecified</span></code> if there is no default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">py_default</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">default</span></code> as it should appear in Python code,
as a string.
Or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is no default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_default</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">default</span></code> as it should appear in C code,
as a string.
Or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is no default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_ignored_default</span></code></dt><dd><p>The default value used to initialize the C variable when
there is no default, but not specifying a default may
result in an &quot;uninitialized variable&quot; warning.  This can
easily happen when using option groups—although
properly-written code will never actually use this value,
the variable does get passed in to the impl, and the
C compiler will complain about the &quot;use&quot; of the
uninitialized value.  This value should always be a
non-empty string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">converter</span></code></dt><dd><p>The name of the C converter function, as a string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">impl_by_reference</span></code></dt><dd><p>A boolean value.  If true,
Argument Clinic will add a <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> in front of the name of
the variable when passing it into the impl function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parse_by_reference</span></code></dt><dd><p>A boolean value.  If true,
Argument Clinic will add a <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> in front of the name of
the variable when passing it into <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>.</p>
</dd>
</dl>
<p>Here's the simplest example of a custom converter, from <code class="docutils literal notranslate"><span class="pre">Modules/zlibmodule.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>

<span class="cm">class ssize_t_converter(CConverter):</span>
<span class="cm">    type = &#39;Py_ssize_t&#39;</span>
<span class="cm">    converter = &#39;ssize_t_converter&#39;</span>

<span class="cm">[python start generated code]*/</span>
<span class="cm">/*[python end generated code: output=da39a3ee5e6b4b0d input=35521e4e733823c7]*/</span>
</pre></div>
</div>
<p>This block adds a converter to Argument Clinic named <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code>.  Parameters
declared as <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> will be declared as type <code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>, and will
be parsed by the <code class="docutils literal notranslate"><span class="pre">'O&amp;'</span></code> format unit, which will call the
<code class="docutils literal notranslate"><span class="pre">ssize_t_converter</span></code> converter function.  <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> variables
automatically support default values.</p>
<p>More sophisticated custom converters can insert custom C code to
handle initialization and cleanup.
You can see more examples of custom converters in the CPython
source tree; grep the C files for the string <code class="docutils literal notranslate"><span class="pre">CConverter</span></code>.</p>
</div>
<div class="section" id="writing-a-custom-return-converter">
<h3>Writing a custom return converter<a class="headerlink" href="#writing-a-custom-return-converter" title="제목 주소">¶</a></h3>
<p>Writing a custom return converter is much like writing
a custom converter.  Except it's somewhat simpler, because return
converters are themselves much simpler.</p>
<p>Return converters must subclass <code class="docutils literal notranslate"><span class="pre">CReturnConverter</span></code>.
There are no examples yet of custom return converters,
because they are not widely used yet.  If you wish to
write your own return converter, please read <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code>,
specifically the implementation of <code class="docutils literal notranslate"><span class="pre">CReturnConverter</span></code> and
all its subclasses.</p>
</div>
<div class="section" id="meth-o-and-meth-noargs">
<h3>METH_O and METH_NOARGS<a class="headerlink" href="#meth-o-and-meth-noargs" title="제목 주소">¶</a></h3>
<p>To convert a function using <code class="docutils literal notranslate"><span class="pre">METH_O</span></code>, make sure the function's
single argument is using the <code class="docutils literal notranslate"><span class="pre">object</span></code> converter, and mark the
arguments as positional-only:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">meth_o_sample</span>

<span class="cm">     argument: object</span>
<span class="cm">     /</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>To convert a function using <code class="docutils literal notranslate"><span class="pre">METH_NOARGS</span></code>, just don't specify
any arguments.</p>
<p>You can still use a self converter, a return converter, and specify
a <code class="docutils literal notranslate"><span class="pre">type</span></code> argument to the object converter for <code class="docutils literal notranslate"><span class="pre">METH_O</span></code>.</p>
</div>
<div class="section" id="tp-new-and-tp-init-functions">
<h3>tp_new and tp_init functions<a class="headerlink" href="#tp-new-and-tp-init-functions" title="제목 주소">¶</a></h3>
<p>You can convert <code class="docutils literal notranslate"><span class="pre">tp_new</span></code> and <code class="docutils literal notranslate"><span class="pre">tp_init</span></code> functions.  Just name
them <code class="docutils literal notranslate"><span class="pre">__new__</span></code> or <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as appropriate.  Notes:</p>
<ul class="simple">
<li><p>The function name generated for <code class="docutils literal notranslate"><span class="pre">__new__</span></code> doesn't end in <code class="docutils literal notranslate"><span class="pre">__new__</span></code>
like it would by default.  It's just the name of the class, converted
into a valid C identifier.</p></li>
<li><p>No <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> <code class="docutils literal notranslate"><span class="pre">#define</span></code> is generated for these functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> functions return <code class="docutils literal notranslate"><span class="pre">int</span></code>, not <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>.</p></li>
<li><p>Use the docstring as the class docstring.</p></li>
<li><p>Although <code class="docutils literal notranslate"><span class="pre">__new__</span></code> and <code class="docutils literal notranslate"><span class="pre">__init__</span></code> functions must always
accept both the <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> objects, when converting
you may specify any signature for these functions that you like.
(If your function doesn't support keywords, the parsing function
generated will throw an exception if it receives any.)</p></li>
</ul>
</div>
<div class="section" id="changing-and-redirecting-clinic-s-output">
<h3>Changing and redirecting Clinic's output<a class="headerlink" href="#changing-and-redirecting-clinic-s-output" title="제목 주소">¶</a></h3>
<p>It can be inconvenient to have Clinic's output interspersed with
your conventional hand-edited C code.  Luckily, Clinic is configurable:
you can buffer up its output for printing later (or earlier!), or write
its output to a separate file.  You can also add a prefix or suffix to
every line of Clinic's generated output.</p>
<p>While changing Clinic's output in this manner can be a boon to readability,
it may result in Clinic code using types before they are defined, or
your code attempting to use Clinic-generated code before it is defined.
These problems can be easily solved by rearranging the declarations in your file,
or moving where Clinic's generated code goes.  (This is why the default behavior
of Clinic is to output everything into the current block; while many people
consider this hampers readability, it will never require rearranging your
code to fix definition-before-use problems.)</p>
<p>Let's start with defining some terminology:</p>
<dl>
<dt><em>field</em></dt><dd><p>A field, in this context, is a subsection of Clinic's output.
For example, the <code class="docutils literal notranslate"><span class="pre">#define</span></code> for the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure
is a field, called <code class="docutils literal notranslate"><span class="pre">methoddef_define</span></code>.  Clinic has seven
different fields it can output per function definition:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docstring_prototype
docstring_definition
methoddef_define
impl_prototype
parser_prototype
parser_definition
impl_definition
</pre></div>
</div>
<p>All the names are of the form <code class="docutils literal notranslate"><span class="pre">&quot;&lt;a&gt;_&lt;b&gt;&quot;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">&quot;&lt;a&gt;&quot;</span></code> is the semantic object represented (the parsing function,
the impl function, the docstring, or the methoddef structure) and <code class="docutils literal notranslate"><span class="pre">&quot;&lt;b&gt;&quot;</span></code>
represents what kind of statement the field is.  Field names that end in
<code class="docutils literal notranslate"><span class="pre">&quot;_prototype&quot;</span></code>
represent forward declarations of that thing, without the actual body/data
of the thing; field names that end in <code class="docutils literal notranslate"><span class="pre">&quot;_definition&quot;</span></code> represent the actual
definition of the thing, with the body/data of the thing.  (<code class="docutils literal notranslate"><span class="pre">&quot;methoddef&quot;</span></code>
is special, it's the only one that ends with <code class="docutils literal notranslate"><span class="pre">&quot;_define&quot;</span></code>, representing that
it's a preprocessor #define.)</p>
</dd>
<dt><em>destination</em></dt><dd><p>A destination is a place Clinic can write output to.  There are
five built-in destinations:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">block</span></code></dt><dd><p>The default destination: printed in the output section of
the current Clinic block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>A text buffer where you can save text for later.  Text sent
here is appended to the end of any existing text.  It's an
error to have any text left in the buffer when Clinic finishes
processing a file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>A separate &quot;clinic file&quot; that will be created automatically by Clinic.
The filename chosen for the file is <code class="docutils literal notranslate"><span class="pre">{basename}.clinic{extension}</span></code>,
where <code class="docutils literal notranslate"><span class="pre">basename</span></code> and <code class="docutils literal notranslate"><span class="pre">extension</span></code> were assigned the output
from <code class="docutils literal notranslate"><span class="pre">os.path.splitext()</span></code> run on the current file.  (Example:
the <code class="docutils literal notranslate"><span class="pre">file</span></code> destination for <code class="docutils literal notranslate"><span class="pre">_pickle.c</span></code> would be written to
<code class="docutils literal notranslate"><span class="pre">_pickle.clinic.c</span></code>.)</p>
<p><strong>Important: When using a</strong> <code class="docutils literal notranslate"><span class="pre">file</span></code> <strong>destination, you</strong>
<em>must check in</em> <strong>the generated file!</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>A buffer like <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.  However, a two-pass buffer can only
be dumped once, and it prints out all text sent to it during
all processing, even from Clinic blocks <em>after</em> the dumping point.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suppress</span></code></dt><dd><p>The text is suppressed—thrown away.</p>
</dd>
</dl>
</dd>
</dl>
<p>Clinic defines five new directives that let you reconfigure its output.</p>
<p>The first new directive is <code class="docutils literal notranslate"><span class="pre">dump</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dump &lt;destination&gt;
</pre></div>
</div>
<p>This dumps the current contents of the named destination into the output of
the current block, and empties it.  This only works with <code class="docutils literal notranslate"><span class="pre">buffer</span></code> and
<code class="docutils literal notranslate"><span class="pre">two-pass</span></code> destinations.</p>
<p>The second new directive is <code class="docutils literal notranslate"><span class="pre">output</span></code>.  The most basic form of <code class="docutils literal notranslate"><span class="pre">output</span></code>
is like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output &lt;field&gt; &lt;destination&gt;
</pre></div>
</div>
<p>This tells Clinic to output <em>field</em> to <em>destination</em>.  <code class="docutils literal notranslate"><span class="pre">output</span></code> also
supports a special meta-destination, called <code class="docutils literal notranslate"><span class="pre">everything</span></code>, which tells
Clinic to output <em>all</em> fields to that <em>destination</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">output</span></code> has a number of other functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output push
output pop
output preset &lt;preset&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">push</span></code> and <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">pop</span></code> allow you to push and pop
configurations on an internal configuration stack, so that you
can temporarily modify the output configuration, then easily restore
the previous configuration.  Simply push before your change to save
the current configuration, then pop when you wish to restore the
previous configuration.</p>
<p><code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">preset</span></code> sets Clinic's output to one of several built-in
preset configurations, as follows:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">block</span></code></dt><dd><p>Clinic's original starting configuration.  Writes everything
immediately after the input block.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write everything else to <code class="docutils literal notranslate"><span class="pre">block</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>Designed to write everything to the &quot;clinic file&quot; that it can.
You then <code class="docutils literal notranslate"><span class="pre">#include</span></code> this file near the top of your file.
You may need to rearrange your file to make this work, though
usually this just means creating forward declarations for various
<code class="docutils literal notranslate"><span class="pre">typedef</span></code> and <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> definitions.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code> to
<code class="docutils literal notranslate"><span class="pre">block</span></code>, and write everything else to <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p>
<p>The default filename is <code class="docutils literal notranslate"><span class="pre">&quot;{dirname}/clinic/{basename}.h&quot;</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Save up most of the output from Clinic, to be written into
your file near the end.  For Python files implementing modules
or builtin types, it's recommended that you dump the buffer
just above the static structures for your module or
builtin type; these are normally very near the end.  Using
<code class="docutils literal notranslate"><span class="pre">buffer</span></code> may require even more editing than <code class="docutils literal notranslate"><span class="pre">file</span></code>, if
your file has static <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> arrays defined in the
middle of the file.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>, <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>,
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code> to
<code class="docutils literal notranslate"><span class="pre">block</span></code>, and write everything else to <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>Similar to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset, but writes forward declarations to
the <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> buffer, and definitions to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.
This is similar to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset, but may require
less editing than <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.  Dump the <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> buffer
near the top of your file, and dump the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> near
the end just like you would when using the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset.</p>
<p>Suppresses the <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code>
to <code class="docutils literal notranslate"><span class="pre">block</span></code>, write <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, <code class="docutils literal notranslate"><span class="pre">methoddef_define</span></code>,
and <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code> to <code class="docutils literal notranslate"><span class="pre">two-pass</span></code>, write everything else
to <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">partial-buffer</span></code></dt><dd><p>Similar to the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset, but writes more things to <code class="docutils literal notranslate"><span class="pre">block</span></code>,
only writing the really big chunks of generated code to <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.
This avoids the definition-before-use problem of <code class="docutils literal notranslate"><span class="pre">buffer</span></code> completely,
at the small cost of having slightly more stuff in the block's output.
Dump the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> near the end, just like you would when using
the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> preset.</p>
<p>Suppresses the <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>, write the <code class="docutils literal notranslate"><span class="pre">docstring_definition</span></code>
and <code class="docutils literal notranslate"><span class="pre">parser_definition</span></code> to <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, write everything else to <code class="docutils literal notranslate"><span class="pre">block</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>The third new directive is <code class="docutils literal notranslate"><span class="pre">destination</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; &lt;command&gt; [...]
</pre></div>
</div>
<p>This performs an operation on the destination named <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>There are two defined subcommands: <code class="docutils literal notranslate"><span class="pre">new</span></code> and <code class="docutils literal notranslate"><span class="pre">clear</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">new</span></code> subcommand works like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; new &lt;type&gt;
</pre></div>
</div>
<p>This creates a new destination with name <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> and type <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>.</p>
<p>There are five destination types:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">suppress</span></code></dt><dd><p>Throws the text away.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block</span></code></dt><dd><p>Writes the text to the current block.  This is what Clinic
originally did.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>A simple text buffer, like the &quot;buffer&quot; builtin destination above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>A text file.  The file destination takes an extra argument,
a template to use for building the filename, like so:</p>
<blockquote>
<div><p>destination &lt;name&gt; new &lt;type&gt; &lt;file_template&gt;</p>
</div></blockquote>
<p>The template can use three strings internally that will be replaced
by bits of the filename:</p>
<blockquote>
<div><dl class="simple">
<dt>{path}</dt><dd><p>The full path to the file, including directory and full filename.</p>
</dd>
<dt>{dirname}</dt><dd><p>The name of the directory the file is in.</p>
</dd>
<dt>{basename}</dt><dd><p>Just the name of the file, not including the directory.</p>
</dd>
<dt>{basename_root}</dt><dd><p>Basename with the extension clipped off
(everything up to but not including the last '.').</p>
</dd>
<dt>{basename_extension}</dt><dd><p>The last '.' and everything after it.  If the basename
does not contain a period, this will be the empty string.</p>
</dd>
</dl>
</div></blockquote>
<p>If there are no periods in the filename, {basename} and {filename}
are the same, and {extension} is empty.  &quot;{basename}{extension}&quot;
is always exactly the same as &quot;{filename}&quot;.&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>A two-pass buffer, like the &quot;two-pass&quot; builtin destination above.</p>
</dd>
</dl>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">clear</span></code> subcommand works like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; clear
</pre></div>
</div>
<p>It removes all the accumulated text up to this point in the destination.
(I don't know what you'd need this for, but I thought maybe it'd be
useful while someone's experimenting.)</p>
<p>The fourth new directive is <code class="docutils literal notranslate"><span class="pre">set</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set line_prefix &quot;string&quot;
set line_suffix &quot;string&quot;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">set</span></code> lets you set two internal variables in Clinic.
<code class="docutils literal notranslate"><span class="pre">line_prefix</span></code> is a string that will be prepended to every line of Clinic's output;
<code class="docutils literal notranslate"><span class="pre">line_suffix</span></code> is a string that will be appended to every line of Clinic's output.</p>
<p>Both of these support two format strings:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">comment</span> <span class="pre">start}</span></code></dt><dd><p>Turns into the string <code class="docutils literal notranslate"><span class="pre">/*</span></code>, the start-comment text sequence for C files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">comment</span> <span class="pre">end}</span></code></dt><dd><p>Turns into the string <code class="docutils literal notranslate"><span class="pre">*/</span></code>, the end-comment text sequence for C files.</p>
</dd>
</dl>
</div></blockquote>
<p>The final new directive is one you shouldn't need to use directly,
called <code class="docutils literal notranslate"><span class="pre">preserve</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>preserve
</pre></div>
</div>
<p>This tells Clinic that the current contents of the output should be kept, unmodified.
This is used internally by Clinic when dumping output into <code class="docutils literal notranslate"><span class="pre">file</span></code> files; wrapping
it in a Clinic block lets Clinic use its existing checksum functionality to ensure
the file was not modified by hand before it gets overwritten.</p>
</div>
<div class="section" id="the-ifdef-trick">
<h3>The #ifdef trick<a class="headerlink" href="#the-ifdef-trick" title="제목 주소">¶</a></h3>
<p>If you're converting a function that isn't available on all platforms,
there's a trick you can use to make life a little easier.  The existing
code probably looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAVE_FUNCTIONNAME</span>
<span class="k">static</span> <span class="nf">module_functionname</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_FUNCTIONNAME */</span><span class="cp"></span>
</pre></div>
</div>
<p>And then in the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure at the bottom the existing code
will have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ifdef HAVE_FUNCTIONNAME
{&#39;functionname&#39;, ... },
#endif /* HAVE_FUNCTIONNAME */
</pre></div>
</div>
<p>In this scenario, you should enclose the body of your impl function inside the <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>,
like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAVE_FUNCTIONNAME</span>
<span class="cm">/*[clinic input]</span>
<span class="cm">module.functionname</span>
<span class="cm">...</span>
<span class="cm">[clinic start generated code]*/</span>
<span class="k">static</span> <span class="nf">module_functionname</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_FUNCTIONNAME */</span><span class="cp"></span>
</pre></div>
</div>
<p>Then, remove those three lines from the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure,
replacing them with the macro Argument Clinic generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODULE_FUNCTIONNAME_METHODDEF
</pre></div>
</div>
<p>(You can find the real name for this macro inside the generated code.
Or you can calculate it yourself: it's the name of your function as defined
on the first line of your block, but with periods changed to underscores,
uppercased, and <code class="docutils literal notranslate"><span class="pre">&quot;_METHODDEF&quot;</span></code> added to the end.)</p>
<p>Perhaps you're wondering: what if <code class="docutils literal notranslate"><span class="pre">HAVE_FUNCTIONNAME</span></code> isn't defined?
The <code class="docutils literal notranslate"><span class="pre">MODULE_FUNCTIONNAME_METHODDEF</span></code> macro won't be defined either!</p>
<p>Here's where Argument Clinic gets very clever.  It actually detects that the
Argument Clinic block might be deactivated by the <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>.  When that
happens, it generates a little extra code that looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef MODULE_FUNCTIONNAME_METHODDEF</span>
    <span class="cp">#define MODULE_FUNCTIONNAME_METHODDEF</span>
<span class="cp">#endif </span><span class="cm">/* !defined(MODULE_FUNCTIONNAME_METHODDEF) */</span><span class="cp"></span>
</pre></div>
</div>
<p>That means the macro always works.  If the function is defined, this turns
into the correct structure, including the trailing comma.  If the function is
undefined, this turns into nothing.</p>
<p>However, this causes one ticklish problem: where should Argument Clinic put this
extra code when using the &quot;block&quot; output preset?  It can't go in the output block,
because that could be deactivated by the <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>.  (That's the whole point!)</p>
<p>In this situation, Argument Clinic writes the extra code to the &quot;buffer&quot; destination.
This may mean that you get a complaint from Argument Clinic:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Warning in file &quot;Modules/posixmodule.c&quot; on line 12357:
Destination buffer &#39;buffer&#39; not empty at end of file, emptying.
</pre></div>
</div>
<p>When this happens, just open your file, find the <code class="docutils literal notranslate"><span class="pre">dump</span> <span class="pre">buffer</span></code> block that
Argument Clinic added to your file (it'll be at the very bottom), then
move it above the <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> structure where that macro is used.</p>
</div>
<div class="section" id="using-argument-clinic-in-python-files">
<h3>Using Argument Clinic in Python files<a class="headerlink" href="#using-argument-clinic-in-python-files" title="제목 주소">¶</a></h3>
<p>It's actually possible to use Argument Clinic to preprocess Python files.
There's no point to using Argument Clinic blocks, of course, as the output
wouldn't make any sense to the Python interpreter.  But using Argument Clinic
to run Python blocks lets you use Python as a Python preprocessor!</p>
<p>Since Python comments are different from C comments, Argument Clinic
blocks embedded in Python files look slightly different.  They look like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#/*[python input]</span>
<span class="c1">#print(&quot;def foo(): pass&quot;)</span>
<span class="c1">#[python start generated code]*/</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span> <span class="k">pass</span>
<span class="c1">#/*[python checksum:...]*/</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">인자 클리닉 How-To</a><ul>
<li><a class="reference internal" href="#the-goals-of-argument-clinic">인자 클리닉의 목표</a></li>
<li><a class="reference internal" href="#basic-concepts-and-usage">기본 개념과 사용법</a></li>
<li><a class="reference internal" href="#converting-your-first-function">첫 번째 함수 변환하기</a></li>
<li><a class="reference internal" href="#advanced-topics">고급 주제</a><ul>
<li><a class="reference internal" href="#symbolic-default-values">기호 기본값</a></li>
<li><a class="reference internal" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic">인자 클리닉에서 생성한 C 함수와 변수 이름 변경하기</a></li>
<li><a class="reference internal" href="#converting-functions-using-pyarg-unpacktuple">PyArg_UnpackTuple을 사용하여 함수 변환하기</a></li>
<li><a class="reference internal" href="#optional-groups">선택적 그룹</a></li>
<li><a class="reference internal" href="#using-real-argument-clinic-converters-instead-of-legacy-converters">Using real Argument Clinic converters, instead of &quot;legacy converters&quot;</a></li>
<li><a class="reference internal" href="#py-buffer">Py_buffer</a></li>
<li><a class="reference internal" href="#advanced-converters">Advanced converters</a></li>
<li><a class="reference internal" href="#parameter-default-values">Parameter default values</a></li>
<li><a class="reference internal" href="#the-null-default-value">The <code class="docutils literal notranslate"><span class="pre">NULL</span></code> default value</a></li>
<li><a class="reference internal" href="#expressions-specified-as-default-values">Expressions specified as default values</a></li>
<li><a class="reference internal" href="#using-a-return-converter">Using a return converter</a></li>
<li><a class="reference internal" href="#cloning-existing-functions">Cloning existing functions</a></li>
<li><a class="reference internal" href="#calling-python-code">Calling Python code</a></li>
<li><a class="reference internal" href="#using-a-self-converter">Using a &quot;self converter&quot;</a></li>
<li><a class="reference internal" href="#writing-a-custom-converter">Writing a custom converter</a></li>
<li><a class="reference internal" href="#writing-a-custom-return-converter">Writing a custom return converter</a></li>
<li><a class="reference internal" href="#meth-o-and-meth-noargs">METH_O and METH_NOARGS</a></li>
<li><a class="reference internal" href="#tp-new-and-tp-init-functions">tp_new and tp_init functions</a></li>
<li><a class="reference internal" href="#changing-and-redirecting-clinic-s-output">Changing and redirecting Clinic's output</a></li>
<li><a class="reference internal" href="#the-ifdef-trick">The #ifdef trick</a></li>
<li><a class="reference internal" href="#using-argument-clinic-in-python-files">Using Argument Clinic in Python files</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="ipaddress.html"
                        title="이전 장">ipaddress 모듈에 대한 소개</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="instrumentation.html"
                        title="다음 장">DTrace와 SystemTap으로 CPython 계측하기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="instrumentation.html" title="DTrace와 SystemTap으로 CPython 계측하기"
             >다음</a> |</li>
        <li class="right" >
          <a href="ipaddress.html" title="ipaddress 모듈에 대한 소개"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>