
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>소켓 프로그래밍 HOWTO &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Sorting HOW TO" href="sorting.html" />
    <link rel="prev" title="Regular Expression HOWTO" href="regex.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/howto/sockets.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="Sorting HOW TO"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="regex.html" title="Regular Expression HOWTO"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="socket-programming-howto">
<span id="socket-howto"></span><h1>소켓 프로그래밍 HOWTO<a class="headerlink" href="#socket-programming-howto" title="제목 주소">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">저자:</th><td class="field-body">Gordon McMillan</td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">개요</p>
<p>소켓은 거의 모든 곳에서 사용되지만, 가장 심하게 오해 된 기술 중 하나입니다. 이것은 10,000 피트 상공에서 본 소켓 개요입니다. 진짜 자습서는 아닙니다 - 여러분은 여전히 작동하도록하기위해 일을 해야할 것입니다. 세부 사항을 다루지는 않습니다만 (그것 것들이 많이 있습니다), 그것들을 적당히 사용하기에 충분한 배경을 줄 수 있기를 바랍니다.</p>
</div>
<div class="section" id="sockets">
<h2>소켓<a class="headerlink" href="#sockets" title="제목 주소">¶</a></h2>
<p>INET (즉, IPv4) 소켓에 대해서만 이야기 할 것이지만, 사용중인 소켓의 99% 이상을 차지합니다. 또한 STREAM (즉, TCP) 소켓에 대해서만 이야기 할 것입니다 - 여러분이 무엇을 하고 있는지 정말로 알고있지 (그럴 때 이 HOWTO는 필요없습니다!) 않다면, 다른 모든 것보다 STREAM 소켓으로 더 나은 동작과 성능을 얻을 수 있습니다. 소켓이 무엇인지에 대한 수수께끼뿐만 아니라 블로킹과 비 블로킹 소켓으로 작업하는 방법에 대한 힌트를 분명하게 하려고합니다. 하지만 블로킹 소켓에 대해 이야기하는 것으로 시작할 것입니다. 비 블로킹 소켓을 다루기 전에 이 것이 어떻게 작동하는지 알아야합니다.</p>
<p>이러한 것들을 이해하는데 어려움을 주는 한 부분은 문맥에 따라 &quot;소켓&quot;이 여러 가지 미묘하게 다른 것을 뜻할 수 있다는 것입니다. 그래서 먼저, 대화의 끝점 인 &quot;클라이언트&quot; 소켓과, 배전반 운영자와 같은 &quot;서버&quot; 소켓을 구별해 보겠습니다. 클라이언트 응용 프로그램(예를 들어, 여러분의 브라우저)은 &quot;클라이언트&quot; 소켓만 사용합니다; 이 것이 대화하는 웹 서버는 &quot;서버&quot; 소켓과 &quot;클라이언트&quot; 소켓을 모두 사용합니다.</p>
<div class="section" id="history">
<h3>역사<a class="headerlink" href="#history" title="제목 주소">¶</a></h3>
<p><abbr title="Inter Process Communication, 프로세스 간 통신">IPC</abbr>의 다양한 형태 중에서, 소켓이 가장 많이 사용됩니다. 특정 플랫폼에서 다른 형태의 IPC가 더 빠를 가능성이 있지만, 크로스 플랫폼 통신의 경우 소켓이 유일한 게임의 법칙입니다.</p>
<p>BSD 계열 유닉스의 일부로 버클리에서 발명되었습니다. 인터넷과함께 산불처럼 퍼졌습니다. 좋은 의미에서 --- INET과 소켓의 조합은 전 세계의 임의의 기계와 믿을 수 없을만큼 쉽게 대화를 나눌 수 있도록합니다 (적어도 다른 체계와 비교할 때).</p>
</div>
</div>
<div class="section" id="creating-a-socket">
<h2>소켓 만들기<a class="headerlink" href="#creating-a-socket" title="제목 주소">¶</a></h2>
<p>대충 말하면, 이 페이지로 연결되는 링크를 클릭하면 브라우저가 다음과 같은 작업을 수행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># INET, STREAMing 소켓을 만듭니다</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># 이제 포트 80의 웹 서버에 연결합니다 - 일반적인 http 포트</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">connect</span></code>가 완료되면, 소켓 <code class="docutils literal notranslate"><span class="pre">s</span></code>를 사용하여 페이지의 텍스트 요청을 보낼 수 있습니다. 같은 소켓으로 응답을 읽은 다음 파괴됩니다. 그렇습니다, 파괴됩니다. 클라이언트 소켓은 일반적으로 하나의 교환(또는 일련의 작은 교환 집합)에서만 사용됩니다.</p>
<p>웹 서버에서 일어나는 일은 좀 더 복잡합니다. 첫째, 웹 서버는 &quot;서버 소켓&quot;을 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># INET, STREAMing 소켓을 만듭니다</span>
<span class="n">serversocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># bind the socket to a public host, and a well-known port</span>
<span class="c1"># 소켓을 공개 호스트와 잘 알려진 포트에 바인드 합니다</span>
<span class="n">serversocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span> <span class="mi">80</span><span class="p">))</span>
<span class="c1"># become a server socket</span>
<span class="c1"># 서버 소켓이 됩니다</span>
<span class="n">serversocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>알아 두어야 할 몇 가지 사항: 소켓을 외부 세계에서 볼 수 있도록 <code class="docutils literal notranslate"><span class="pre">socket.gethostname()</span></code>를 사용했습니다. <code class="docutils literal notranslate"><span class="pre">s.bind(('localhost',</span> <span class="pre">80))</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">s.bind(('127.0.0.1',</span> <span class="pre">80))</span></code>을 사용했다면, 여전히 &quot;서버&quot; 소켓을 가지게 되지만 같은 기계 내에서만 볼 수있는 소켓을 갖게됩니다. <code class="docutils literal notranslate"><span class="pre">s.bind(('',</span> <span class="pre">80))</span></code>은 시스템에 있는 모든 주소로 소켓에 연결할 수 있음을 나타냅니다.</p>
<p>두 번째로 주목해야 할 점: 낮은 번호의 포트는 일반적으로 &quot;잘 알려진&quot; 서비스(HTTP, SNMP 등)를 위해 예약되어 있습니다. 연습 중이라면 적당히 높은 번호(4 자리수)를 사용하십시오.</p>
<p>마지막으로, <code class="docutils literal notranslate"><span class="pre">listen</span></code>에 대한 인자는 외부 연결을 거부하기 전에 최대 5 개의 연결 요청을 큐에 넣기를 원한다는 것을 소켓 라이브러리에 알립니다. 코드의 나머지 부분이 제대로 작성 되었다면, 이 것으로 충분합니다.</p>
<p>이제 우리는 포트 80에서 대기하는 &quot;서버&quot; 소켓을 가지고 있고, 웹 서버의 메인루프를 입력 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># 외부로부터의 연결을 받아들입니다</span>
    <span class="p">(</span><span class="n">clientsocket</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">=</span> <span class="n">serversocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="c1"># 이제 clientsocket으로 뭔가 합니다</span>
    <span class="c1"># 이 경우, 스레딩 서버인 것처럼 취급합니다</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">client_thread</span><span class="p">(</span><span class="n">clientsocket</span><span class="p">)</span>
    <span class="n">ct</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>실제로 이 루프가 작동 할 수있는 3 가지 일반적인 방법이 있습니다 - <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>를 처리하기 위해 스레드로 보내거나, <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>를 처리 할 새 프로세스를 만들거나, 비 블로킹 소켓을 사용하도록이 응용 프로그램을 재구성하고, <code class="docutils literal notranslate"><span class="pre">select</span></code>를 사용하여 &quot;서버&quot; 소켓과 활성 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>들 간에 다중화(multiplexing)합니다. 나중에 자세히 다룹니다. 지금 이해해야 할 중요한 점: 이것이 &quot;서버&quot; 소켓이하는 <em>전부</em>입니다. 어떤 데이터도 보내지 않습니다. 어떤 데이터도 수신하지 않습니다. 단지 &quot;클라이언트&quot; 소켓을 생성할 뿐입니다. 각 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>은 우리가 바인드한 호스트와 포트로 <code class="docutils literal notranslate"><span class="pre">connect()</span></code>를 수행하는 <em>다른</em> &quot;클라이언트&quot; 소켓에 대한 응답으로 만들어집니다. <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>를 만들자마자, 더 많은 연결을 기다리는 것으로 돌아갑니다. 두 개의 &quot;클라이언트&quot; 는 자유롭게 대화를 나눌 수 있습니다 - 그들은 대화를 끝낼 때 재활용되는 어떤 동적으로 할당된 포트를 사용합니다.</p>
<div class="section" id="ipc">
<h3>IPC<a class="headerlink" href="#ipc" title="제목 주소">¶</a></h3>
<p>한 기계의 두 프로세스간에 빠른 IPC가 필요하다면, 파이프나 공유 메모리를 살펴야합니다. AF_INET 소켓을 사용하기로 결정했다면, &quot;서버&quot; 소켓을 <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>에 바인드하십시오. 대부분 플랫폼에서, 이것은 네트워크 코드의 두어 개의 계층을 건너뛰는 지름길을 취할 것이고, 꽤 빨라집니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>은 교차 플랫폼 IPC를 고수준 API로 통합합니다.</p>
</div>
</div>
</div>
<div class="section" id="using-a-socket">
<h2>소켓 사용하기<a class="headerlink" href="#using-a-socket" title="제목 주소">¶</a></h2>
<p>첫 번째로 주목해야 할 점은 웹 브라우저의 &quot;클라이언트&quot; 소켓과 웹 서버의 &quot;클라이언트&quot; 소켓은 같은 녀석이라는 것입니다. 즉, 이것은 &quot;피어 투 피어(peer to peer)&quot; 대화입니다. 또는 다른 방식으로 표현하면, <em>설계자로서, 대화를 위한 에티켓의 규칙이 무엇인지 결정해야합니다</em>. 일반적으로, <code class="docutils literal notranslate"><span class="pre">connect</span></code>하는 소켓이 요청이나 로그인을 보내 대화를 시작합니다. 그러나 이것은 설계상의 결정입니다 - 소켓의 규칙이 아닙니다.</p>
<p>이제 통신에 사용할 두 벌의 동사가 있습니다. <code class="docutils literal notranslate"><span class="pre">send</span></code>와 <code class="docutils literal notranslate"><span class="pre">recv</span></code>를 사용하거나, 클라이언트 소켓을 파일류로 변환한 후 <code class="docutils literal notranslate"><span class="pre">read</span></code>와 <code class="docutils literal notranslate"><span class="pre">write</span></code>를 사용할 수 있습니다. 후자는 자바가 소켓을 제공하는 방식입니다. <code class="docutils literal notranslate"><span class="pre">flush</span></code>를 소켓에 사용해야한다고 경고하는 것 외에는, 여기에 대해서는 언급하지 않을 것입니다. 이것들은 버퍼된 &quot;파일&quot;이며, 일반적인 실수는 어떤 것을 <code class="docutils literal notranslate"><span class="pre">write</span></code>하고는 응답을 <code class="docutils literal notranslate"><span class="pre">read</span></code>하는 것입니다. <code class="docutils literal notranslate"><span class="pre">flush</span></code>가 없으면, 요청이 여전히 출력 버퍼에 남아있을 수 있으므로 응답을 영원히 기다리게될 수 있습니다.</p>
<p>이제 소켓의 주요 걸림돌에 도달했습니다 - <code class="docutils literal notranslate"><span class="pre">send</span></code>와 <code class="docutils literal notranslate"><span class="pre">recv</span></code>는 네트워크 버퍼에서 작동합니다. 이 것들은 여러분이 건내준 모든 바이트를 처리하지 않을 수 있습니다, 그들의 주 관심사는 네트워크 버퍼를 처리하는 것이기 때문입니다. 일반적으로, 연관된 네트워크 버퍼가 채워 지거나(<code class="docutils literal notranslate"><span class="pre">send</span></code>) 비워지면(<code class="docutils literal notranslate"><span class="pre">recv</span></code>) 반환됩니다. 그런 다음 처리 한 바이트 수를 알려줍니다. 메시지가 완전히 처리 될 때까지 다시 호출하는 것은 <em>여러분</em>의 책임입니다.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">recv</span></code> returns 0 bytes, it means the other side has closed (or is in
the process of closing) the connection.  You will not receive any more data on
this connection. Ever.  You may be able to send data successfully; I'll talk
more about this later.</p>
<p>A protocol like HTTP uses a socket for only one transfer. The client sends a
request, then reads a reply.  That's it. The socket is discarded. This means that
a client can detect the end of the reply by receiving 0 bytes.</p>
<p>But if you plan to reuse your socket for further transfers, you need to realize
that <em>there is no</em> <abbr title="End of Transfer">EOT</abbr> <em>on a socket.</em> I repeat: if a socket
<code class="docutils literal notranslate"><span class="pre">send</span></code> or <code class="docutils literal notranslate"><span class="pre">recv</span></code> returns after handling 0 bytes, the connection has been
broken.  If the connection has <em>not</em> been broken, you may wait on a <code class="docutils literal notranslate"><span class="pre">recv</span></code>
forever, because the socket will <em>not</em> tell you that there's nothing more to
read (for now).  Now if you think about that a bit, you'll come to realize a
fundamental truth of sockets: <em>messages must either be fixed length</em> (yuck), <em>or
be delimited</em> (shrug), <em>or indicate how long they are</em> (much better), <em>or end by
shutting down the connection</em>. The choice is entirely yours, (but some ways are
righter than others).</p>
<p>Assuming you don't want to end the connection, the simplest solution is a fixed
length message:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySocket</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;demonstration class only</span>
<span class="sd">      - coded for clarity, not efficiency</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
                            <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">mysend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="n">totalsent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">totalsent</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>
            <span class="n">sent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">totalsent</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;socket connection broken&quot;</span><span class="p">)</span>
            <span class="n">totalsent</span> <span class="o">=</span> <span class="n">totalsent</span> <span class="o">+</span> <span class="n">sent</span>

    <span class="k">def</span> <span class="nf">myreceive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bytes_recd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">bytes_recd</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">MSGLEN</span> <span class="o">-</span> <span class="n">bytes_recd</span><span class="p">,</span> <span class="mi">2048</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;socket connection broken&quot;</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">bytes_recd</span> <span class="o">=</span> <span class="n">bytes_recd</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
</pre></div>
</div>
<p>The sending code here is usable for almost any messaging scheme - in Python you
send strings, and you can use <code class="docutils literal notranslate"><span class="pre">len()</span></code> to determine its length (even if it has
embedded <code class="docutils literal notranslate"><span class="pre">\0</span></code> characters). It's mostly the receiving code that gets more
complex. (And in C, it's not much worse, except you can't use <code class="docutils literal notranslate"><span class="pre">strlen</span></code> if the
message has embedded <code class="docutils literal notranslate"><span class="pre">\0</span></code>s.)</p>
<p>The easiest enhancement is to make the first character of the message an
indicator of message type, and have the type determine the length. Now you have
two <code class="docutils literal notranslate"><span class="pre">recv</span></code>s - the first to get (at least) that first character so you can
look up the length, and the second in a loop to get the rest. If you decide to
go the delimited route, you'll be receiving in some arbitrary chunk size, (4096
or 8192 is frequently a good match for network buffer sizes), and scanning what
you've received for a delimiter.</p>
<p>One complication to be aware of: if your conversational protocol allows multiple
messages to be sent back to back (without some kind of reply), and you pass
<code class="docutils literal notranslate"><span class="pre">recv</span></code> an arbitrary chunk size, you may end up reading the start of a
following message. You'll need to put that aside and hold onto it, until it's
needed.</p>
<p>Prefixing the message with its length (say, as 5 numeric characters) gets more
complex, because (believe it or not), you may not get all 5 characters in one
<code class="docutils literal notranslate"><span class="pre">recv</span></code>. In playing around, you'll get away with it; but in high network loads,
your code will very quickly break unless you use two <code class="docutils literal notranslate"><span class="pre">recv</span></code> loops - the first
to determine the length, the second to get the data part of the message. Nasty.
This is also when you'll discover that <code class="docutils literal notranslate"><span class="pre">send</span></code> does not always manage to get
rid of everything in one pass. And despite having read this, you will eventually
get bit by it!</p>
<p>In the interests of space, building your character, (and preserving my
competitive position), these enhancements are left as an exercise for the
reader. Lets move on to cleaning up.</p>
<div class="section" id="binary-data">
<h3>Binary Data<a class="headerlink" href="#binary-data" title="제목 주소">¶</a></h3>
<p>It is perfectly possible to send binary data over a socket. The major problem is
that not all machines use the same formats for binary data. For example, a
Motorola chip will represent a 16 bit integer with the value 1 as the two hex
bytes 00 01. Intel and DEC, however, are byte-reversed - that same 1 is 01 00.
Socket libraries have calls for converting 16 and 32 bit integers - <code class="docutils literal notranslate"><span class="pre">ntohl,</span>
<span class="pre">htonl,</span> <span class="pre">ntohs,</span> <span class="pre">htons</span></code> where &quot;n&quot; means <em>network</em> and &quot;h&quot; means <em>host</em>, &quot;s&quot; means
<em>short</em> and &quot;l&quot; means <em>long</em>. Where network order is host order, these do
nothing, but where the machine is byte-reversed, these swap the bytes around
appropriately.</p>
<p>In these days of 32 bit machines, the ascii representation of binary data is
frequently smaller than the binary representation. That's because a surprising
amount of the time, all those longs have the value 0, or maybe 1. The string &quot;0&quot;
would be two bytes, while binary is four. Of course, this doesn't fit well with
fixed-length messages. Decisions, decisions.</p>
</div>
</div>
<div class="section" id="disconnecting">
<h2>Disconnecting<a class="headerlink" href="#disconnecting" title="제목 주소">¶</a></h2>
<p>Strictly speaking, you're supposed to use <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> on a socket before you
<code class="docutils literal notranslate"><span class="pre">close</span></code> it.  The <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> is an advisory to the socket at the other end.
Depending on the argument you pass it, it can mean &quot;I'm not going to send
anymore, but I'll still listen&quot;, or &quot;I'm not listening, good riddance!&quot;.  Most
socket libraries, however, are so used to programmers neglecting to use this
piece of etiquette that normally a <code class="docutils literal notranslate"><span class="pre">close</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">shutdown();</span>
<span class="pre">close()</span></code>.  So in most situations, an explicit <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> is not needed.</p>
<p>One way to use <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> effectively is in an HTTP-like exchange. The client
sends a request and then does a <code class="docutils literal notranslate"><span class="pre">shutdown(1)</span></code>. This tells the server &quot;This
client is done sending, but can still receive.&quot;  The server can detect &quot;EOF&quot; by
a receive of 0 bytes. It can assume it has the complete request.  The server
sends a reply. If the <code class="docutils literal notranslate"><span class="pre">send</span></code> completes successfully then, indeed, the client
was still receiving.</p>
<p>Python takes the automatic shutdown a step further, and says that when a socket
is garbage collected, it will automatically do a <code class="docutils literal notranslate"><span class="pre">close</span></code> if it's needed. But
relying on this is a very bad habit. If your socket just disappears without
doing a <code class="docutils literal notranslate"><span class="pre">close</span></code>, the socket at the other end may hang indefinitely, thinking
you're just being slow. <em>Please</em> <code class="docutils literal notranslate"><span class="pre">close</span></code> your sockets when you're done.</p>
<div class="section" id="when-sockets-die">
<h3>When Sockets Die<a class="headerlink" href="#when-sockets-die" title="제목 주소">¶</a></h3>
<p>Probably the worst thing about using blocking sockets is what happens when the
other side comes down hard (without doing a <code class="docutils literal notranslate"><span class="pre">close</span></code>). Your socket is likely to
hang. TCP is a reliable protocol, and it will wait a long, long time
before giving up on a connection. If you're using threads, the entire thread is
essentially dead. There's not much you can do about it. As long as you aren't
doing something dumb, like holding a lock while doing a blocking read, the
thread isn't really consuming much in the way of resources. Do <em>not</em> try to kill
the thread - part of the reason that threads are more efficient than processes
is that they avoid the overhead associated with the automatic recycling of
resources. In other words, if you do manage to kill the thread, your whole
process is likely to be screwed up.</p>
</div>
</div>
<div class="section" id="non-blocking-sockets">
<h2>Non-blocking Sockets<a class="headerlink" href="#non-blocking-sockets" title="제목 주소">¶</a></h2>
<p>If you've understood the preceding, you already know most of what you need to
know about the mechanics of using sockets. You'll still use the same calls, in
much the same ways. It's just that, if you do it right, your app will be almost
inside-out.</p>
<p>In Python, you use <code class="docutils literal notranslate"><span class="pre">socket.setblocking(0)</span></code> to make it non-blocking. In C, it's
more complex, (for one thing, you'll need to choose between the BSD flavor
<code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code> and the almost indistinguishable Posix flavor <code class="docutils literal notranslate"><span class="pre">O_NDELAY</span></code>, which
is completely different from <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>), but it's the exact same idea. You
do this after creating the socket, but before using it. (Actually, if you're
nuts, you can switch back and forth.)</p>
<p>The major mechanical difference is that <code class="docutils literal notranslate"><span class="pre">send</span></code>, <code class="docutils literal notranslate"><span class="pre">recv</span></code>, <code class="docutils literal notranslate"><span class="pre">connect</span></code> and
<code class="docutils literal notranslate"><span class="pre">accept</span></code> can return without having done anything. You have (of course) a
number of choices. You can check return code and error codes and generally drive
yourself crazy. If you don't believe me, try it sometime. Your app will grow
large, buggy and suck CPU. So let's skip the brain-dead solutions and do it
right.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">select</span></code>.</p>
<p>In C, coding <code class="docutils literal notranslate"><span class="pre">select</span></code> is fairly complex. In Python, it's a piece of cake, but
it's close enough to the C version that if you understand <code class="docutils literal notranslate"><span class="pre">select</span></code> in Python,
you'll have little trouble with it in C:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ready_to_read</span><span class="p">,</span> <span class="n">ready_to_write</span><span class="p">,</span> <span class="n">in_error</span> <span class="o">=</span> \
               <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                  <span class="n">potential_readers</span><span class="p">,</span>
                  <span class="n">potential_writers</span><span class="p">,</span>
                  <span class="n">potential_errs</span><span class="p">,</span>
                  <span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<p>You pass <code class="docutils literal notranslate"><span class="pre">select</span></code> three lists: the first contains all sockets that you might
want to try reading; the second all the sockets you might want to try writing
to, and the last (normally left empty) those that you want to check for errors.
You should note that a socket can go into more than one list. The <code class="docutils literal notranslate"><span class="pre">select</span></code>
call is blocking, but you can give it a timeout. This is generally a sensible
thing to do - give it a nice long timeout (say a minute) unless you have good
reason to do otherwise.</p>
<p>In return, you will get three lists. They contain the sockets that are actually
readable, writable and in error. Each of these lists is a subset (possibly
empty) of the corresponding list you passed in.</p>
<p>If a socket is in the output readable list, you can be
as-close-to-certain-as-we-ever-get-in-this-business that a <code class="docutils literal notranslate"><span class="pre">recv</span></code> on that
socket will return <em>something</em>. Same idea for the writable list. You'll be able
to send <em>something</em>. Maybe not all you want to, but <em>something</em> is better than
nothing.  (Actually, any reasonably healthy socket will return as writable - it
just means outbound network buffer space is available.)</p>
<p>If you have a &quot;server&quot; socket, put it in the potential_readers list. If it comes
out in the readable list, your <code class="docutils literal notranslate"><span class="pre">accept</span></code> will (almost certainly) work. If you
have created a new socket to <code class="docutils literal notranslate"><span class="pre">connect</span></code> to someone else, put it in the
potential_writers list. If it shows up in the writable list, you have a decent
chance that it has connected.</p>
<p>Actually, <code class="docutils literal notranslate"><span class="pre">select</span></code> can be handy even with blocking sockets. It's one way of
determining whether you will block - the socket returns as readable when there's
something in the buffers.  However, this still doesn't help with the problem of
determining whether the other end is done, or just busy with something else.</p>
<p><strong>Portability alert</strong>: On Unix, <code class="docutils literal notranslate"><span class="pre">select</span></code> works both with the sockets and
files. Don't try this on Windows. On Windows, <code class="docutils literal notranslate"><span class="pre">select</span></code> works with sockets
only. Also note that in C, many of the more advanced socket options are done
differently on Windows. In fact, on Windows I usually use threads (which work
very, very well) with my sockets.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">소켓 프로그래밍 HOWTO</a><ul>
<li><a class="reference internal" href="#sockets">소켓</a><ul>
<li><a class="reference internal" href="#history">역사</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-a-socket">소켓 만들기</a><ul>
<li><a class="reference internal" href="#ipc">IPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-socket">소켓 사용하기</a><ul>
<li><a class="reference internal" href="#binary-data">Binary Data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#disconnecting">Disconnecting</a><ul>
<li><a class="reference internal" href="#when-sockets-die">When Sockets Die</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-blocking-sockets">Non-blocking Sockets</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="regex.html"
                        title="이전 장">Regular Expression HOWTO</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="sorting.html"
                        title="다음 장">Sorting HOW TO</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="Sorting HOW TO"
             >다음</a> |</li>
        <li class="right" >
          <a href="regex.html" title="Regular Expression HOWTO"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>