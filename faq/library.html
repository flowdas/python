
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>라이브러리와 확장 FAQ &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="확장/내장 FAQ" href="extending.html" />
    <link rel="prev" title="설계와 역사 FAQ" href="design.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/faq/library.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="extending.html" title="확장/내장 FAQ"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="design.html" title="설계와 역사 FAQ"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 자주 나오는 질문들</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="library-and-extension-faq">
<h1><a class="toc-backref" href="#id1">라이브러리와 확장 FAQ</a><a class="headerlink" href="#library-and-extension-faq" title="제목 주소">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">목차</p>
<ul class="simple">
<li><p><a class="reference internal" href="#library-and-extension-faq" id="id1">라이브러리와 확장 FAQ</a></p>
<ul>
<li><p><a class="reference internal" href="#general-library-questions" id="id2">일반 라이브러리 관련 질문</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-find-a-module-or-application-to-perform-task-x" id="id3">작업 X를 수행할 모듈이나 응용 프로그램을 어떻게 찾습니까?</a></p></li>
<li><p><a class="reference internal" href="#where-is-the-math-py-socket-py-regex-py-etc-source-file" id="id4">math.py (socket.py, regex.py 등) 소스 파일은 어디에 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-make-a-python-script-executable-on-unix" id="id5">유닉스에서 파이썬 스크립트를 실행 파일로 만들려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#is-there-a-curses-termcap-package-for-python" id="id6">파이썬 용 curses/termcap 패키지가 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#is-there-an-equivalent-to-c-s-onexit-in-python" id="id7">파이썬에 C의 onexit()와 동등한 것이 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#why-don-t-my-signal-handlers-work" id="id8">시그널 처리기가 작동하지 않는 이유는 무엇입니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#common-tasks" id="id9">일반적인 작업</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-test-a-python-program-or-component" id="id10">파이썬 프로그램이나 컴포넌트를 어떻게 테스트합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-create-documentation-from-doc-strings" id="id11">독스트링으로 설명서를 어떻게 만듭니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-get-a-single-keypress-at-a-time" id="id12">한 번에 하나의 키 입력을 받는 방법은 무엇입니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#threads" id="id13">스레드</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-program-using-threads" id="id14">스레드를 사용하여 어떻게 프로그래밍합니까?</a></p></li>
<li><p><a class="reference internal" href="#none-of-my-threads-seem-to-run-why" id="id15">제 스레드가 아무것도 실행되지 않는 것 같습니다: 왜 그런가요?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-parcel-out-work-among-a-bunch-of-worker-threads" id="id16">여러 작업자 스레드 간에 작업을 어떻게 배달합니까?</a></p></li>
<li><p><a class="reference internal" href="#what-kinds-of-global-value-mutation-are-thread-safe" id="id17">어떤 종류의 전역 값 변경이 스레드 안전합니까?</a></p></li>
<li><p><a class="reference internal" href="#can-t-we-get-rid-of-the-global-interpreter-lock" id="id18">전역 인터프리터 록을 제거할 수 없습니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#input-and-output" id="id19">입력과 출력</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-delete-a-file-and-other-file-questions" id="id20">파일을 어떻게 삭제합니까? (그리고 다른 파일 질문들...)</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-copy-a-file" id="id21">파일을 어떻게 복사합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-read-or-write-binary-data" id="id22">바이너리 데이터를 읽는 (또는 쓰는) 방법은 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why" id="id23">os.popen()으로 만든 파이프에서 os.read()를 사용할 수 없는 것처럼 보입니다; 왜입니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-access-the-serial-rs232-port" id="id24">직렬 (RS232) 포트에 어떻게 액세스합니까?</a></p></li>
<li><p><a class="reference internal" href="#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it" id="id25">왜 sys.stdout(stdin, stderr)을 닫아도 닫히지 않습니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#network-internet-programming" id="id26">네트워크/인터넷 프로그래밍</a></p>
<ul>
<li><p><a class="reference internal" href="#what-www-tools-are-there-for-python" id="id27">파이썬에는 어떤 WWW 도구가 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-mimic-cgi-form-submission-method-post" id="id28">CGI 폼 제출을 어떻게 흉내 낼 수 있습니까 (METHOD=POST)?</a></p></li>
<li><p><a class="reference internal" href="#what-module-should-i-use-to-help-with-generating-html" id="id29">HTML 생성을 위해 어떤 모듈을 사용해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-send-mail-from-a-python-script" id="id30">파이썬 스크립트에서 메일을 보내려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-avoid-blocking-in-the-connect-method-of-a-socket" id="id31">소켓의 connect() 메서드에서 블로킹을 피하려면 어떻게 해야 합니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#databases" id="id32">데이터베이스</a></p>
<ul>
<li><p><a class="reference internal" href="#are-there-any-interfaces-to-database-packages-in-python" id="id33">파이썬에 데이터베이스 패키지에 대한 인터페이스가 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-implement-persistent-objects-in-python" id="id34">파이썬에서 영속 객체를 어떻게 구현합니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mathematics-and-numerics" id="id35">수학과 숫자</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-generate-random-numbers-in-python" id="id36">파이썬에서 난수를 어떻게 생성합니까?</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-library-questions">
<h2><a class="toc-backref" href="#id2">일반 라이브러리 관련 질문</a><a class="headerlink" href="#general-library-questions" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-find-a-module-or-application-to-perform-task-x">
<h3><a class="toc-backref" href="#id3">작업 X를 수행할 모듈이나 응용 프로그램을 어떻게 찾습니까?</a><a class="headerlink" href="#how-do-i-find-a-module-or-application-to-perform-task-x" title="제목 주소">¶</a></h3>
<p>관련 표준 라이브러리 모듈이 있는지 <a class="reference internal" href="../library/index.html#library-index"><span class="std std-ref">라이브러리 레퍼런스</span></a>를 확인하십시오. (결국에는 표준 라이브러리에 있는 내용을 배우고 이 단계를 건너뛸 수 있게 됩니다.)</p>
<p>제삼자 패키지의 경우 <a class="reference external" href="https://pypi.org">파이썬 패키지 색인</a>을 검색하거나 <a class="reference external" href="https://www.google.com">구글</a> 또는 다른 웹 검색 엔진을 사용해보십시오. &quot;Python&quot;에 관심 있는 주제에 관한 한두 개의 키워드를 더해 검색하면 보통 도움이 될만한 것을 찾게 될 것입니다.</p>
</div>
<div class="section" id="where-is-the-math-py-socket-py-regex-py-etc-source-file">
<h3><a class="toc-backref" href="#id4">math.py (socket.py, regex.py 등) 소스 파일은 어디에 있습니까?</a><a class="headerlink" href="#where-is-the-math-py-socket-py-regex-py-etc-source-file" title="제목 주소">¶</a></h3>
<p>모듈의 소스 파일을 찾을 수 없으면 C, C++ 또는 기타 컴파일된 언어로 구현된 내장이나 동적으로 로드된 모듈일 수 있습니다. 이 경우 소스 파일이 없거나 C 소스 디렉터리(파이썬 경로에 없는)의 <code class="file docutils literal notranslate"><span class="pre">mathmodule.c</span></code>와 같은 파일일 수 있습니다.</p>
<p>파이썬에는 (적어도) 세 가지 종류의 모듈이 있습니다:</p>
<ol class="arabic">
<li><p>파이썬으로 작성된 모듈 (.py);</p></li>
<li><p>C로 작성되고 동적으로 로드되는 모듈 (.dll, .pyd, .so, .sl 등);</p></li>
<li><p>C로 작성되고 인터프리터와 링크된 모듈; 이 목록을 얻으려면, 다음을 입력하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="how-do-i-make-a-python-script-executable-on-unix">
<h3><a class="toc-backref" href="#id5">유닉스에서 파이썬 스크립트를 실행 파일로 만들려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-do-i-make-a-python-script-executable-on-unix" title="제목 주소">¶</a></h3>
<p>두 가지를 해야 합니다: 스크립트 파일의 모드는 실행 가능해야 하고 첫 번째 줄은 <code class="docutils literal notranslate"><span class="pre">#!</span></code>로 시작하고 그 뒤에 파이썬 인터프리터 경로가 있어야 합니다.</p>
<p>첫 번째는 <code class="docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">scriptfile</span></code>이나 아마도 <code class="docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">755</span> <span class="pre">scriptfile</span></code>을 실행하여 수행됩니다.</p>
<p>두 번째는 여러 가지 방법으로 수행 할 수 있습니다. 가장 간단한 방법은 다음과 같은 줄을</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/local/bin/python</span>
</pre></div>
</div>
<p>파이썬 인터프리터가 플랫폼에 설치된 경로 이름을 사용하여 파일의 첫 번째 줄로 작성하는 것입니다.</p>
<p>스크립트가 파이썬 인터프리터가 있는 위치와 독립적으로 되도록 하려면, <strong class="program">env</strong> 프로그램을 사용할 수 있습니다. 파이썬 인터프리터가 사용자 <span class="target" id="index-4"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code>의 디렉터리에 있다고 가정하면, 거의 모든 유닉스 변형이 다음을 지원합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
</pre></div>
</div>
<p>이것을 CGI 스크립트에 적용하지 <em>마십시오</em>. CGI 스크립트의 <span class="target" id="index-5"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> 변수는 종종 최소한이라서, 인터프리터의 실제 절대 경로명을 사용해야 합니다.</p>
<p>때때로, 사용자 환경이 가득 차서 <strong class="program">/usr/bin/env</strong> 프로그램이 실패합니다; 또는 env 프로그램이 아예 없습니다. 이 경우, 다음과 같은 핵을 시도할 수 있습니다 (Alex Rezinsky의 기법입니다):</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="ch">#! /bin/sh</span>
<span class="s2">&quot;&quot;&quot;:&quot;</span>
<span class="nb">exec</span> python <span class="nv">$0</span> <span class="si">${</span><span class="nv">1</span><span class="p">+</span><span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="si">}</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>작은 단점은 이것이 스크립트의 __doc__ 문자열을 정의한다는 것입니다. 그러나, 다음을 추가하여 문제를 해결할 수 있습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;...Whatever...&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="is-there-a-curses-termcap-package-for-python">
<h3><a class="toc-backref" href="#id6">파이썬 용 curses/termcap 패키지가 있습니까?</a><a class="headerlink" href="#is-there-a-curses-termcap-package-for-python" title="제목 주소">¶</a></h3>
<p>유닉스 변형의 경우: 표준 파이썬 소스 배포판은 기본적으로 컴파일되지는 않지만, <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Modules">Modules</a> 서브 디렉터리에 curses 모듈을 포함합니다. (윈도우 배포판에서는 사용할 수 없습니다 -- 윈도우용 curses 모듈은 없습니다.)</p>
<p><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> 모듈은 기본 curses 기능뿐만 아니라 색상, 대체 문자 집합 지원, 패드 및 마우스 지원과 같은 ncurses와 SYSV curses의 많은 추가 기능을 지원합니다. 이는 모듈이 BSD curses만 있는 운영 체제와 호환되지 않음을 뜻하지만, 현재 유지 보수되는 OS들은 어느 것도 이 범주에 속하지 않는 것 같습니다.</p>
<p>윈도우의 경우: <a class="reference external" href="http://effbot.org/zone/console-index.htm">consolelib 모듈</a>을 사용하십시오.</p>
</div>
<div class="section" id="is-there-an-equivalent-to-c-s-onexit-in-python">
<h3><a class="toc-backref" href="#id7">파이썬에 C의 onexit()와 동등한 것이 있습니까?</a><a class="headerlink" href="#is-there-an-equivalent-to-c-s-onexit-in-python" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 모듈은 C의 <code class="xref c c-func docutils literal notranslate"><span class="pre">onexit()</span></code>와 유사한 등록 함수를 제공합니다.</p>
</div>
<div class="section" id="why-don-t-my-signal-handlers-work">
<h3><a class="toc-backref" href="#id8">시그널 처리기가 작동하지 않는 이유는 무엇입니까?</a><a class="headerlink" href="#why-don-t-my-signal-handlers-work" title="제목 주소">¶</a></h3>
<p>가장 흔한 문제점은 시그널 처리기가 잘못된 인자 목록으로 선언되는 것입니다. 이렇게 호출됩니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
<p>따라서 두 개의 매개 변수로 선언해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="common-tasks">
<h2><a class="toc-backref" href="#id9">일반적인 작업</a><a class="headerlink" href="#common-tasks" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-test-a-python-program-or-component">
<h3><a class="toc-backref" href="#id10">파이썬 프로그램이나 컴포넌트를 어떻게 테스트합니까?</a><a class="headerlink" href="#how-do-i-test-a-python-program-or-component" title="제목 주소">¶</a></h3>
<p>파이썬에는 두 가지 테스트 프레임워크가 있습니다. <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 모듈은 모듈의 독스트링에 있는 예제를 찾고 실행한 후, 출력을 독스트링에 제공된 예상 출력과 비교합니다.</p>
<p><a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 모듈은 Java와 Smalltalk 테스트 프레임 워크에서 모델링 된 더 멋진 테스트 프레임워크입니다.</p>
<p>테스트를 더 쉽게 하려면, 여러분의 프로그램에 좋은 모듈식 디자인을 사용해야 합니다. 프로그램은 거의 모든 기능을 함수나 클래스 메서드로 캡슐화해야 합니다 -- 그리고 이는 때로 프로그램을 더 빠르게 실행하는 놀라운 효과가 있습니다 (지역 변수 액세스가 전역 액세스보다 빠르기 때문에). 또한 프로그램은 전역 변수를 변경하는 것에 의존하지 않아야 합니다, 이렇게 하면 테스트하기가 훨씬 어렵기 때문입니다.</p>
<p>프로그램의 &quot;전역 메인 논리&quot;는 다음과 같은 코드를</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main_logic</span><span class="p">()</span>
</pre></div>
</div>
<p>프로그램의 메인 모듈 하단에 넣는 것처럼 간단할 수 있습니다.</p>
<p>일단 프로그램이 다루기 쉬운 함수와 클래스 동작의 모음으로 구성되면, 이 동작을 검사하는 테스트 함수를 작성해야 합니다. 일련의 테스트를 자동화하는 테스트 스위트는 각 모듈과 연관될 수 있습니다. 이것은 많은 작업처럼 들리지만, 파이썬이 아주 간결하고 유연하기 때문에 놀랍도록 쉽습니다. &quot;프로덕션 코드&quot;와 함께 테스트 함수를 작성하여 코딩을 훨씬 더 즐겁고 재미있게 만들 수 있습니다. 버그를 쉽게 찾고 결함을 조기에 발견할 수 있기 때문입니다.</p>
<p>프로그램의 메인 모듈이 아닌 &quot;지원 모듈&quot;에는 모듈의 자체 테스트가 포함될 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">self_test</span><span class="p">()</span>
</pre></div>
</div>
<p>복잡한 외부 인터페이스와 상호 작용하는 프로그램조차도 파이썬으로 구현된 &quot;가짜&quot; 인터페이스를 사용하여 외부 인터페이스를 사용할 수 없을 때 테스트할 수 있습니다.</p>
</div>
<div class="section" id="how-do-i-create-documentation-from-doc-strings">
<h3><a class="toc-backref" href="#id11">독스트링으로 설명서를 어떻게 만듭니까?</a><a class="headerlink" href="#how-do-i-create-documentation-from-doc-strings" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 모듈은 파이썬 소스 코드의 독스트링에서 HTML을 만들 수 있습니다. 순수하게 독스트링에서 API 설명서를 만드는 대안은 <a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a>입니다. <a class="reference external" href="http://sphinx-doc.org">Sphinx</a>도 독스트링 내용을 포함할 수 있습니다.</p>
</div>
<div class="section" id="how-do-i-get-a-single-keypress-at-a-time">
<h3><a class="toc-backref" href="#id12">한 번에 하나의 키 입력을 받는 방법은 무엇입니까?</a><a class="headerlink" href="#how-do-i-get-a-single-keypress-at-a-time" title="제목 주소">¶</a></h3>
<p>유닉스 변형에는 몇 가지 해결책이 있습니다. curses를 사용하여 이 작업을 수행하는 것은 간단하지만, curses는 배우기에 상당히 큰 모듈입니다.</p>
</div>
</div>
<div class="section" id="threads">
<h2><a class="toc-backref" href="#id13">스레드</a><a class="headerlink" href="#threads" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-program-using-threads">
<h3><a class="toc-backref" href="#id14">스레드를 사용하여 어떻게 프로그래밍합니까?</a><a class="headerlink" href="#how-do-i-program-using-threads" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code></a> 모듈이 아닌 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 모듈을 사용하십시오. <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 모듈은 <a class="reference internal" href="../library/_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code></a> 모듈이 제공하는 저수준 프리미티브 위에 편리한 추상화를 구축합니다.</p>
<p>Aahz가 자신의 threading 자습서에서 유용한 슬라이드 모음을 제공합니다; <a class="reference external" href="http://www.pythoncraft.com/OSCON2001/">http://www.pythoncraft.com/OSCON2001/</a> 을 참조하십시오.</p>
</div>
<div class="section" id="none-of-my-threads-seem-to-run-why">
<h3><a class="toc-backref" href="#id15">제 스레드가 아무것도 실행되지 않는 것 같습니다: 왜 그런가요?</a><a class="headerlink" href="#none-of-my-threads-seem-to-run-why" title="제목 주소">¶</a></h3>
<p>메인 스레드가 종료되자마자, 모든 스레드가 죽습니다. 메인 스레드가 너무 빨리 실행되어, 스레드가 작업을 수행할 시간이 없습니다.</p>
<p>간단한 수정은 프로그램 끝에 모든 스레드가 완료될 만큼 충분히 긴 휴면을 추가하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># &lt;---------------------------!</span>
</pre></div>
</div>
<p>그러나 이제 (많은 플랫폼에서) 스레드는 병렬로 실행되지 않고, 한 번에 하나씩 순차적으로 실행되는 것처럼 보입니다! 그 이유는 OS 스레드 스케줄러가 이전 스레드가 블록 될 때까지 새 스레드를 시작하지 않기 때문입니다.</p>
<p>간단한 수정은 실행 함수의 시작 부분에 작은 휴면을 추가하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>  <span class="c1"># &lt;--------------------!</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/time.html#time.sleep" title="time.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a>을 위한 좋은 지연 값을 추측하는 대신, 일종의 세마포어 메커니즘을 사용하는 것이 좋습니다. 한 가지 아이디어는 <a class="reference internal" href="../library/queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> 모듈을 사용하여 큐 객체를 만들고, 각 스레드가 완료될 때 큐에 토큰을 추가하게 하고, 메인 스레드가 스레드 수 만큼의 토큰을 읽도록 하는 것입니다.</p>
</div>
<div class="section" id="how-do-i-parcel-out-work-among-a-bunch-of-worker-threads">
<h3><a class="toc-backref" href="#id16">여러 작업자 스레드 간에 작업을 어떻게 배달합니까?</a><a class="headerlink" href="#how-do-i-parcel-out-work-among-a-bunch-of-worker-threads" title="제목 주소">¶</a></h3>
<p>가장 쉬운 방법은 <a class="reference internal" href="../library/concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> 모듈, 특히 <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> 클래스를 사용하는 것입니다.</p>
<p>또는, 디스패치 알고리즘을 세밀하게 제어하려면, 직접 논리를 작성할 수 있습니다. <a class="reference internal" href="../library/queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> 모듈을 사용하여 작업 목록을 포함하는 큐를 만드십시오. <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> 클래스는 객체 목록을 유지하고 큐에 항목을 추가하는 <code class="docutils literal notranslate"><span class="pre">.put(obj)</span></code> 메서드와 이를 반환하는 <code class="docutils literal notranslate"><span class="pre">.get()</span></code> 메서드를 갖습니다. 클래스는 각 작업이 정확히 한 번만 전달되도록 하는 데 필요한 록을 관리합니다.</p>
<p>간단한 예를 들면 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">queue</span><span class="o">,</span> <span class="nn">time</span>

<span class="c1"># 작업자 스레드는 큐에서 작업을 가져옵니다. 큐가 비어 있으면, 더는 작업이 없다고 가정하고 종료합니다.</span>
<span class="c1"># (실제 상황에서는 작업자가 종료할 때까지 실행합니다.)</span>
<span class="k">def</span> <span class="nf">worker</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running worker&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;queue empty&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;running with argument&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># 큐를 만듭니다</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="c1"># 5 작업자의 풀을 시작합니다</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;worker </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># 큐에 작업을 추가하기 시작합니다</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># 스레드가 실행할 시간을 줍니다</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Main thread sleeping&#39;</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>실행하면 다음과 같은 출력이 생성됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Running worker
Running worker
Running worker
Running worker
Running worker
Main thread sleeping
Worker &lt;Thread(worker 1, started 130283832797456)&gt; running with argument 0
Worker &lt;Thread(worker 2, started 130283824404752)&gt; running with argument 1
Worker &lt;Thread(worker 3, started 130283816012048)&gt; running with argument 2
Worker &lt;Thread(worker 4, started 130283807619344)&gt; running with argument 3
Worker &lt;Thread(worker 5, started 130283799226640)&gt; running with argument 4
Worker &lt;Thread(worker 1, started 130283832797456)&gt; running with argument 5
...
</pre></div>
</div>
<p>자세한 내용은 모듈 설명서를 참조하십시오. <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> 클래스는 기능이 풍부한 인터페이스를 제공합니다.</p>
</div>
<div class="section" id="what-kinds-of-global-value-mutation-are-thread-safe">
<h3><a class="toc-backref" href="#id17">어떤 종류의 전역 값 변경이 스레드 안전합니까?</a><a class="headerlink" href="#what-kinds-of-global-value-mutation-are-thread-safe" title="제목 주소">¶</a></h3>
<p>내부적으로 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">전역 인터프리터 록</span></a>(GIL)이 사용되어 한 번에 하나의 스레드 만 파이썬 VM에서 실행되도록 합니다. 일반적으로, 파이썬은 바이트 코드 명령어들 사이에서만 스레드 간 전환을 제공합니다; <a class="reference internal" href="../library/sys.html#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>을 통해 얼마나 자주 전환할지를 설정할 수 있습니다. 따라서 각 바이트 코드 명령어와 각 명령어에서 도달하는 모든 C 구현 코드는 파이썬 프로그램의 관점에서 원자 적입니다.</p>
<p>이론적으로, 이것은 정확하게 따지기 위해서는 PVM 바이트 코드 구현에 대한 정확한 이해가 필요하다는 것을 의미합니다. 경험적으로는, 이것은 &quot;원자 적으로 보이는&quot; 내장 데이터형(정수, 리스트, 딕셔너리 등)의 공유 변수에 대한 조작이 실제로 원자 적임을 의미합니다.</p>
<p>예를 들어, 다음 연산은 모두 원자 적입니다 (L, L1, L2는 리스트, D, D1, D2는 딕셔너리, x, y는 객체, i, j는 정수입니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">L1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L2</span>
<span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">x</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
<span class="n">D</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>이것들은 아닙니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>다른 객체를 대체하는 연산은 객체의 참조 횟수가 0에 도달할 때 그들의 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드를 호출할 수 있으며, 이는 영향을 줄 수 있습니다. 이것은 딕셔너리와 리스트의 대량 갱신 때 특히 그렇습니다. 의심스러우면, 뮤텍스를 사용하십시오!</p>
</div>
<div class="section" id="can-t-we-get-rid-of-the-global-interpreter-lock">
<h3><a class="toc-backref" href="#id18">전역 인터프리터 록을 제거할 수 없습니까?</a><a class="headerlink" href="#can-t-we-get-rid-of-the-global-interpreter-lock" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">전역 인터프리터 록</span></a>(GIL)은 종종 하이 엔드 다중 프로세서 서버 기계에 파이썬을 배치하는 데 방해가 된다고 여겨집니다, (거의) 모든 파이썬 코드가 GIL을 잡고 있는 동안에만 실행하려고 해서, 다중 스레드 파이썬 프로그램이 사실상 오직 하나의 CPU만 사용하기 때문입니다.</p>
<p>파이썬 1.5 시절에, Greg Stein은 실제로 GIL을 제거하고 세밀한 록으로 대체한 포괄적인 패치 모음(&quot;자유로운 스레딩&quot; 패치)을 구현했습니다. Adam Olsen은 최근 그의 <a class="reference external" href="https://code.google.com/archive/p/python-safethread">python-safethread</a> 프로젝트에서 유사한 실험을 수행했습니다. 불행히도, 두 실험 모두 GIL 제거를 보상하는 데 필요한 세밀한 록의 양으로 인해 단일 스레드 성능이 급격히 떨어졌습니다 (적어도 30% 더 느립니다).</p>
<p>그렇다고 다중 CPU 기계에서 파이썬을 제대로 사용할 수는 없다는 뜻은 아닙니다! 여러 <em>스레드</em> 대신에 여러 <em>프로세스</em>로 작업을 분할하는 창의력을 발휘해야 합니다. 새로운 <a class="reference internal" href="../library/concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> 모듈의 <a class="reference internal" href="../library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a> 클래스는 그렇게 하는 쉬운 방법을 제공합니다; <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 모듈은 작업 디스패치에 대한 제어를 더 원할 때를 위한 저수준 API를 제공합니다.</p>
<p>C 확장을 신중하게 사용하는 것도 도움이 됩니다; C 확장을 사용하여 시간이 오래 걸리는 작업을 수행하면, 확장은 실행 스레드가 C 코드에 있는 동안 GIL을 해제하고 다른 스레드가 어떤 작업을 수행할 수 있도록 할 수 있습니다. <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>와 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a>와 같은 일부 표준 라이브러리 모듈은 이미 이렇게 합니다.</p>
<p>GIL은 진정한 전역이 아니라 인터프리터별 상태 록이어야 한다고 제안되었습니다; 그러면 인터프리터가 객체를 공유할 수 없습니다. 불행히도, 이것도 일어날 가능성이 없습니다. 많은 객체 구현이 현재 전역 상태를 가지고 있기 때문에, 엄청난 양의 작업이 될 것입니다. 예를 들어, 작은 정수와 짧은 문자열이 캐시 됩니다; 이러한 캐시는 인터프리터 상태로 이동해야 합니다. 다른 객체 형에는 자체 자유 목록(free list)이 있습니다; 이 자유 목록은 인터프리터 상태로 이동해야 합니다. 이런 식으로 계속됩니다.</p>
<p>그리고 제삼자 확장에도 같은 문제가 있기 때문에, 유한한 시간 안에 할 수 있는지도 의심스럽습니다. 제삼자 확장은 여러분이 그들의 전체 전역 상태를 인터프리터 상태에 저장하도록 변환할 수 있는 것보다 빠른 속도로 작성되고 있을 가능성이 높습니다.</p>
<p>그리고 마지막으로, 일단 상태를 공유하지 않는 다중 인터프리터를 갖게 된다면, 각 인터프리터를 별도의 프로세스로 실행하는 것에 비해 얻은 이점은 무엇입니까?</p>
</div>
</div>
<div class="section" id="input-and-output">
<h2><a class="toc-backref" href="#id19">입력과 출력</a><a class="headerlink" href="#input-and-output" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-delete-a-file-and-other-file-questions">
<h3><a class="toc-backref" href="#id20">파일을 어떻게 삭제합니까? (그리고 다른 파일 질문들...)</a><a class="headerlink" href="#how-do-i-delete-a-file-and-other-file-questions" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">os.remove(filename)</span></code>이나 <code class="docutils literal notranslate"><span class="pre">os.unlink(filename)</span></code>을 사용하십시오; 설명서는 <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 모듈을 참조하십시오. 두 함수는 동일합니다; <a class="reference internal" href="../library/os.html#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">unlink()</span></code></a>는 단순히 이 함수에 대한 유닉스 시스템 호출의 이름입니다.</p>
<p>디렉터리를 제거하려면, <a class="reference internal" href="../library/os.html#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rmdir()</span></code></a>을 사용하십시오; 만들려면 <a class="reference internal" href="../library/os.html#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.mkdir()</span></code></a>을 사용하십시오. <code class="docutils literal notranslate"><span class="pre">os.makedirs(path)</span></code>는 존재하지 않는 <code class="docutils literal notranslate"><span class="pre">path</span></code>의 중간 디렉터리를 만듭니다. <code class="docutils literal notranslate"><span class="pre">os.removedirs(path)</span></code>는 비어있는 한, 중간 디렉터리를 제거합니다; 전체 디렉터리 트리와 그 내용을 삭제하려면 <a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.rmtree()</span></code></a>를 사용하십시오.</p>
<p>파일 이름을 바꾸려면 <code class="docutils literal notranslate"><span class="pre">os.rename(old_path,</span> <span class="pre">new_path)</span></code>를 사용하십시오.</p>
<p>파일을 자르려면, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">open(filename,</span> <span class="pre">&quot;rb+&quot;)</span></code>를 사용하여 열고 <code class="docutils literal notranslate"><span class="pre">f.truncate(offset)</span></code>을 사용하십시오; offset의 기본값은 현재 탐색(seek) 위치입니다. <a class="reference internal" href="../library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a>으로 열린 파일의 경우 <code class="docutils literal notranslate"><span class="pre">os.ftruncate(fd,</span> <span class="pre">offset)</span></code>도 있습니다. 여기서 <em>fd</em>는 파일 기술자(작은 정수)입니다.</p>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 모듈에도 <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a>, <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 및 <a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a>를 포함한 파일에서 작동하는 많은 함수가 포함되어 있습니다.</p>
</div>
<div class="section" id="how-do-i-copy-a-file">
<h3><a class="toc-backref" href="#id21">파일을 어떻게 복사합니까?</a><a class="headerlink" href="#how-do-i-copy-a-file" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 모듈에는 <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a> 함수가 포함되어 있습니다. MacOS 9에서 리소스 포크(resource fork)와 파인더(Finder)_ 정보를 복사하지 않음에 유의하십시오.</p>
</div>
<div class="section" id="how-do-i-read-or-write-binary-data">
<h3><a class="toc-backref" href="#id22">바이너리 데이터를 읽는 (또는 쓰는) 방법은 무엇입니까?</a><a class="headerlink" href="#how-do-i-read-or-write-binary-data" title="제목 주소">¶</a></h3>
<p>복잡한 바이너리 데이터 형식을 읽거나 쓰려면, <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 모듈을 사용하는 것이 가장 좋습니다. 바이너리 데이터(보통 숫자)를 포함하는 문자열을 취해서 파이썬 객체로 변환할 수 있도록 합니다; 그리고 그 반대도 가능합니다.</p>
<p>예를 들어, 다음 코드는 파일에서 빅 엔디안 형식의 두 개의 2-바이트 정수와 하나의 4-바이트 정수를 읽습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;hhl&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>포맷 문자열의 '&gt;'는 빅 엔디안 데이터를 강제합니다; 문자 'h'는 하나의 &quot;짧은(short) 정수&quot;(2바이트)를 읽고, 'l'은 문자열에서 하나의 &quot;긴(long) 정수&quot;(4바이트)를 읽습니다.</p>
<p>더욱 규칙적인 데이터(예를 들어 int나 float의 동종 리스트)의 경우, <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 모듈을 사용할 수도 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>바이너리 데이터를 읽고 쓰려면, 바이너리 모드로 파일을 열어야 합니다 (여기서는, <code class="docutils literal notranslate"><span class="pre">&quot;rb&quot;</span></code>를 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>으로 전달합니다). 대신 <code class="docutils literal notranslate"><span class="pre">&quot;r&quot;</span></code>(기본값)을 사용하면, 파일이 텍스트 모드로 열리고 <code class="docutils literal notranslate"><span class="pre">f.read()</span></code>는 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체 대신 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체를 반환합니다.</p>
</div>
</div>
<div class="section" id="i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why">
<h3><a class="toc-backref" href="#id23">os.popen()으로 만든 파이프에서 os.read()를 사용할 수 없는 것처럼 보입니다; 왜입니까?</a><a class="headerlink" href="#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/os.html#os.read" title="os.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.read()</span></code></a>는 열린 파일을 나타내는 작은 정수인 파일 기술자를 취하는 저수준 함수입니다. <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>은 내장 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수에서 반환하는 것과 같은 형의 고수준 파일 객체를 만듭니다. 따라서, <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>으로 만들어진 파이프 <em>p</em>에서 <em>n</em> 바이트를 읽으려면, <code class="docutils literal notranslate"><span class="pre">p.read(n)</span></code>을 사용해야 합니다.</p>
</div>
<div class="section" id="how-do-i-access-the-serial-rs232-port">
<h3><a class="toc-backref" href="#id24">직렬 (RS232) 포트에 어떻게 액세스합니까?</a><a class="headerlink" href="#how-do-i-access-the-serial-rs232-port" title="제목 주소">¶</a></h3>
<p>Win32, POSIX(리눅스, BSD 등), Jython의 경우:</p>
<blockquote>
<div><p><a class="reference external" href="http://pyserial.sourceforge.net">http://pyserial.sourceforge.net</a></p>
</div></blockquote>
<p>유닉스의 경우, Mitch Chapman의 유즈넷 게시물을 참조하십시오:</p>
<blockquote>
<div><p><a class="reference external" href="https://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com">https://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com</a></p>
</div></blockquote>
</div>
<div class="section" id="why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it">
<h3><a class="toc-backref" href="#id25">왜 sys.stdout(stdin, stderr)을 닫아도 닫히지 않습니까?</a><a class="headerlink" href="#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it" title="제목 주소">¶</a></h3>
<p>파이썬 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>는 저수준 C 파일 기술자의 고수준 추상화 계층입니다.</p>
<p>내장 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수를 통해 파이썬에서 만드는 대부분 파일 객체의 경우, <code class="docutils literal notranslate"><span class="pre">f.close()</span></code>는 파이썬 파일 객체를 파이썬의 관점에서 닫은 것으로 표시하고 하부 C 파일 기술자를 닫도록 합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">f</span></code>가 가비지가 될 때 <code class="docutils literal notranslate"><span class="pre">f</span></code>의 파괴자에서 자동으로 일어나기도 합니다.</p>
<p>그러나 stdin, stdout 및 stderr은 파이썬에서 특별하게 처리되는데, C 역시 이들에게 특수한 상태를 부여하기 때문입니다. <code class="docutils literal notranslate"><span class="pre">sys.stdout.close()</span></code>를 실행하면 파이썬 수준 파일 객체가 닫힌 것으로 표시되지만, 연관된 C 파일 기술자를 닫지 <em>않습니다</em>.</p>
<p>이 세 가지 중 하나에 대한 하부 C 파일 기술자를 닫으려면, 먼저 이것이 정말로 여러분이 하고 싶은 것인지 확인해야 합니다 (예를 들어, I/O를 수행하려는 확장 모듈이 혼동할 수 있습니다). 그렇다면, <a class="reference internal" href="../library/os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a>를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">stderr</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
</pre></div>
</div>
<p>또는 숫자 상수 0, 1 및 2를 각각 사용할 수 있습니다.</p>
</div>
</div>
<div class="section" id="network-internet-programming">
<h2><a class="toc-backref" href="#id26">네트워크/인터넷 프로그래밍</a><a class="headerlink" href="#network-internet-programming" title="제목 주소">¶</a></h2>
<div class="section" id="what-www-tools-are-there-for-python">
<h3><a class="toc-backref" href="#id27">파이썬에는 어떤 WWW 도구가 있습니까?</a><a class="headerlink" href="#what-www-tools-are-there-for-python" title="제목 주소">¶</a></h3>
<p>라이브러리 레퍼런스 매뉴얼의 <a class="reference internal" href="../library/internet.html#internet"><span class="std std-ref">인터넷 프로토콜과 지원</span></a>과 <a class="reference internal" href="../library/netdata.html#netdata"><span class="std std-ref">인터넷 데이터 처리</span></a> 장을 참조하십시오. 파이썬에는 서버 측과 클라이언트 측 웹 시스템을 구축하는 데 도움이 되는 많은 모듈이 있습니다.</p>
<p>사용 가능한 프레임워크 요약은 Paul Boddie가 <a class="reference external" href="https://wiki.python.org/moin/WebProgramming">https://wiki.python.org/moin/WebProgramming</a>에서 유지 관리합니다.</p>
<p>Cameron Laird는 <a class="reference external" href="http://phaseit.net/claird/comp.lang.python/web_python">http://phaseit.net/claird/comp.lang.python/web_python</a>에서 파이썬 웹 기술에 관한 유용한 페이지 모음을 유지 관리합니다.</p>
</div>
<div class="section" id="how-can-i-mimic-cgi-form-submission-method-post">
<h3><a class="toc-backref" href="#id28">CGI 폼 제출을 어떻게 흉내 낼 수 있습니까 (METHOD=POST)?</a><a class="headerlink" href="#how-can-i-mimic-cgi-form-submission-method-post" title="제목 주소">¶</a></h3>
<p>폼을 POST 한 결과 웹 페이지를 가져오고 싶습니다. 이 작업을 쉽게 수행할 수 있도록 하는 기존 코드가 있습니까?</p>
<p>예. 다음은 <a class="reference internal" href="../library/urllib.request.html#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a>를 사용하는 간단한 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/local/bin/python</span>

<span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="c1"># 쿼리 문자열을 만듭니다</span>
<span class="n">qs</span> <span class="o">=</span> <span class="s2">&quot;First=Josephine&amp;MI=Q&amp;Last=Public&quot;</span>

<span class="c1"># 연결하고 서버에게 경로를 보냅니다</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.some-server.out-there&#39;</span>
                             <span class="s1">&#39;/cgi-bin/some-cgi-script&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">qs</span><span class="p">)</span>
<span class="k">with</span> <span class="n">req</span><span class="p">:</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">hdrs</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">req</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
<p>일반적으로 퍼센트 인코딩된 POST 연산의 경우, 쿼리 문자열은 <a class="reference internal" href="../library/urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a>를 사용하여 인용해야 함에 유의하십시오. 예를 들어, <code class="docutils literal notranslate"><span class="pre">name=Guy</span> <span class="pre">Steele,</span> <span class="pre">Jr.</span></code> 를 보내려면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Guy Steele, Jr.&#39;</span><span class="p">})</span>
<span class="go">&#39;name=Guy+Steele%2C+Jr.&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>광범위한 예는 <a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib 패키지를 사용하여 인터넷 리소스를 가져오는 방법</span></a>을 참조하십시오.</p>
</div>
</div>
<div class="section" id="what-module-should-i-use-to-help-with-generating-html">
<h3><a class="toc-backref" href="#id29">HTML 생성을 위해 어떤 모듈을 사용해야 합니까?</a><a class="headerlink" href="#what-module-should-i-use-to-help-with-generating-html" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://wiki.python.org/moin/WebProgramming">Web Programming wiki page</a>에서 유용한 링크 모음을 찾을 수 있습니다.</p>
</div>
<div class="section" id="how-do-i-send-mail-from-a-python-script">
<h3><a class="toc-backref" href="#id30">파이썬 스크립트에서 메일을 보내려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-do-i-send-mail-from-a-python-script" title="제목 주소">¶</a></h3>
<p>표준 라이브러리 모듈 <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a>를 사용하십시오.</p>
<p>다음은 이를 사용하는 매우 간단한 대화식 메일 발신기입니다. 이 방법은 SMTP 리스너를 지원하는 모든 호스트에서 작동합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">smtplib</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter message, end with ^D:&quot;</span><span class="p">)</span>
<span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">line</span>

<span class="c1"># 실제 우편 전송</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>유닉스 전용 대안은 sendmail을 사용합니다. sendmail 프로그램의 위치는 시스템마다 다릅니다; 때로는 <code class="docutils literal notranslate"><span class="pre">/usr/lib/sendmail</span></code>, 때로는 <code class="docutils literal notranslate"><span class="pre">/usr/sbin/sendmail</span></code>. sendmail 매뉴얼 페이지가 도움이 될 것입니다. 샘플 코드는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="n">SENDMAIL</span> <span class="o">=</span> <span class="s2">&quot;/usr/sbin/sendmail&quot;</span>  <span class="c1"># sendmail 위치</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -t -i&quot;</span> <span class="o">%</span> <span class="n">SENDMAIL</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;To: receiver@example.com</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Subject: test</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># 헤더와 본문을 구분하는 빈 줄</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Some text</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;some more text</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">sts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">if</span> <span class="n">sts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sendmail exit status&quot;</span><span class="p">,</span> <span class="n">sts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-avoid-blocking-in-the-connect-method-of-a-socket">
<h3><a class="toc-backref" href="#id31">소켓의 connect() 메서드에서 블로킹을 피하려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-do-i-avoid-blocking-in-the-connect-method-of-a-socket" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a> 모듈이 소켓의 비동기 I/O를 지원하는 데 흔히 사용됩니다.</p>
<p>TCP 연결이 블록 되지 않도록 하기 위해, 소켓을 비 블로킹 모드로 설정할 수 있습니다. 그런 다음 <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code>를 수행하면, 즉시 연결되거나 (그다지 가능성이 없습니다) 에러 번호를 <code class="docutils literal notranslate"><span class="pre">.errno</span></code>에 포함하는 예외가 발생합니다. <code class="docutils literal notranslate"><span class="pre">errno.EINPROGRESS</span></code>는 연결이 진행 중이지만, 아직 완료되지 않았음을 나타냅니다. OS마다 다른 값을 반환해서, 여러분의 시스템에서 무엇이 반환되는지 확인해야 합니다.</p>
<p>예외를 피하려면 <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect_ex()</span></code> 메서드를 사용할 수 있습니다. errno 값만 반환합니다. 폴링하려면, 나중에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect_ex()</span></code>를 다시 호출할 수 있습니다 -- <code class="docutils literal notranslate"><span class="pre">0</span></code>이나 <code class="docutils literal notranslate"><span class="pre">errno.EISCONN</span></code>은 연결되었음을 나타냅니다 -- 또는 이 소켓을 <a class="reference internal" href="../library/select.html#select.select" title="select.select"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select.select()</span></code></a>로 전달하여 쓸 수 있는지 확인할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 모듈은 비 블로킹 네트워크 코드를 작성하는 데 사용할 수 있는 범용 단일 스레드 및 동시성 비동기 라이브러리를 제공합니다. 제삼자 <a class="reference external" href="https://twistedmatrix.com/trac/">Twisted</a> 라이브러리는 널리 사용되는 기능이 풍부한 대안입니다.</p>
</div>
</div>
</div>
<div class="section" id="databases">
<h2><a class="toc-backref" href="#id32">데이터베이스</a><a class="headerlink" href="#databases" title="제목 주소">¶</a></h2>
<div class="section" id="are-there-any-interfaces-to-database-packages-in-python">
<h3><a class="toc-backref" href="#id33">파이썬에 데이터베이스 패키지에 대한 인터페이스가 있습니까?</a><a class="headerlink" href="#are-there-any-interfaces-to-database-packages-in-python" title="제목 주소">¶</a></h3>
<p>예.</p>
<p><a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DBM</span></code></a>과 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">GDBM</span></code></a>같은 디스크 기반 해시에 대한 인터페이스도 표준 파이썬에 포함되어 있습니다. 경량 디스크 기반 관계형 데이터베이스를 제공하는 <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈도 있습니다.</p>
<p>대부분 관계형 데이터베이스에 대한 지원이 제공됩니다. 자세한 내용은 <a class="reference external" href="https://wiki.python.org/moin/DatabaseProgramming">DatabaseProgramming wiki page</a>를 참조하십시오.</p>
</div>
<div class="section" id="how-do-you-implement-persistent-objects-in-python">
<h3><a class="toc-backref" href="#id34">파이썬에서 영속 객체를 어떻게 구현합니까?</a><a class="headerlink" href="#how-do-you-implement-persistent-objects-in-python" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 라이브러리 모듈은 이것을 매우 일반적인 방식으로 해결하고 (여전히 열린 파일, 소켓 또는 창과 같은 것을 저장할 수는 없지만), <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> 라이브러리 모듈은 pickle과 (g)dbm을 사용하여 임의의 파이썬 객체를 포함하는 영속적(persistent) 매핑을 만듭니다.</p>
</div>
</div>
<div class="section" id="mathematics-and-numerics">
<h2><a class="toc-backref" href="#id35">수학과 숫자</a><a class="headerlink" href="#mathematics-and-numerics" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-generate-random-numbers-in-python">
<h3><a class="toc-backref" href="#id36">파이썬에서 난수를 어떻게 생성합니까?</a><a class="headerlink" href="#how-do-i-generate-random-numbers-in-python" title="제목 주소">¶</a></h3>
<p>표준 모듈 <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>은 난수 생성기를 구현합니다. 사용법은 간단합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
</pre></div>
</div>
<p>이것은 [0, 1) 범위의 무작위 부동 소수점 숫자를 반환합니다.</p>
<p>이 모듈에는 다른 많은 특수 생성기가 있습니다, 가령:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">randrange(a,</span> <span class="pre">b)</span></code>는 [a, b) 범위의 정수를 선택합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uniform(a,</span> <span class="pre">b)</span></code>는 [a, b) 범위의 부동 소수점 숫자를 선택합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">normalvariate(mean,</span> <span class="pre">sdev)</span></code>는 정규 (가우시안) 분포를 샘플링합니다.</p></li>
</ul>
<p>일부 고수준 함수는 시퀀스에서 직접 작동합니다, 가령:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">choice(S)</span></code>는 주어진 시퀀스에서 무작위 요소 하나를 선택합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shuffle(L)</span></code>은 리스트를 제자리에서 섞습니다, 즉 무작위로 순서를 바꿉니다.</p></li>
</ul>
<p>독립적인 여러 개의 난수 생성기를 만들기 위해 인스턴스 화 할 수 있는 <code class="docutils literal notranslate"><span class="pre">Random</span></code> 클래스도 있습니다.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">라이브러리와 확장 FAQ</a><ul>
<li><a class="reference internal" href="#general-library-questions">일반 라이브러리 관련 질문</a></li>
<li><a class="reference internal" href="#common-tasks">일반적인 작업</a></li>
<li><a class="reference internal" href="#threads">스레드</a></li>
<li><a class="reference internal" href="#input-and-output">입력과 출력</a></li>
<li><a class="reference internal" href="#network-internet-programming">네트워크/인터넷 프로그래밍</a></li>
<li><a class="reference internal" href="#databases">데이터베이스</a></li>
<li><a class="reference internal" href="#mathematics-and-numerics">수학과 숫자</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="design.html"
                        title="이전 장">설계와 역사 FAQ</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="extending.html"
                        title="다음 장">확장/내장 FAQ</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="extending.html" title="확장/내장 FAQ"
             >다음</a> |</li>
        <li class="right" >
          <a href="design.html" title="설계와 역사 FAQ"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 자주 나오는 질문들</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>