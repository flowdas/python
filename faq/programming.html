
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>프로그래밍 FAQ &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="설계와 역사 FAQ" href="design.html" />
    <link rel="prev" title="일반적인 파이썬 FAQ" href="general.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/faq/programming.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="design.html" title="설계와 역사 FAQ"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="general.html" title="일반적인 파이썬 FAQ"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 자주 나오는 질문들</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="programming-faq">
<h1><a class="toc-backref" href="#id1">프로그래밍 FAQ</a><a class="headerlink" href="#programming-faq" title="제목 주소">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">목차</p>
<ul class="simple">
<li><p><a class="reference internal" href="#programming-faq" id="id1">프로그래밍 FAQ</a></p>
<ul>
<li><p><a class="reference internal" href="#general-questions" id="id2">일반적인 질문</a></p>
<ul>
<li><p><a class="reference internal" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" id="id3">중단점, 단일 스테핑(single-stepping) 등을 포함하는 소스 코드 수준 디버거가 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#are-there-tools-to-help-find-bugs-or-perform-static-analysis" id="id4">버그를 찾거나 정적 분석을 수행하는 데 도움이 되는 도구가 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" id="id5">파이썬 스크립트로 독립 실행형 바이너리를 만들려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" id="id6">파이썬 프로그램을 위한 코딩 표준이나 스타일 지침서가 있습니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#core-language" id="id7">핵심 언어</a></p>
<ul>
<li><p><a class="reference internal" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" id="id8">변수에 값이 있을 때 UnboundLocalError 가 발생하는 이유는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#what-are-the-rules-for-local-and-global-variables-in-python" id="id9">파이썬에서 지역과 전역 변수에 대한 규칙은 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" id="id10">다른 값으로 루프에서 정의된 람다는 왜 모두 같은 결과를 반환합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-share-global-variables-across-modules" id="id11">모듈 간에 전역 변수를 공유하려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#what-are-the-best-practices-for-using-import-in-a-module" id="id12">모듈에서 임포트를 사용하는 &quot;모범 사례&quot;는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#why-are-default-values-shared-between-objects" id="id13">객체 간에 기본값이 공유되는 이유는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" id="id14">한 함수에서 다른 함수로 선택적이나 키워드 매개변수를 전달하려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#what-is-the-difference-between-arguments-and-parameters" id="id15">인자와 매개변수의 차이점은 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#why-did-changing-list-y-also-change-list-x" id="id16">리스트 'y'를 변경할 때 리스트 'x'도 변경되는 이유는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" id="id17">출력 매개변수가 있는 함수를 작성하려면 어떻게 해야 합니까 (참조에 의한 호출)?</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-make-a-higher-order-function-in-python" id="id18">파이썬에서 고차 함수(higher order function)를 어떻게 만드나요?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-copy-an-object-in-python" id="id19">파이썬에서 객체를 어떻게 복사합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-find-the-methods-or-attributes-of-an-object" id="id20">객체의 메서드나 어트리뷰트를 어떻게 찾을 수 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-my-code-discover-the-name-of-an-object" id="id21">코드에서 객체 이름을 어떻게 찾을 수 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#what-s-up-with-the-comma-operator-s-precedence" id="id22">쉼표 연산자의 우선순위는 어떻게 되나요?</a></p></li>
<li><p><a class="reference internal" href="#is-there-an-equivalent-of-c-s-ternary-operator" id="id23">C의 &quot;?:&quot; 삼항 연산자와 동등한 것이 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" id="id24">파이썬에서 난독화된 한 줄 코드를 작성할 수 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" id="id25">함수의 매개변수 목록에서 슬래시(/)는 무엇을 의미합니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#numbers-and-strings" id="id26">숫자와 문자열</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-specify-hexadecimal-and-octal-integers" id="id27">16진수와 8진수 정수는 어떻게 지정합니까?</a></p></li>
<li><p><a class="reference internal" href="#why-does-22-10-return-3" id="id28">왜 -22 // 10 이 -3을 반환합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-convert-a-string-to-a-number" id="id29">문자열을 숫자로 어떻게 변환합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-convert-a-number-to-a-string" id="id30">숫자를 문자열로 어떻게 변환합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-modify-a-string-in-place" id="id31">제자리에서 문자열을 어떻게 수정합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-use-strings-to-call-functions-methods" id="id32">문자열을 사용하여 어떻게 함수/메서드를 호출합니까?</a></p></li>
<li><p><a class="reference internal" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" id="id33">문자열에서 후행 줄 바꿈을 제거하는 Perl의 chomp()와 동등한 것이 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#is-there-a-scanf-or-sscanf-equivalent" id="id34">scanf()나 sscanf()에 해당하는 것이 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" id="id35">'UnicodeDecodeError'나 'UnicodeEncodeError' 에러는 무엇을 의미합니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#performance" id="id36">성능</a></p>
<ul>
<li><p><a class="reference internal" href="#my-program-is-too-slow-how-do-i-speed-it-up" id="id37">내 프로그램이 너무 느립니다. 속도를 높이려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" id="id38">많은 문자열을 함께 이어붙이는 가장 효율적인 방법은 무엇입니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#sequences-tuples-lists" id="id39">시퀀스 (튜플/리스트)</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-convert-between-tuples-and-lists" id="id40">튜플과 리스트를 어떻게 변환합니까?</a></p></li>
<li><p><a class="reference internal" href="#what-s-a-negative-index" id="id41">음수 인덱스는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" id="id42">시퀀스를 역순으로 이터레이트 하려면 어떻게 합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-remove-duplicates-from-a-list" id="id43">리스트에서 중복을 어떻게 제거합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-remove-multiple-items-from-a-list" id="id44">리스트에서 여러 항목을 어떻게 제거합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-make-an-array-in-python" id="id45">파이썬에서 어떻게 배열을 만드나요?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-create-a-multidimensional-list" id="id46">다차원 리스트를 어떻게 만듭니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-apply-a-method-to-a-sequence-of-objects" id="id47">객체의 시퀀스에 메서드를 어떻게 적용합니까?</a></p></li>
<li><p><a class="reference internal" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" id="id48">덧셈은 작동하는데, 왜 a_tuple[i] += ['item']이 예외를 일으킵니까?</a></p></li>
<li><p><a class="reference internal" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" id="id49">복잡한 정렬을 하고 싶습니다: 파이썬에서 Schwartzian 변환을 할 수 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-sort-one-list-by-values-from-another-list" id="id50">한 리스트를 다른 리스트의 값으로 정렬하려면 어떻게 해야 합니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#objects" id="id51">객체</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-a-class" id="id52">클래스는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#what-is-a-method" id="id53">메서드는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#what-is-self" id="id54">self는 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" id="id55">객체가 주어진 클래스나 그 서브 클래스의 인스턴스인지 어떻게 확인합니까?</a></p></li>
<li><p><a class="reference internal" href="#what-is-delegation" id="id56">위임이란 무엇입니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it" id="id57">메서드를 재정의하는 파생 클래스에서 베이스 클래스에 정의된 해당 메서드를 어떻게 호출합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" id="id58">베이스 클래스를 쉽게 변경할 수 있도록 코드를 구성하려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-create-static-class-data-and-static-class-methods" id="id59">정적 클래스 데이터와 정적 클래스 메서드를 만들려면 어떻게 해야 합니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-overload-constructors-or-methods-in-python" id="id60">파이썬에서 생성자(또는 메서드)를 어떻게 재정의할 수 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" id="id61">__spam을 사용하려고 하는데 _SomeClassName__spam에 대한 에러가 발생합니다.</a></p></li>
<li><p><a class="reference internal" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" id="id62">내 클래스는 __del__을 정의하지만 객체를 삭제할 때 호출되지 않습니다.</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" id="id63">주어진 클래스의 모든 인스턴스 목록을 어떻게 얻습니까?</a></p></li>
<li><p><a class="reference internal" href="#why-does-the-result-of-id-appear-to-be-not-unique" id="id64"><code class="docutils literal notranslate"><span class="pre">id()</span></code>의 결과가 고유하지 않은 것처럼 보이는 이유는 무엇입니까?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#modules" id="id65">모듈</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-create-a-pyc-file" id="id66">.pyc 파일을 어떻게 만듭니까?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-find-the-current-module-name" id="id67">현재 모듈 이름을 어떻게 찾습니까?</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-have-modules-that-mutually-import-each-other" id="id68">서로 임포트 하는 모듈을 어떻게 만들 수 있습니까?</a></p></li>
<li><p><a class="reference internal" href="#import-x-y-z-returns-module-x-how-do-i-get-z" id="id69">__import__('x.y.z')는 &lt;module 'x'&gt;를 반환합니다; z를 어떻게 얻습니까?</a></p></li>
<li><p><a class="reference internal" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" id="id70">임포트 된 모듈을 편집하고 다시 임포트 할 때, 변경 사항이 표시되지 않습니다. 왜 이런 일이 발생합니까?</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-questions">
<h2><a class="toc-backref" href="#id2">일반적인 질문</a><a class="headerlink" href="#general-questions" title="제목 주소">¶</a></h2>
<div class="section" id="is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc">
<h3><a class="toc-backref" href="#id3">중단점, 단일 스테핑(single-stepping) 등을 포함하는 소스 코드 수준 디버거가 있습니까?</a><a class="headerlink" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" title="제목 주소">¶</a></h3>
<p>예.</p>
<p>파이썬을 위한 여러 디버거가 아래에 설명되어 있으며, 내장 함수 <a class="reference internal" href="../library/functions.html#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a>를 사용하면 이들 중 하나로 들어갈 수 있습니다.</p>
<p>pdb 모듈은 간단하지만 적절한 파이썬 용 콘솔 모드 디버거입니다. 표준 파이썬 라이브러리의 일부이며, <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">라이브러리</span> <span class="pre">레퍼런스</span> <span class="pre">매뉴얼에서</span> <span class="pre">설명</span></code></a>하고 있습니다. pdb의 코드를 예로 사용하여 자체 디버거를 작성할 수도 있습니다.</p>
<p>표준 파이썬 배포의 일부인 (보통 Tools/scripts/idle에 있습니다) IDLE 대화식 개발 환경에는 그래픽 디버거가 포함되어 있습니다.</p>
<p>PythonWin은 pdb 기반 GUI 디버거를 포함하는 파이썬 IDE입니다. Pythonwin 디버거는 중단점에 색을 입히고 비 Pythonwin 프로그램 디버깅과 같은 멋진 기능을 제공합니다. Pythonwin은 <a class="reference external" href="https://sourceforge.net/projects/pywin32/">Python for Windows Extensions</a> 프로젝트의 일부와 ActivePython 배포의 일부로 제공됩니다 (<a class="reference external" href="https://www.activestate.com/activepython">https://www.activestate.com/activepython</a> 를 참조하십시오).</p>
<p><a class="reference external" href="http://eric-ide.python-projects.org/">Eric</a>은 PyQt와 Scintilla 편집 컴포넌트를 기반으로 하는 IDE입니다.</p>
<p>Pydb는 널리 사용되는 그래픽 디버거 프런트 엔드인 DDD(Data Display Debugger)와 함께 사용하도록 수정된 표준 파이썬 디버거 pdb의 버전입니다. Pydb는 <a class="reference external" href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a> 에서 찾을 수 있고 DDD는 <a class="reference external" href="https://www.gnu.org/software/ddd">https://www.gnu.org/software/ddd</a> 에서 찾을 수 있습니다.</p>
<p>그래픽 디버거를 포함하는 많은 상용 파이썬 IDE가 있습니다. 다음을 포함합니다:</p>
<ul class="simple">
<li><p>Wing IDE (<a class="reference external" href="https://wingware.com/">https://wingware.com/</a>)</p></li>
<li><p>Komodo IDE (<a class="reference external" href="https://komodoide.com/">https://komodoide.com/</a>)</p></li>
<li><p>PyCharm (<a class="reference external" href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a>)</p></li>
</ul>
</div>
<div class="section" id="are-there-tools-to-help-find-bugs-or-perform-static-analysis">
<h3><a class="toc-backref" href="#id4">버그를 찾거나 정적 분석을 수행하는 데 도움이 되는 도구가 있습니까?</a><a class="headerlink" href="#are-there-tools-to-help-find-bugs-or-perform-static-analysis" title="제목 주소">¶</a></h3>
<p>예.</p>
<p><a class="reference external" href="https://www.pylint.org/">Pylint</a>와 <a class="reference external" href="https://github.com/PyCQA/pyflakes">Pyflakes</a>는 버그를 더 빨리 발견하는 데 도움이 되는 기본 검사를 수행합니다.</p>
<p><a class="reference external" href="http://mypy-lang.org/">Mypy</a>, <a class="reference external" href="https://pyre-check.org/">Pyre</a> 및 <a class="reference external" href="https://github.com/google/pytype">Pytype</a>과 같은 정적 형 검사기는 파이썬 소스 코드에 있는 형 힌트를 검사할 수 있습니다.</p>
</div>
<div class="section" id="how-can-i-create-a-stand-alone-binary-from-a-python-script">
<h3><a class="toc-backref" href="#id5">파이썬 스크립트로 독립 실행형 바이너리를 만들려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" title="제목 주소">¶</a></h3>
<p>사용자가 파이썬 배포를 먼저 설치하지 않고도 다운로드하여 실행할 수 있는 독립 실행형 프로그램을 원하는 것이 전부라면 파이썬을 C 코드로 컴파일하는 기능이 필요하지는 않습니다. 프로그램에 필요한 모듈 집합을 파악하고 이러한 모듈들을 파이썬 바이너리와 결합하여 단일 실행 파일을 생성하는 많은 도구가 있습니다.</p>
<p>그중 하나는 파이썬 소스 트리에 <code class="docutils literal notranslate"><span class="pre">Tools/freeze</span></code>로 포함된 freeze 도구를 사용하는 것입니다. 파이썬 바이트 코드를 C 배열로 변환합니다; C 컴파일러를 사용하면 모든 모듈을 새 프로그램에 내장시킨 다음 표준 파이썬 모듈과 링크할 수 있습니다.</p>
<p>소스를 재귀적으로 검색하여 import 문(두 형식 모두)을 찾고 표준 파이썬 경로뿐만 아니라 소스 디렉터리에서 모듈을 찾습니다 (내장할 모듈을 위해). 그런 다음 파이썬으로 작성된 모듈의 바이트 코드를 C 코드 (marshal 모듈을 사용하여 코드 객체로 변환할 수 있는 배열 초기화기)로 바꾸고 프로그램에서 실제로 사용되는 내장 모듈만 포함하는 특별한 구성 파일을 만듭니다. 그런 다음 생성된 C 코드를 컴파일하고 이를 나머지 파이썬 인터프리터와 링크하여 스크립트와 똑같게 작동하는 자체 포함 바이너리를 형성합니다.</p>
<p>명백히, freeze는 C 컴파일러를 요구합니다. 그렇지 않은 다른 유틸리티가 몇 가지 있습니다. 그중 하나는 Thomas Heller의 py2exe(윈도우 전용)이고, 다음에서 찾을 수 있습니다.</p>
<blockquote>
<div><p><a class="reference external" href="http://www.py2exe.org/">http://www.py2exe.org/</a></p>
</div></blockquote>
<p>또 다른 도구는 Anthony Tuininga의 <a class="reference external" href="https://anthony-tuininga.github.io/cx_Freeze/">cx_Freeze</a>입니다.</p>
</div>
<div class="section" id="are-there-coding-standards-or-a-style-guide-for-python-programs">
<h3><a class="toc-backref" href="#id6">파이썬 프로그램을 위한 코딩 표준이나 스타일 지침서가 있습니까?</a><a class="headerlink" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" title="제목 주소">¶</a></h3>
<p>예. 표준 라이브러리 모듈에 요구되는 코딩 스타일은 <span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a>에서 설명합니다.</p>
</div>
</div>
<div class="section" id="core-language">
<h2><a class="toc-backref" href="#id7">핵심 언어</a><a class="headerlink" href="#core-language" title="제목 주소">¶</a></h2>
<div class="section" id="why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value">
<h3><a class="toc-backref" href="#id8">변수에 값이 있을 때 UnboundLocalError 가 발생하는 이유는 무엇입니까?</a><a class="headerlink" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" title="제목 주소">¶</a></h3>
<p>전에는 동작하던 코드에서 함수 본문 어딘가에 대입문을 추가했을 때 UnboundLocalError 가 발생하면 당황할 수 있습니다.</p>
<p>이 코드는:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>작동하지만, 이 코드는:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>UnboundLocalError 가 발생합니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">UnboundLocalError</span>: <span class="n">local variable &#39;x&#39; referenced before assignment</span>
</pre></div>
</div>
<p>이는 스코프에서 변수에 대입할 때, 해당 변수가 그 스코프에 대해 지역(local)이 되고 외부 스코프에서 비슷한 이름의 변수를 가리기 때문입니다. foo의 마지막 문장은 <code class="docutils literal notranslate"><span class="pre">x</span></code>에 새 값을 대입하므로, 컴파일러는 이 값을 지역 변수로 인식합니다. 결과적으로 앞의 <code class="docutils literal notranslate"><span class="pre">print(x)</span></code>가 초기화되지 않은 지역 변수를 인쇄하려고 할 때 에러가 발생합니다.</p>
<p>위의 예에서 변수를 전역(global)으로 선언하여 외부 스코프 변수에 액세스 할 수 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foobar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>이 명시적 선언은 (클래스와 인스턴스 변수의 표면적으로 유사한 상황과 달리) 실제로 외부 스코프에 있는 변수의 값을 수정하고 있음을 상기시키기 위해 필요합니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 키워드를 사용하여 중첩된 스코프에서 비슷한 일을 할 수 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>       <span class="k">nonlocal</span> <span class="n">x</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>       <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="n">bar</span><span class="p">()</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">10</span>
<span class="go">11</span>
</pre></div>
</div>
</div>
<div class="section" id="what-are-the-rules-for-local-and-global-variables-in-python">
<h3><a class="toc-backref" href="#id9">파이썬에서 지역과 전역 변수에 대한 규칙은 무엇입니까?</a><a class="headerlink" href="#what-are-the-rules-for-local-and-global-variables-in-python" title="제목 주소">¶</a></h3>
<p>파이썬에서, 함수 내에서 참조되기만 하는 변수는 묵시적으로 전역입니다. 변수가 함수 본문 내 어디에서건 값을 대입하면, 명시적으로 전역으로 선언되지 않는 한 지역으로 간주합니다.</p>
<p>처음에는 조금 의외지만, 잠시 생각해보면 이해가 됩니다. 한편으로, 대입된 변수에 <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a>을 요구하면 의도하지 않은 부작용에 대한 저지선을 제공합니다. 반면에, 모든 전역 참조에 <code class="docutils literal notranslate"><span class="pre">global</span></code>이 요구된다면, 항상 <code class="docutils literal notranslate"><span class="pre">global</span></code>을 사용하게 됩니다. 내장 함수나 임포트 한 모듈의 구성 요소에 대한 모든 참조를 전역으로 선언해야 합니다. 이 혼란은 부작용을 식별하기 위한 <code class="docutils literal notranslate"><span class="pre">global</span></code> 선언의 유용성을 무효로 합니다.</p>
</div>
<div class="section" id="why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result">
<h3><a class="toc-backref" href="#id10">다른 값으로 루프에서 정의된 람다는 왜 모두 같은 결과를 반환합니까?</a><a class="headerlink" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" title="제목 주소">¶</a></h3>
<p>for 루프를 사용하여 몇 가지 다른 람다(또는 일반 함수조차)를 정의한다고 가정하십시오, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">x**2</span></code>를 계산하는 5개의 람다가 포함된 리스트를 제공합니다. 호출되면, 각각 <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>, <code class="docutils literal notranslate"><span class="pre">9</span></code> 및 <code class="docutils literal notranslate"><span class="pre">16</span></code>을 반환할 것으로 예상할 수 있습니다. 그러나, 실제로 시도하면 모두 <code class="docutils literal notranslate"><span class="pre">16</span></code>을 반환한다는 것을 알 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>이는 <code class="docutils literal notranslate"><span class="pre">x</span></code>가 람다에 지역(local)이 아니라 외부 스코프에 정의되어 있기 때문에 발생하며, 람다가 호출될 때 액세스 됩니다 --- 정의될 때가 아닙니다. 루프의 끝에서, <code class="docutils literal notranslate"><span class="pre">x</span></code>의 값은 <code class="docutils literal notranslate"><span class="pre">4</span></code>이므로, 모든 함수는 이제 <code class="docutils literal notranslate"><span class="pre">4**2</span></code>, 즉 <code class="docutils literal notranslate"><span class="pre">16</span></code>을 반환합니다. <code class="docutils literal notranslate"><span class="pre">x</span></code>의 값을 변경하고 람다의 결과가 어떻게 변경되는지 봄으로써 이를 확인할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">64</span>
</pre></div>
</div>
<p>이를 피하려면, 람다에 대해 지역인 변수에 값을 저장하여, 전역 <code class="docutils literal notranslate"><span class="pre">x</span></code>의 값에 의존하지 않도록 할 필요가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">n=x</span></code>는 람다에 지역인 새 변수 <code class="docutils literal notranslate"><span class="pre">n</span></code>을 만들고, 루프의 해당 시점에서 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 같은 값을 갖도록 람다가 정의될 때 계산됩니다. 이는 <code class="docutils literal notranslate"><span class="pre">n</span></code>의 값이 첫 번째 람다에서 <code class="docutils literal notranslate"><span class="pre">0</span></code>, 두 번째에서 <code class="docutils literal notranslate"><span class="pre">1</span></code>, 세 번째에서 <code class="docutils literal notranslate"><span class="pre">2</span></code> 등이 됨을 의미합니다. 따라서 각 람다는 이제 올바른 결과를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>이 동작은 람다에만 국한된 것이 아니라 일반 함수에도 적용됩니다.</p>
</div>
<div class="section" id="how-do-i-share-global-variables-across-modules">
<h3><a class="toc-backref" href="#id11">모듈 간에 전역 변수를 공유하려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-do-i-share-global-variables-across-modules" title="제목 주소">¶</a></h3>
<p>단일 프로그램 내에서 모듈 간에 정보를 공유하는 규범적인 방법은 특별한 모듈(종종 config나 cfg라고 불립니다)을 만드는 것입니다. 응용 프로그램의 모든 모듈에서 config 모듈을 임포트 하기만 하면 됩니다; 그러면 모듈이 전역 이름으로 사용 가능해집니다. 각 모듈의 인스턴스는 오직 하나이기 때문에, 모듈 객체에 대한 변경 사항은 모든 곳에 반영됩니다. 예를 들면 다음과 같습니다:</p>
<p>config.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># &#39;x&#39; 구성 설정의 기본 값</span>
</pre></div>
</div>
<p>mod.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>main.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">mod</span>
<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>같은 이유로, 모듈을 사용하는 것도 싱글톤 디자인 패턴 구현을 위한 기초입니다.</p>
</div>
<div class="section" id="what-are-the-best-practices-for-using-import-in-a-module">
<h3><a class="toc-backref" href="#id12">모듈에서 임포트를 사용하는 &quot;모범 사례&quot;는 무엇입니까?</a><a class="headerlink" href="#what-are-the-best-practices-for-using-import-in-a-module" title="제목 주소">¶</a></h3>
<p>일반적으로, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modulename</span> <span class="pre">import</span> <span class="pre">*</span></code>를 사용하지 마십시오. 그렇게 하면 임포트 하는 곳의 이름 공간이 어수선해지고, 린터(linter)가 정의되지 않은 이름을 감지하기가 훨씬 어려워집니다.</p>
<p>파일 맨 위에서 모듈을 임포트 하십시오. 그렇게 하면 코드에 필요한 다른 모듈을 명확하게 하고 모듈 이름이 스코프에 있는지에 대한 질문을 피할 수 있습니다. 한 줄에 하나의 임포트를 사용하면 모듈 임포트를 쉽게 추가하고 삭제할 수 있지만, 한 줄에 여러 임포트를 사용하면 화면 공간을 덜 사용합니다.</p>
<p>다음 순서로 모듈을 임포트 하는 것이 좋습니다:</p>
<ol class="arabic simple">
<li><p>표준 라이브러리 모듈 -- 예를 들어 <code class="docutils literal notranslate"><span class="pre">sys</span></code>, <code class="docutils literal notranslate"><span class="pre">os</span></code>, <code class="docutils literal notranslate"><span class="pre">getopt</span></code>, <code class="docutils literal notranslate"><span class="pre">re</span></code></p></li>
<li><p>제삼자 라이브러리 모듈 (파이썬의 site-packages 디렉터리에 설치된 모든 것) -- 예를 들어 mx.DateTime, ZODB, PIL.Image 등.</p></li>
<li><p>내부에서 개발된 모듈</p></li>
</ol>
<p>순환 임포트 관련 문제를 피하고자 임포트를 함수나 클래스로 이동해야 하는 경우가 있습니다. Gordon McMillan은 다음과 같이 말했습니다:</p>
<blockquote>
<div><p>두 모듈 모두 &quot;import &lt;module&gt;&quot; 형식의 임포트를 사용하면 순환 임포트는 괜찮습니다. 두 번째 모듈이 첫 번째 모듈의 이름(name)을 붙잡으려고 하고 (&quot;from module import name&quot;) 임포트가 최상위 수준에 있으면 실패합니다. 첫 번째 모듈이 두 번째 모듈을 임포트 하는 중이라서 첫 번째 모듈에 있는 이름을 아직 사용할 수 없기 때문입니다.</p>
</div></blockquote>
<p>이 경우, 두 번째 모듈이 하나의 함수에서만 사용된다면, 임포트를 해당 함수로 쉽게 이동할 수 있습니다. 임포트가 호출될 때, 첫 번째 모듈의 초기화가 완료되었고, 두 번째 모듈은 임포트를 수행할 수 있습니다.</p>
<p>일부 모듈이 플랫폼 특정이면 임포트를 코드의 최상위 수준에서 다른 곳으로 이동해야 할 수도 있습니다. 이 경우, 파일 맨 위에서 모든 모듈을 임포트 하는 것이 가능하지 않을 수도 있습니다. 이 경우, 해당 플랫폼 특정 코드에서 올바른 모듈을 임포트 하는 것이 좋은 선택입니다.</p>
<p>순환 임포트를 피하거나 모듈의 초기화 시간을 줄이려는 등의 문제를 해결하는 데 필요할 때만, 함수 정의 내부와 같은 지역 스코프로 임포트를 옮기십시오. 이 기법은 프로그램 실행 방법에 따라 많은 임포트가 필요하지 않을 때 특히 유용합니다. 모듈이 해당 함수에서만 사용될 때 임포트를 함수로 옮기고 싶을 수도 있습니다. 모듈의 일회성 초기화 때문에 모듈을 처음 로드하는 데 비용이 많이들 수 있지만, 모듈을 여러 번 로드하는 것은 사실상 무료임에 유의하십시오, 두 번의 딕셔너리 조회만 발생합니다. 모듈 이름이 스코프를 벗어난 경우에도, 모듈은 아마도 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있을 겁니다.</p>
</div>
<div class="section" id="why-are-default-values-shared-between-objects">
<h3><a class="toc-backref" href="#id13">객체 간에 기본값이 공유되는 이유는 무엇입니까?</a><a class="headerlink" href="#why-are-default-values-shared-between-objects" title="제목 주소">¶</a></h3>
<p>이 유형의 버그는 흔히 신참 프로그래머들을 깨뭅니다. 이 함수를 생각해보십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>  <span class="c1"># 위험: 모든 호출이 한 딕셔너리에 대해 참조를 공유합니다</span>
    <span class="o">...</span> <span class="n">뭔가</span> <span class="n">계산합니다</span> <span class="o">...</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">mydict</span>
</pre></div>
</div>
<p>이 함수를 처음 호출하면, <code class="docutils literal notranslate"><span class="pre">mydict</span></code>에 단일 항목이 포함됩니다. 두 번째는, <code class="docutils literal notranslate"><span class="pre">foo()</span></code>가 실행되기 시작할 때, <code class="docutils literal notranslate"><span class="pre">mydict</span></code>가 이미 항목에 들어 있는 상태로 시작하기 때문에, <code class="docutils literal notranslate"><span class="pre">mydict</span></code>가 두 개의 항목을 포함합니다.</p>
<p>종종 함수 호출이 기본값으로 새 객체를 만들 것으로 기대합니다. 그렇게 되지 않습니다. 함수가 정의될 때, 기본값은 정확히 한 번 만들어집니다. 이 예제의 딕셔너리와 같이, 해당 객체가 변경되면, 함수에 대한 후속 호출은 이 변경된 객체를 참조합니다.</p>
<p>정의에 따라, 숫자, 문자열, 튜플 및 <code class="docutils literal notranslate"><span class="pre">None</span></code>과 같은 불변 객체는 변경에 안전합니다. 딕셔너리, 리스트 및 클래스 인스턴스와 같은 가변 객체를 변경하면 혼란스러울 수 있습니다.</p>
<p>이 기능으로 인해, 가변 객체를 기본값으로 사용하지 않는 것이 좋습니다. 대신, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 기본값으로 사용하고 함수 내부에서 매개변수가 <code class="docutils literal notranslate"><span class="pre">None</span></code>인지 확인한 다음 새 리스트/딕셔너리/무엇이든 새로 만드십시오. 예를 들어, 다음과 같이 쓰지 마십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>대신 이렇게 쓰십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mydict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># 지역 이름 공간에 새 딕셔너리를 만듭니다</span>
</pre></div>
</div>
<p>이 기능은 유용할 수 있습니다. 계산하는 데 시간이 걸리는 함수가 있을 때, 일반적인 기법은 각 함수 호출의 매개변수와 결괏값을 캐시하고, 같은 값이 다시 요청되면 캐시 된 값을 반환하는 것입니다. 이것을 &quot;memoizing&quot; 이라고 하며, 다음과 같이 구현할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 호출자는 두 개의 매개 변수만 제공할 수 있고 선택적으로 키워드로 _cache를 전달할 수 있습니다</span>
<span class="k">def</span> <span class="nf">expensive</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_cache</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span>

    <span class="c1"># 값을 계산합니다</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">비싼</span> <span class="n">계산</span> <span class="o">...</span>
    <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>           <span class="c1"># 결과를 캐시에 저장합니다</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>기본값 대신 딕셔너리를 포함하는 전역 변수를 사용할 수 있습니다; 취향의 문제입니다.</p>
</div>
<div class="section" id="how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another">
<h3><a class="toc-backref" href="#id14">한 함수에서 다른 함수로 선택적이나 키워드 매개변수를 전달하려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" title="제목 주소">¶</a></h3>
<p>함수의 매개변수 목록에 <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">**</span></code> 지정자를 사용하여 인자를 수집하십시오; 이것은 위치 인자를 튜플로, 키워드 인자를 딕셔너리로 제공합니다. 그런 다음 <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">**</span></code>를 사용하여 다른 함수를 호출할 때 이러한 인자를 전달할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-the-difference-between-arguments-and-parameters">
<span id="faq-argument-vs-parameter"></span><span id="index-1"></span><h3><a class="toc-backref" href="#id15">인자와 매개변수의 차이점은 무엇입니까?</a><a class="headerlink" href="#what-is-the-difference-between-arguments-and-parameters" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">매개변수</span></a>는 함수 정의에 나타나는 이름으로 정의되는 반면, <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">인자</span></a>는 함수를 호출할 때 실제로 함수에 전달되는 값입니다. 매개변수는 함수가 받아들일 수 있는 인자 형을 정의합니다. 예를 들어, 다음과 같은 함수 정의가 주어졌을 때:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><em>foo</em>, <em>bar</em> 및 <em>kwargs</em>는 <code class="docutils literal notranslate"><span class="pre">func</span></code>의 매개변수입니다. 그러나, <code class="docutils literal notranslate"><span class="pre">func</span></code>를 호출할 때, 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">314</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">somevar</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">42</span></code>, <code class="docutils literal notranslate"><span class="pre">314</span></code> 및 <code class="docutils literal notranslate"><span class="pre">somevar</span></code> 값은 인자입니다.</p>
</div>
<div class="section" id="why-did-changing-list-y-also-change-list-x">
<h3><a class="toc-backref" href="#id16">리스트 'y'를 변경할 때 리스트 'x'도 변경되는 이유는 무엇입니까?</a><a class="headerlink" href="#why-did-changing-list-y-also-change-list-x" title="제목 주소">¶</a></h3>
<p>다음과 같은 코드를 작성하면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[10]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">y</span></code>에 요소를 추가하면 <code class="docutils literal notranslate"><span class="pre">x</span></code>도 변경되는 이유가 궁금할 것입니다.</p>
<p>이 결과를 만드는 두 가지 요소가 있습니다:</p>
<ol class="arabic simple">
<li><p>변수는 단순히 객체를 가리키는 이름입니다. <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></code>를 수행하면 리스트의 사본을 만들지 않습니다 -- <code class="docutils literal notranslate"><span class="pre">x</span></code>가 참조하는 것과 같은 객체를 참조하는 새 변수 <code class="docutils literal notranslate"><span class="pre">y</span></code>를 만듭니다. 이는 하나의 객체(리스트)만 있고, <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span></code> 모두 그 객체를 참조함을 의미합니다.</p></li>
<li><p>리스트는 <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">가변</span></a>입니다, 내용을 변경할 수 있다는 뜻입니다.</p></li>
</ol>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>를 호출한 후, 가변 객체의 내용이 <code class="docutils literal notranslate"><span class="pre">[]</span></code>에서 <code class="docutils literal notranslate"><span class="pre">[10]</span></code> 으로 변경되었습니다. 두 변수가 모두 동일한 객체를 참조하기 때문에, 두 이름 중 어느 것을 사용하더라도 수정된 값 <code class="docutils literal notranslate"><span class="pre">[10]</span></code> 에 액세스합니다.</p>
<p>대신 불변 객체를 <code class="docutils literal notranslate"><span class="pre">x</span></code>에 대입하면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># int는 불변입니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 5는 변경할 수 없습니다, 여기에서 우리는 새 객체를 만들고 있습니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">5</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span></code>가 더는 같지 않다는 것을 알 수 있습니다. 이는 정수가 <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">불변</span></a>이기 때문이고, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>을 수행할 때 값을 증가시켜서 정수 <code class="docutils literal notranslate"><span class="pre">5</span></code>를 변경하는 것이 아닙니다; 대신 새 객체(정수 <code class="docutils literal notranslate"><span class="pre">6</span></code>)를 만들어 <code class="docutils literal notranslate"><span class="pre">x</span></code>에 대입합니다 (즉, <code class="docutils literal notranslate"><span class="pre">x</span></code>가 참조하는 객체를 바꿉니다). 이 대입 후에는 두 개의 객체(정수 <code class="docutils literal notranslate"><span class="pre">6</span></code>과 <code class="docutils literal notranslate"><span class="pre">5</span></code>)와 이를 참조하는 두 개의 변수를 갖게 됩니다 (<code class="docutils literal notranslate"><span class="pre">x</span></code>는 이제 <code class="docutils literal notranslate"><span class="pre">6</span></code>을 참조하지만, <code class="docutils literal notranslate"><span class="pre">y</span></code>는 여전히 <code class="docutils literal notranslate"><span class="pre">5</span></code>를 참조합니다).</p>
<p>일부 연산(예를 들어 <code class="docutils literal notranslate"><span class="pre">y.append(10)</span></code>과 <code class="docutils literal notranslate"><span class="pre">y.sort()</span></code>)은 객체를 변경하지만, 표면적으로 유사한 연산(예를 들어 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">[10]</span></code> 과 <code class="docutils literal notranslate"><span class="pre">sorted(y)</span></code>)은 새 객체를 만듭니다. 일반적으로 파이썬에서 (그리고 표준 라이브러리의 모든 경우에서) 객체를 변경하는 메서드는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하여 두 가지 유형의 연산이 혼동되지 않도록 합니다. 따라서 실수로 <code class="docutils literal notranslate"><span class="pre">y.sort()</span></code>라고 작성하고 <code class="docutils literal notranslate"><span class="pre">y</span></code>의 정렬된 사본을 얻을 수 있다고 생각하면, 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 얻어서 프로그램에서 쉽게 진단되는 에러가 발생하도록 합니다.</p>
<p>그러나, 같은 연산이 때때로 형에 따라 다른 동작을 갖는 한 가지 연산 클래스가 있습니다: 증분 대입 연산자. 예를 들어, <code class="docutils literal notranslate"><span class="pre">+=</span></code>는 리스트를 변경하지만, 튜플이나 정수는 변경하지 않습니다 (<code class="docutils literal notranslate"><span class="pre">a_list</span> <span class="pre">+=</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>은 <code class="docutils literal notranslate"><span class="pre">a_list.extend([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code>과 동등하고 <code class="docutils literal notranslate"><span class="pre">a_list</span></code>를  변경하지만, <code class="docutils literal notranslate"><span class="pre">some_tuple</span> <span class="pre">+=</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code>과 <code class="docutils literal notranslate"><span class="pre">some_int</span> <span class="pre">+=</span> <span class="pre">1</span></code>은 새 객체를 만듭니다).</p>
<p>달리 표현하면:</p>
<ul class="simple">
<li><p>가변 객체(<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 등)가 있으면, 일부 특정 연산을 사용하여 객체를 변경하면 해당 객체를 참조하는 모든 변수가 변경을 보게 됩니다.</p></li>
<li><p>불변 객체(<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 등)가 있으면, 이를 참조하는 모든 변수는 항상 같은 값을 보게 되지만, 해당 값을 새로운 값으로 변환하는 연산은 항상 새로운 객체를 반환합니다.</p></li>
</ul>
<p>두 변수가 같은 객체를 참조하는지를 알고 싶다면, <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 연산자나 내장 함수 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>를 사용할 수 있습니다.</p>
</div>
<div class="section" id="how-do-i-write-a-function-with-output-parameters-call-by-reference">
<h3><a class="toc-backref" href="#id17">출력 매개변수가 있는 함수를 작성하려면 어떻게 해야 합니까 (참조에 의한 호출)?</a><a class="headerlink" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" title="제목 주소">¶</a></h3>
<p>파이썬에서 인자는 대입으로 전달됨을 기억하십시오. 대입은 단지 객체에 대한 참조를 만들기 때문에, 호출자와 피호출자의 인자 이름 간에 에일리어스가 없고, 참조에 의한 호출도 없습니다. 여러 가지 방법으로 원하는 효과를 얻을 수 있습니다.</p>
<ol class="arabic">
<li><p>결과의 튜플을 반환하여:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># a와 b는 지역 이름입니다</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>              <span class="c1"># 새 객체로 대입합니다</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>            <span class="c1"># 새 값을 반환합니다</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(&#39;new-value&#39;, 100)</span>
</pre></div>
</div>
<p>이것은 거의 항상 가장 명확한 해법입니다.</p>
</li>
<li><p>전역 변수를 사용하여. 이것은 스레드 안전하지 않고, 권장하지 않습니다.</p></li>
<li><p>가변 (제자리에서 변경할 수 있는) 객체를 전달하여:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># &#39;a&#39; 는 가변 리스트를 참조합니다</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># 공유 객체를 변경합니다</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">[&#39;new-value&#39;, 100]</span>
</pre></div>
</div>
</li>
<li><p>변경되는 딕셔너리를 전달하여:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func3</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># args는 가변 딕셔너리입니다</span>
<span class="gp">... </span>    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># 제자리에서 변경합니다</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func3</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">{&#39;a&#39;: &#39;new-value&#39;, &#39;b&#39;: 100}</span>
</pre></div>
</div>
</li>
<li><p>또는 클래스 인스턴스에 값을 묶어서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Namespace</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func4</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># args는 가변 Namespace 입니다</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># 제자리에서 변경합니다</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func4</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: &#39;new-value&#39;, &#39;b&#39;: 100}</span>
</pre></div>
</div>
<p>이렇게 복잡하게 만들어야 할 좋은 이유는 거의 없습니다.</p>
</li>
</ol>
<p>최선의 선택은 여러 결과가 포함된 튜플을 반환하는 것입니다.</p>
</div>
<div class="section" id="how-do-you-make-a-higher-order-function-in-python">
<h3><a class="toc-backref" href="#id18">파이썬에서 고차 함수(higher order function)를 어떻게 만드나요?</a><a class="headerlink" href="#how-do-you-make-a-higher-order-function-in-python" title="제목 주소">¶</a></h3>
<p>두 가지 선택이 있습니다: 중첩된 스코프를 사용하거나 콜러블 객체를 사용할 수 있습니다. 예를 들어, 값 <code class="docutils literal notranslate"><span class="pre">a*x+b</span></code>를 계산하는 함수 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>를 반환하는 <code class="docutils literal notranslate"><span class="pre">linear(a,b)</span></code>를 정의하려고 한다고 가정하십시오. 중첩된 스코프를 사용해서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>또는 콜러블 객체를 사용해서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">linear</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>두 경우 모두,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">taxes</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">taxes(10e6)</span> <span class="pre">==</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">10e6</span> <span class="pre">+</span> <span class="pre">2</span></code>가 되도록 하는 콜러블 객체를 제공합니다.</p>
<p>콜러블 객체 접근 방식은 약간 느리고 코드가 약간 길어진다는 단점이 있습니다. 그러나, 콜러블 컬렉션은 상속을 통해 서명을 공유할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">exponential</span><span class="p">(</span><span class="n">linear</span><span class="p">):</span>
    <span class="c1"># __init__ inherited</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>객체는 여러 메서드의 상태를 캡슐화 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">counter</span><span class="p">:</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">down</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">set</span>
</pre></div>
</div>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">inc()</span></code>, <code class="docutils literal notranslate"><span class="pre">dec()</span></code> 및 <code class="docutils literal notranslate"><span class="pre">reset()</span></code>은 같은 계수 변수를 공유하는 함수처럼 작동합니다.</p>
</div>
<div class="section" id="how-do-i-copy-an-object-in-python">
<h3><a class="toc-backref" href="#id19">파이썬에서 객체를 어떻게 복사합니까?</a><a class="headerlink" href="#how-do-i-copy-an-object-in-python" title="제목 주소">¶</a></h3>
<p>일반적으로, 일반적일 때 <a class="reference internal" href="../library/copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a>나 <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>를 시도하십시오. 모든 객체를 복사할 수는 없지만, 대부분 가능합니다.</p>
<p>일부 객체는 더 쉽게 복사할 수 있습니다. 딕셔너리에는 <a class="reference internal" href="../library/stdtypes.html#dict.copy" title="dict.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> 메서드가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">newdict</span> <span class="o">=</span> <span class="n">olddict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>시퀀스는 슬라이싱으로 복사할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-find-the-methods-or-attributes-of-an-object">
<h3><a class="toc-backref" href="#id20">객체의 메서드나 어트리뷰트를 어떻게 찾을 수 있습니까?</a><a class="headerlink" href="#how-can-i-find-the-methods-or-attributes-of-an-object" title="제목 주소">¶</a></h3>
<p>사용자 정의 클래스의 인스턴스 x에 대해, <code class="docutils literal notranslate"><span class="pre">dir(x)</span></code>는 인스턴스 어트리뷰트와 메서드 및 해당 클래스에 의해 정의된 어트리뷰트를 포함하는 알파벳순의 이름 리스트를 반환합니다.</p>
</div>
<div class="section" id="how-can-my-code-discover-the-name-of-an-object">
<h3><a class="toc-backref" href="#id21">코드에서 객체 이름을 어떻게 찾을 수 있습니까?</a><a class="headerlink" href="#how-can-my-code-discover-the-name-of-an-object" title="제목 주소">¶</a></h3>
<p>일반적으로 말하자면, 객체에는 실제로 이름이 없기 때문에 그럴 수 없습니다. 기본적으로, 대입은 항상 이름을 값에 연결합니다; <code class="docutils literal notranslate"><span class="pre">def</span></code>와 <code class="docutils literal notranslate"><span class="pre">class</span></code> 문의 경우도 마찬가지이지만, 이 경우 값은 콜러블입니다. 다음 코드를 고려하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x16D07CC&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x16D07CC&gt;</span>
</pre></div>
</div>
<p>분명히 클래스는 이름이 있습니다: 설사 이것이 두 가지 이름에 연결되어 있고 이름 B를 통해 호출되었더라도 만들어진 인스턴스는 여전히 클래스 A의 인스턴스로 보고됩니다. 그러나, 두 이름이 같은 값에 연결되기 때문에, 인스턴스 이름이 a인지 b인지는 말할 수 없습니다.</p>
<p>일반적으로 말해 코드가 특정 값의 &quot;이름을 알아야&quot; 할 필요는 없습니다. 의도적으로 내성적인(introspective) 프로그램을 작성하지 않는 한, 이는 일반적으로 접근 방식의 변경이 도움이 될 수 있다는 신호입니다.</p>
<p>comp.lang.python에서, Fredrik Lundh는 언젠가 이 질문에 대해 훌륭한 비유를 했습니다:</p>
<blockquote>
<div><p>여러분이 현관에서 발견한 고양이의 이름을 얻는 것과 같은 방법: 고양이(객체) 자체는 여러분에게 자신의 이름을 말할 수 없고, 전혀 신경 쓰지도 않습니다 -- 따라서 그것이 어떻게 불리는지 알아내는 유일한 방법은 여러분 이웃 모두(이름 공간)에게 자신의 고양이(객체)인지 묻는 것입니다...</p>
<p>.... 여러 이름으로 알려져 있거나 전혀 이름이 없다는 것을 알게 되더라도 놀라지 마십시오!</p>
</div></blockquote>
</div>
<div class="section" id="what-s-up-with-the-comma-operator-s-precedence">
<h3><a class="toc-backref" href="#id22">쉼표 연산자의 우선순위는 어떻게 되나요?</a><a class="headerlink" href="#what-s-up-with-the-comma-operator-s-precedence" title="제목 주소">¶</a></h3>
<p>쉼표는 파이썬에서 연산자가 아닙니다. 이 세션을 고려하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
<span class="go">(False, &#39;a&#39;)</span>
</pre></div>
</div>
<p>쉼표는 연산자가 아니라 표현식 사이의 구분자이기 때문에 위는 다음과 같이 입력한 것처럼 평가됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="s2">&quot;a&quot;</span>
</pre></div>
</div>
<p>다음과 같이 평가되지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>다양한 대입 연산자(<code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">+=</span></code> 등)도 마찬가지입니다. 이들은 실제로 연산자가 아니라 대입 문의 문법 구분자입니다.</p>
</div>
<div class="section" id="is-there-an-equivalent-of-c-s-ternary-operator">
<h3><a class="toc-backref" href="#id23">C의 &quot;?:&quot; 삼항 연산자와 동등한 것이 있습니까?</a><a class="headerlink" href="#is-there-an-equivalent-of-c-s-ternary-operator" title="제목 주소">¶</a></h3>
<p>예, 있습니다. 문법은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="k">if</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span>
<span class="n">small</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>이 문법이 파이썬 2.5에서 소개되기 전에, 일반적인 관용구는 논리 연산자를 사용하는 것이었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="ow">and</span> <span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>
</pre></div>
</div>
<p>그러나, 이 관용구는 안전하지 않습니다. <em>on_true</em>가 거짓 불리언 값을 가질 때 잘못된 결과가 나올 수 있습니다. 따라서, 항상 <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">if</span> <span class="pre">...</span> <span class="pre">else</span> <span class="pre">...</span></code> 형식을 사용하는 것이 좋습니다.</p>
</div>
<div class="section" id="is-it-possible-to-write-obfuscated-one-liners-in-python">
<h3><a class="toc-backref" href="#id24">파이썬에서 난독화된 한 줄 코드를 작성할 수 있습니까?</a><a class="headerlink" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" title="제목 주소">¶</a></h3>
<p>예. 일반적으로 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> 내에 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>를 중첩하여 수행됩니다. Ulf Bartelt가 제공한, 다음 세 가지 예를 참조하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="c1"># 소수 &lt; 1000</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">*</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span>
<span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)))))</span>

<span class="c1"># 처음 열 개의 피보나치 숫자</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>

<span class="c1"># 망델브로 집합</span>
<span class="nb">print</span><span class="p">((</span><span class="k">lambda</span> <span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="p">,</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="p">,</span><span class="n">IM</span><span class="p">,</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span>
<span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="k">lambda</span> <span class="n">yc</span><span class="p">,</span><span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">IM</span><span class="p">,</span>
<span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">xc</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">yc</span><span class="o">=</span><span class="n">yc</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span>
<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="o">&gt;=</span><span class="mf">4.0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">xc</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">yc</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="nb">chr</span><span class="p">(</span>
<span class="mi">64</span><span class="o">+</span><span class="n">F</span><span class="p">(</span><span class="n">Ru</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Ro</span><span class="o">-</span><span class="n">Ru</span><span class="p">)</span><span class="o">/</span><span class="n">Sx</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sx</span><span class="p">))):</span><span class="n">L</span><span class="p">(</span><span class="n">Iu</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Io</span><span class="o">-</span><span class="n">Iu</span><span class="p">)</span><span class="o">/</span><span class="n">Sy</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sy</span>
<span class="p">))))(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">24</span><span class="p">))</span>
<span class="c1">#    \___ ___/  \___ ___/  |   |   |__ 화면의 줄 수</span>
<span class="c1">#        V          V      |   |______ 화면의 열 수</span>
<span class="c1">#        |          |      |__________ 최대 &quot;반복&quot;</span>
<span class="c1">#        |          |_________________ y 축의 범위</span>
<span class="c1">#        |____________________________ x 축의 범위</span>
</pre></div>
</div>
<p>집에서 이것을 시도하지 마십시오, 어린이들!</p>
</div>
<div class="section" id="what-does-the-slash-in-the-parameter-list-of-a-function-mean">
<span id="faq-positional-only-arguments"></span><h3><a class="toc-backref" href="#id25">함수의 매개변수 목록에서 슬래시(/)는 무엇을 의미합니까?</a><a class="headerlink" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" title="제목 주소">¶</a></h3>
<p>함수의 인자 목록에서 슬래시는 그 앞에 있는 매개변수가 위치 전용임을 나타냅니다. 위치 전용 매개변수는 외부에서 사용할 수 있는 이름이 없는 매개변수입니다. 위치 전용 매개변수를 받아들이는 함수를 호출하면, 인자는 해당 위치만을 기준으로 매개변수에 매핑됩니다. 예를 들어, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>는 위치 전용 매개변수를 받아들이는 함수입니다. 설명서는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="nb">divmod</span><span class="p">)</span>
<span class="go">Help on built-in function divmod in module builtins:</span>

<span class="go">divmod(x, y, /)</span>
<span class="go">    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.</span>
</pre></div>
</div>
<p>매개변수 목록 끝의 슬래시는 두 매개변수가 위치 전용임을 의미합니다. 따라서, 키워드 인자로 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>를 호출하면 에러가 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">divmod</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">divmod() takes no keyword arguments</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="numbers-and-strings">
<h2><a class="toc-backref" href="#id26">숫자와 문자열</a><a class="headerlink" href="#numbers-and-strings" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-specify-hexadecimal-and-octal-integers">
<h3><a class="toc-backref" href="#id27">16진수와 8진수 정수는 어떻게 지정합니까?</a><a class="headerlink" href="#how-do-i-specify-hexadecimal-and-octal-integers" title="제목 주소">¶</a></h3>
<p>8진수를 지정하려면, 8진수 값 앞에 0을 붙이고, 소문자나 대문자 &quot;o&quot;를 붙입니다. 예를 들어, 변수 &quot;a&quot;를 8진수 값 &quot;10&quot;(10진수 8)으로 설정하려면, 이렇게 입력하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mo">0o10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">8</span>
</pre></div>
</div>
<p>16진수도 쉽습니다. 16진수 앞에 0을 붙이고, 소문자나 대문자 &quot;x&quot;를 붙이기만 하면 됩니다. 16진 숫자는 소문자나 대문자로 지정할 수 있습니다. 예를 들어, 파이썬 인터프리터에서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xa5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">165</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mh">0XB2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">178</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-22-10-return-3">
<h3><a class="toc-backref" href="#id28">왜 -22 // 10 이 -3을 반환합니까?</a><a class="headerlink" href="#why-does-22-10-return-3" title="제목 주소">¶</a></h3>
<p>주로 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code>가 <code class="docutils literal notranslate"><span class="pre">j</span></code>와 같은 부호를 갖도록 하려는 것입니다. 여러분이 이것을 원하고, 다음과 같은 것도 원한다면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>정수 나누기는 floor를 반환해야 합니다. C 또한 이 항등식을 만족하도록 요구하고, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">//</span> <span class="pre">j</span></code>를 자르는(truncate) 컴파일러는 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code>가 <code class="docutils literal notranslate"><span class="pre">i</span></code> 와 같은 부호를 갖도록 할 필요가 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">j</span></code>가 음수인 경우 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code>에 대한 실제 사용 사례는 거의 없습니다. <code class="docutils literal notranslate"><span class="pre">j</span></code>가 양수이면, 많은 사례가 있으며, 사실상 모든 경우에 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code>가 <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>인 것이 더 유용합니다. 시계가 지금 10을 가리킨다면, 200시간 전에는 어디를 가리키겠습니까? <code class="docutils literal notranslate"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">2</span></code>가 유용합니다; <code class="docutils literal notranslate"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">-10</span></code>은 물기를 기다리는 버그입니다.</p>
</div>
<div class="section" id="how-do-i-convert-a-string-to-a-number">
<h3><a class="toc-backref" href="#id29">문자열을 숫자로 어떻게 변환합니까?</a><a class="headerlink" href="#how-do-i-convert-a-string-to-a-number" title="제목 주소">¶</a></h3>
<p>정수의 경우, 내장 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 형 생성자를 사용하십시오, 예를 들어 <code class="docutils literal notranslate"><span class="pre">int('144')</span> <span class="pre">==</span> <span class="pre">144</span></code>. 마찬가지로, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>는 부동 소수점으로 변환합니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">float('144')</span> <span class="pre">==</span> <span class="pre">144.0</span></code>.</p>
<p>기본적으로 이것은 숫자를 심진수로 해석합니다. 그래서 <code class="docutils literal notranslate"><span class="pre">int('0144')</span> <span class="pre">==</span> <span class="pre">144</span></code>는 참이고 <code class="docutils literal notranslate"><span class="pre">int('0x144')</span></code>는 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다. <code class="docutils literal notranslate"><span class="pre">int(string,</span> <span class="pre">base)</span></code>는 두 번째 선택적 인자로 변환에 사용할 진수(base)를 받아들여서, <code class="docutils literal notranslate"><span class="pre">int(</span> <span class="pre">'0x144',</span> <span class="pre">16)</span> <span class="pre">==</span> <span class="pre">324</span></code>입니다. base가 0으로 지정되면, 숫자는 파이썬의 규칙을 사용하여 해석됩니다: 선행 '0o'는 8진수를 나타내고, '0x'는 16진수를 나타냅니다.</p>
<p>필요한 것이 문자열을 숫자로 변환하는 것뿐이라면 내장 함수 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>을 사용하지 마십시오. <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>은 상당히 느리며 보안 위험을 초래할 수 있습니다: 누군가 원하지 않는 부작용이 있는 파이썬 표현식을 전달할 수 있습니다. 예를 들어, 누군가 여러분의 홈 디렉터리를 지우는 <code class="docutils literal notranslate"><span class="pre">__import__('os').system(&quot;rm</span> <span class="pre">-rf</span> <span class="pre">$HOME&quot;)</span></code>을 전달할 수 있습니다.</p>
<p><a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>은 또한 숫자를 파이썬 표현식으로 해석하는 효과가 있어서, 예를 들어 <code class="docutils literal notranslate"><span class="pre">eval('09')</span></code>는 파이썬이 ('0'을 제외한 )십진수에서 선행 '0'을 허용하지 않기 때문에 구문 에러가 발생합니다.</p>
</div>
<div class="section" id="how-do-i-convert-a-number-to-a-string">
<h3><a class="toc-backref" href="#id30">숫자를 문자열로 어떻게 변환합니까?</a><a class="headerlink" href="#how-do-i-convert-a-number-to-a-string" title="제목 주소">¶</a></h3>
<p>예를 들어 숫자 144를 문자열 '144'로 변환하려면, 내장형 생성자 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>을 사용하십시오. 16진수나 8진수 표현을 원하면, 내장 함수 <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a>나 <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>를 사용하십시오. 멋진 포매팅이 필요하면, <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a>과 <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">포맷 문자열 문법</span></a> 섹션을 참조하십시오, 예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;{:04d}&quot;.format(144)</span></code>는 <code class="docutils literal notranslate"><span class="pre">'0144'</span></code>를 산출하고 <code class="docutils literal notranslate"><span class="pre">&quot;{:.3f}&quot;.format(1.0/3.0)</span></code>은 <code class="docutils literal notranslate"><span class="pre">'0.333'</span></code>을 산출합니다.</p>
</div>
<div class="section" id="how-do-i-modify-a-string-in-place">
<h3><a class="toc-backref" href="#id31">제자리에서 문자열을 어떻게 수정합니까?</a><a class="headerlink" href="#how-do-i-modify-a-string-in-place" title="제목 주소">¶</a></h3>
<p>그럴 수 없습니다. 문자열은 불변이기 때문입니다. 대부분의 경우, 조립하려는 다양한 부분으로 새 문자열을 구성해야 합니다. 그러나 제자리에서 유니코드 데이터를 수정할 수 있는 객체가 필요하면, <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 객체나 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 모듈을 사용해보십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, world&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello, world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;there!&quot;</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello, there!&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(&#39;u&#39;, &#39;Hello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(&#39;u&#39;, &#39;yello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tounicode</span><span class="p">()</span>
<span class="go">&#39;yello, world&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-use-strings-to-call-functions-methods">
<h3><a class="toc-backref" href="#id32">문자열을 사용하여 어떻게 함수/메서드를 호출합니까?</a><a class="headerlink" href="#how-do-i-use-strings-to-call-functions-methods" title="제목 주소">¶</a></h3>
<p>다양한 기법이 있습니다.</p>
<ul>
<li><p>문자열을 함수로 매핑하는 딕셔너리를 사용하는 것이 가장 좋습니다. 이 기법의 주요 장점은 문자열이 함수 이름과 일치할 필요가 없다는 것입니다. 이것은 또한 case 구문을 흉내 내는 데 사용되는 기본 기법입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;go&#39;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>  <span class="c1"># 함수에 괄호가 빠진 것에 유의하십시오</span>

<span class="n">dispatch</span><span class="p">[</span><span class="n">get_input</span><span class="p">()]()</span>  <span class="c1"># 함수 호출을 위한 후행 괄호에 유의하십시오</span>
</pre></div>
</div>
</li>
<li><p>내장 함수 <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>을 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>은 클래스, 클래스 인스턴스, 모듈 등을 포함하는 모든 객체에서 작동함에 유의하십시오.</p>
<p>이것은 다음과 같이 표준 라이브러리의 여러 곳에서 사용됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">do_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">do_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">,</span> <span class="s1">&#39;do_&#39;</span> <span class="o">+</span> <span class="n">opname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>함수 이름을 해석(resolve)하려면 <a class="reference internal" href="../library/functions.html#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myFunc</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;myFunc&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">fname</span><span class="p">]</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings">
<h3><a class="toc-backref" href="#id33">문자열에서 후행 줄 바꿈을 제거하는 Perl의 chomp()와 동등한 것이 있습니까?</a><a class="headerlink" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">S.rstrip(&quot;\r\n&quot;)</span></code>을 사용하면 다른 후행 공백을 제거하지 않고 문자열 <code class="docutils literal notranslate"><span class="pre">S</span></code>의 끝에 있는 모든 줄 종결자를 제거 할 수 있습니다. 문자열 <code class="docutils literal notranslate"><span class="pre">S</span></code>가 끝에 빈 줄이 여러 개 붙어 한 줄 이상을 나타내면, 모든 빈 줄의 줄 종결자가 제거됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;line 1 </span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\r</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&#39;line 1 &#39;</span>
</pre></div>
</div>
<p>일반적으로 한 번에 한 줄씩 텍스트를 읽을 때만 필요하기 때문에, <code class="docutils literal notranslate"><span class="pre">S.rstrip()</span></code>을 이런 식으로 사용하면 잘 작동합니다.</p>
</div>
<div class="section" id="is-there-a-scanf-or-sscanf-equivalent">
<h3><a class="toc-backref" href="#id34">scanf()나 sscanf()에 해당하는 것이 있습니까?</a><a class="headerlink" href="#is-there-a-scanf-or-sscanf-equivalent" title="제목 주소">¶</a></h3>
<p>그런 식으로는 없습니다.</p>
<p>간단한 입력 구문 분석의 경우, 가장 쉬운 방법은 보통 문자열 객체의 <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> 메서드를 사용하여 줄을 공백으로 구분된 단어로 분할한 다음 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>나 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>를 사용하여 십진수 문자열을 숫자 값으로 변환하는 것입니다. <code class="docutils literal notranslate"><span class="pre">split()</span></code>는 선택적 &quot;sep&quot; 매개변수를 지원합니다. 이 매개변수는 줄이 공백 이외의 문자를 구분자로 사용하는 경우에 유용합니다.</p>
<p>더 복잡한 입력 구문 분석의 경우, 정규식은 C의 <code class="xref c c-func docutils literal notranslate"><span class="pre">sscanf()</span></code>보다 강력하며 작업에 더 적합합니다.</p>
</div>
<div class="section" id="what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean">
<h3><a class="toc-backref" href="#id35">'UnicodeDecodeError'나 'UnicodeEncodeError' 에러는 무엇을 의미합니까?</a><a class="headerlink" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">유니코드 HOWTO</span></a>를 참조하십시오.</p>
</div>
</div>
<div class="section" id="performance">
<h2><a class="toc-backref" href="#id36">성능</a><a class="headerlink" href="#performance" title="제목 주소">¶</a></h2>
<div class="section" id="my-program-is-too-slow-how-do-i-speed-it-up">
<h3><a class="toc-backref" href="#id37">내 프로그램이 너무 느립니다. 속도를 높이려면 어떻게 해야 합니까?</a><a class="headerlink" href="#my-program-is-too-slow-how-do-i-speed-it-up" title="제목 주소">¶</a></h3>
<p>그것은 일반적으로 힘든 일입니다. 먼저, 더 뛰어들기 전에 기억해야 할 사항이 있습니다:</p>
<ul class="simple">
<li><p>성능 특성은 파이썬 구현마다 다릅니다. 이 FAQ는 <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a>에 중점을 둡니다.</p></li>
<li><p>동작은 운영 체제마다 다를 수 있습니다, 특히 I/O 나 다중 스레드에 관해 이야기할 때 그렇습니다.</p></li>
<li><p>코드를 최적화하려고 시도하기 <em>전에</em> 프로그램에서 항상 핫스팟을 찾아야 합니다 (<a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> 모듈을 참조하십시오).</p></li>
<li><p>벤치마크 스크립트를 작성하면 개선 사항을 탐색할 때 빠르게 반복할 수 있습니다 (<a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> 모듈 참조).</p></li>
<li><p>정교한 최적화에 숨겨진 회귀(regressions)를 잠재적으로 도입하기 전에 (단위 테스트나 기타 기법을 통해) 우수한 코드 커버리지를 갖는 것이 좋습니다.</p></li>
</ul>
<p>이것을 전제로, 파이썬 코드 속도를 높이는 많은 트릭이 있습니다. 다음은 수용 가능한 성능 수준에 도달하기 위해 먼 길을 갈 때 도움이 되는 몇 가지 일반적인 원칙입니다:</p>
<ul class="simple">
<li><p>알고리즘을 더 빠르게 만들면 (또는 더 빠른 알고리즘으로 변경하면) 코드 전체에 미세 최적화 트릭을 뿌리는 것보다 훨씬 큰 이점을 얻을 수 있습니다.</p></li>
<li><p>올바른 데이터 구조를 사용하십시오. <a class="reference internal" href="../library/stdtypes.html#bltin-types"><span class="std std-ref">내장형</span></a>과 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈에 대한 설명서를 연구하십시오.</p></li>
<li><p>표준 라이브러리가 무언가를 하기 위한 프리미티브를 제공할 때, 여러분이 떠올린 다른 대안보다 빠를 가능성이 높습니다 (보장되지는 않습니다). 이것은 내장과 일부 확장형과 같이 C로 작성된 프리미티브의 경우에는 두 배로 그렇습니다. 예를 들어, 정렬하려면 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 내장 메서드나 관련 <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 함수를 사용하십시오 (그리고 약간 고급 사용법의 예는 <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">정렬 HOW TO</span></a>를 참조하십시오).</p></li>
<li><p>추상화는 간접(indirections)을 만드는 경향이 있고 인터프리터가 더 많은 일을 하도록 강요합니다. 간접의 수준이 유용한 작업의 양을 초과하면, 프로그램 속도가 느려집니다. 과도한 추상화를 피해야 합니다, 특히 작은 함수나 메서드의 형태에서 그렇습니다 (종종 가독성에도 해롭습니다).</p></li>
</ul>
<p>순수 파이썬이 허용할 수 있는 한도에 도달했다면, 더 멀리 갈 수 있는 도구가 있습니다. 예를 들어, <a class="reference external" href="http://cython.org">Cython</a>은 약간 수정된 버전의 파이썬 코드를 C 확장으로 컴파일 할 수 있으며, 여러 플랫폼에서 사용할 수 있습니다. Cython은 컴파일(과 선택적 형 어노테이션)을 활용하여 코드를 인터프리트 할 때 보다 훨씬 빠르게 만들 수 있습니다. C 프로그래밍 기술에 확신이 있다면, 직접 <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">C 확장 모듈을 작성할</span></a> 수도 있습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference external" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">성능 팁</a>에 할당된 위키 페이지.</p>
</div>
</div>
<div class="section" id="what-is-the-most-efficient-way-to-concatenate-many-strings-together">
<span id="efficient-string-concatenation"></span><h3><a class="toc-backref" href="#id38">많은 문자열을 함께 이어붙이는 가장 효율적인 방법은 무엇입니까?</a><a class="headerlink" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>과 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체는 불변이므로, 많은 문자열을 함께 이어붙이면 각 이어붙이기가 새 객체를 생성하기 때문에 비효율적입니다. 일반적일 때, 총 실행 시간 비용은 전체 문자열 길이의 제곱에 비례합니다.</p>
<p>많은 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체를 누적하기 위해, 권장되는 관용구는 객체를 리스트에 배치하고 마지막에 <a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a>을 호출하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">my_strings</span><span class="p">:</span>
    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
</pre></div>
</div>
<p>(또 다른 합리적으로 효율적인 관용구는 <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>를 사용하는 것입니다)</p>
<p>많은 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 누적하기 위해, 권장되는 관용구는 제자리 이어붙이기(<code class="docutils literal notranslate"><span class="pre">+=</span></code> 연산자)을 사용하여 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체를 확장하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">my_bytes_objects</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">b</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sequences-tuples-lists">
<h2><a class="toc-backref" href="#id39">시퀀스 (튜플/리스트)</a><a class="headerlink" href="#sequences-tuples-lists" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-convert-between-tuples-and-lists">
<h3><a class="toc-backref" href="#id40">튜플과 리스트를 어떻게 변환합니까?</a><a class="headerlink" href="#how-do-i-convert-between-tuples-and-lists" title="제목 주소">¶</a></h3>
<p>형 생성자 <code class="docutils literal notranslate"><span class="pre">tuple(seq)</span></code>는 임의의 시퀀스(실제로는, 모든 이터러블)를 같은 순서로 같은 항목을 가진 튜플로 변환합니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code>은 <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code>을 산출하고 <code class="docutils literal notranslate"><span class="pre">tuple('abc')</span></code>는 <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code>를 산출합니다. 인자가 튜플이면 사본을 만들지 않고 같은 객체를 반환하므로, 객체가 이미 튜플인지 확실하지 않을 때 <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code></a>을 호출하는 것이 저렴합니다.</p>
<p>형 생성자 <code class="docutils literal notranslate"><span class="pre">list(seq)</span></code>는 임의의 시퀀스나 이터러블을 같은 순서로 같은 항목이 있는 리스트로 변환합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">list((1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>은 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>을 산출하고 <code class="docutils literal notranslate"><span class="pre">list('abc')</span></code>는 <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code>를 산출합니다. 인자가 리스트이면, <code class="docutils literal notranslate"><span class="pre">seq[:]</span></code>와 같이 사본을 만듭니다.</p>
</div>
<div class="section" id="what-s-a-negative-index">
<h3><a class="toc-backref" href="#id41">음수 인덱스는 무엇입니까?</a><a class="headerlink" href="#what-s-a-negative-index" title="제목 주소">¶</a></h3>
<p>파이썬 시퀀스는 양수와 음수로 인덱싱됩니다. 양수의 경우 0은 첫 번째 인덱스이고 1은 두 번째 인덱스이고 이런 식으로 계속됩니다. 음수 인덱스의 경우 -1은 마지막 인덱스이고 -2는 끝에서 두 번째 인덱스이고 이런 식으로 계속됩니다. <code class="docutils literal notranslate"><span class="pre">seq[-n]</span></code>을 <code class="docutils literal notranslate"><span class="pre">seq[len(seq)-n]</span></code>과 같다고 생각하십시오.</p>
<p>음수 인덱스를 사용하면 매우 편리할 수 있습니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">S[:-1]</span></code>은 마지막 문자를 제외한 문자열의 모든 것인데, 문자열에서 후행 줄 바꿈을 제거하는 데 유용합니다.</p>
</div>
<div class="section" id="how-do-i-iterate-over-a-sequence-in-reverse-order">
<h3><a class="toc-backref" href="#id42">시퀀스를 역순으로 이터레이트 하려면 어떻게 합니까?</a><a class="headerlink" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장 함수를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># x로 뭔가 합니다 ...</span>
</pre></div>
</div>
<p>이것은 원본 시퀀스에는 영향을 미치지 않지만, 이터레이트 할 뒤집힌 순서의 새 사본을 만듭니다.</p>
</div>
<div class="section" id="how-do-you-remove-duplicates-from-a-list">
<h3><a class="toc-backref" href="#id43">리스트에서 중복을 어떻게 제거합니까?</a><a class="headerlink" href="#how-do-you-remove-duplicates-from-a-list" title="제목 주소">¶</a></h3>
<p>이 작업을 수행하는 여러 가지 방법에 대한 긴 논의는 파이썬 요리책을 참조하십시오:</p>
<blockquote>
<div><p><a class="reference external" href="https://code.activestate.com/recipes/52560/">https://code.activestate.com/recipes/52560/</a></p>
</div></blockquote>
<p>리스트 순서를 바꿔도 상관없다면, 리스트를 정렬한 다음 리스트 끝에서 스캔하면서 중복 항목을 삭제하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">mylist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>리스트의 모든 요소가 집합 키로 사용될 수 있다면 (즉, 모두 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a>이면) 이것이 종종 더 빠릅니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mylist</span><span class="p">))</span>
</pre></div>
</div>
<p>이것은 리스트를 집합으로 변환하여, 중복을 제거한 다음, 리스트로 되돌립니다.</p>
</div>
<div class="section" id="how-do-you-remove-multiple-items-from-a-list">
<h3><a class="toc-backref" href="#id44">리스트에서 여러 항목을 어떻게 제거합니까?</a><a class="headerlink" href="#how-do-you-remove-multiple-items-from-a-list" title="제목 주소">¶</a></h3>
<p>중복 제거와 마찬가지로, 삭제 조건을 사용하여 명시적으로 역순으로 이터레이션 하는 것도 한 가지 가능성입니다. 그러나, 묵시적이나 명시적 순방향 이터레이션으로 슬라이스 치환을 사용하기가 더 쉽고 빠릅니다. 다음은 세 가지 변형입니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">keep_function</span><span class="p">,</span> <span class="n">mylist</span><span class="p">)</span>
<span class="n">mylist</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">keep_condition</span><span class="p">)</span>
<span class="n">mylist</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">keep_condition</span><span class="p">]</span>
</pre></div>
</div>
<p>리스트 컴프리헨션이 아마 가장 빠릅니다.</p>
</div>
<div class="section" id="how-do-you-make-an-array-in-python">
<h3><a class="toc-backref" href="#id45">파이썬에서 어떻게 배열을 만드나요?</a><a class="headerlink" href="#how-do-you-make-an-array-in-python" title="제목 주소">¶</a></h3>
<p>리스트를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;this&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>리스트는 시간 복잡성 면에서 C나 파스칼(Pascal) 배열과 동등합니다; 가장 큰 차이점은 파이썬 리스트에 다양한 형의 객체가 포함될 수 있다는 것입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">array</span></code> 모듈은 또한 간결한 표현으로 고정형의 배열을 만드는 메서드를 제공하지만, 리스트보다 인덱싱하는 속도가 느립니다. 또한 Numeric 확장과 기타의 것들은 다양한 특성을 가진 배열과 유사한 구조를 정의함에 유의하십시오.</p>
<p>리스프(Lisp) 스타일의 링크드 리스트(linked lists)를 얻으려면, 튜플을 사용하여 콘스 셀(cons cells)을 흉내 낼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisp_list</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;like&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;this&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>가변성이 필요하면, 튜플 대신 리스트를 사용할 수 있습니다. 여기서 리스프 car에 해당하는 것은 <code class="docutils literal notranslate"><span class="pre">lisp_list[0]</span></code>이고 cdr에 해당하는 것은 <code class="docutils literal notranslate"><span class="pre">lisp_list[1]</span></code>입니다. 일반적으로 파이썬 리스트를 사용하는 것보다 속도가 느리기 때문에, 꼭 필요하다고 확신할 때만 이렇게 하십시오.</p>
</div>
<div class="section" id="how-do-i-create-a-multidimensional-list">
<span id="faq-multidimensional-list"></span><h3><a class="toc-backref" href="#id46">다차원 리스트를 어떻게 만듭니까?</a><a class="headerlink" href="#how-do-i-create-a-multidimensional-list" title="제목 주소">¶</a></h3>
<p>다음과 같이 다차원 배열을 만들려고 했을 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>인쇄하면 올바르게 보입니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[None, None], [None, None], [None, None]]</span>
</pre></div>
</div>
<p>그러나 값을 대입하면, 여러 위치에 나타납니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[5, None], [5, None], [5, None]]</span>
</pre></div>
</div>
<p>그 이유는 <code class="docutils literal notranslate"><span class="pre">*</span></code>로 리스트를 복제해도 복사본을 만들지 않고 기존 객체에 대한 참조만 만들기 때문입니다. <code class="docutils literal notranslate"><span class="pre">*3</span></code>은 길이 2의 같은 리스트에 대한 3개의 참조를 포함하는 리스트를 만듭니다. 한 행에 대한 변경 사항은 모든 행에 나타나는데, 거의 확실히 여러분이 원하는 것은 아닙니다.</p>
<p>제안된 방법은 원하는 길이의 리스트를 먼저 만든 다음 새로 만든 리스트로 각 요소를 채우는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p>그러면 길이가 2인 3개의 다른 리스트를 포함하는 리스트가 생성됩니다. 리스트 컴프리헨션도 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
<p>또는, 행렬 데이터형을 제공하는 확장을 사용할 수 있습니다. <a class="reference external" href="http://www.numpy.org/">NumPy</a>가 가장 잘 알려져 있습니다.</p>
</div>
<div class="section" id="how-do-i-apply-a-method-to-a-sequence-of-objects">
<h3><a class="toc-backref" href="#id47">객체의 시퀀스에 메서드를 어떻게 적용합니까?</a><a class="headerlink" href="#how-do-i-apply-a-method-to-a-sequence-of-objects" title="제목 주소">¶</a></h3>
<p>리스트 컴프리헨션을 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works">
<span id="faq-augmented-assignment-tuple-error"></span><h3><a class="toc-backref" href="#id48">덧셈은 작동하는데, 왜 a_tuple[i] += ['item']이 예외를 일으킵니까?</a><a class="headerlink" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" title="제목 주소">¶</a></h3>
<p>이는 증분 대입 연산자가 <em>대입</em> 연산자라는 사실과 파이썬에서 가변 객체와 불변 객체의 차이점이 결합하기 때문입니다.</p>
<p>이 논의는 증분 대입 연산자가 가변 객체를 가리키는 튜플의 요소에 적용될 때 일반적으로 적용되지만, 우리는 <code class="docutils literal notranslate"><span class="pre">list</span></code>와 <code class="docutils literal notranslate"><span class="pre">+=</span></code>를 예제로 사용합니다.</p>
<p>다음과 같이 작성한다면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>예외의 이유는 명확합니다: <code class="docutils literal notranslate"><span class="pre">1</span></code>이 <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span></code>이 가리키는 객체(<code class="docutils literal notranslate"><span class="pre">1</span></code>)에 더해져서, 결과 객체 <code class="docutils literal notranslate"><span class="pre">2</span></code>를 생성하지만, 계산 결과 <code class="docutils literal notranslate"><span class="pre">2</span></code>를 튜플의 요소 <code class="docutils literal notranslate"><span class="pre">0</span></code>에 대입하려고 하면, 튜플의 요소가 가리키는 것을 변경할 수 없기 때문에 에러가 발생합니다.</p>
<p>수면 아래에서, 이 증분 대입문이 하는 일은 대략 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>튜플은 불변이므로, 연산의 대입 부분이 에러를 발생시킵니다.</p>
<p>다음과 같이 작성하면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>예외는 조금 더 놀랍습니다, 더 놀라운 것은 에러가 있었지만 더하기가 동작했다는 사실입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[&#39;foo&#39;, &#39;item&#39;]</span>
</pre></div>
</div>
<p>왜 이런 일이 일어나는지 알려면, 이런 것들을 알 필요가 있습니다. (a) 객체가 <code class="docutils literal notranslate"><span class="pre">__iadd__</span></code> 매직 메서드를 구현하면, <code class="docutils literal notranslate"><span class="pre">+=</span></code> 증분 대입이 실행될 때 이것이 호출되고 반환 값이 대입문에 사용되는 값입니다; (b) 리스트의 경우, <code class="docutils literal notranslate"><span class="pre">__iadd__</span></code>는 리스트의 <code class="docutils literal notranslate"><span class="pre">extend</span></code>를 호출하고 리스트를 반환하는 것과 동등합니다. 이것이 우리가 리스트에서 <code class="docutils literal notranslate"><span class="pre">+=</span></code>가 <code class="docutils literal notranslate"><span class="pre">list.extend</span></code>의 &quot;줄임 표현&quot;이라고 말하는 이유입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>이것은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_list</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p>a_list가 가리키는 객체가 변경되었고, 변경된 객체에 대한 포인터가 다시 <code class="docutils literal notranslate"><span class="pre">a_list</span></code>에 대입됩니다. 대입의 최종 결과는 no-op인데, <code class="docutils literal notranslate"><span class="pre">a_list</span></code>가 이전에 가리키고 있던 것과 같은 객체에 대한 포인터이기 때문입니다, 하지만 대입은 여전히 일어납니다.</p>
<p>따라서, 우리의 튜플 예제에서 일어나는 일은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="s1">&#39;item&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__iadd__</span></code>는 성공하고, 따라서 리스트는 확장됩니다. 하지만, <code class="docutils literal notranslate"><span class="pre">result</span></code>가 <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span></code>이 이미 가리키는 것과 같은 객체를 가리키더라도, 튜플은 불변이므로, 최종 대입은 여전히 에러를 발생시킵니다.</p>
</div>
<div class="section" id="i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python">
<h3><a class="toc-backref" href="#id49">복잡한 정렬을 하고 싶습니다: 파이썬에서 Schwartzian 변환을 할 수 있습니까?</a><a class="headerlink" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" title="제목 주소">¶</a></h3>
<p>Perl 커뮤니티의 Randal Schwartz에 의한 이 기법은 리스트의 각 요소를 각 요소를 &quot;정렬 값&quot;에 매핑하는 메트릭으로 정렬합니다. 파이썬에서는, <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 메서드의 <code class="docutils literal notranslate"><span class="pre">key</span></code> 인자를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Isorted</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:]</span>
<span class="n">Isorted</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-sort-one-list-by-values-from-another-list">
<h3><a class="toc-backref" href="#id50">한 리스트를 다른 리스트의 값으로 정렬하려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-can-i-sort-one-list-by-values-from-another-list" title="제목 주소">¶</a></h3>
<p>그것들을 튜플의 이터레이터로 병합하고, 결과 리스트를 정렬한 다음, 원하는 요소를 선택하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;what&quot;</span><span class="p">,</span> <span class="s2">&quot;I&#39;m&quot;</span><span class="p">,</span> <span class="s2">&quot;sorting&quot;</span><span class="p">,</span> <span class="s2">&quot;by&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;something&quot;</span><span class="p">,</span> <span class="s2">&quot;else&quot;</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span>
<span class="go">[(&quot;I&#39;m&quot;, &#39;else&#39;), (&#39;by&#39;, &#39;sort&#39;), (&#39;sorting&#39;, &#39;to&#39;), (&#39;what&#39;, &#39;something&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">[&#39;else&#39;, &#39;sort&#39;, &#39;to&#39;, &#39;something&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="objects">
<h2><a class="toc-backref" href="#id51">객체</a><a class="headerlink" href="#objects" title="제목 주소">¶</a></h2>
<div class="section" id="what-is-a-class">
<h3><a class="toc-backref" href="#id52">클래스는 무엇입니까?</a><a class="headerlink" href="#what-is-a-class" title="제목 주소">¶</a></h3>
<p>클래스는 class 문을 실행하여 만든 특정 객체 형입니다. 클래스 객체는 인스턴스 객체를 만들기 위한 주형으로 사용되며, 데이터형과 관련된 데이터(어트리뷰트)와 코드(메서드)를 모두 내장합니다.</p>
<p>클래스는 베이스 클래스라고 하는 하나 이상의 다른 클래스를 기반으로 할 수 있습니다. 그러면 베이스 클래스의 어트리뷰트와 메서드를 상속합니다. 이는 상속을 통해 객체 모델을 점진적으로 재정의할 수 있도록 합니다. 우편함에 대한 기본 접근자 메서드를 제공하는 일반 <code class="docutils literal notranslate"><span class="pre">Mailbox</span></code> 클래스와 다양한 특정 사서함 형식을 처리하는 <code class="docutils literal notranslate"><span class="pre">MboxMailbox</span></code>, <code class="docutils literal notranslate"><span class="pre">MaildirMailbox</span></code>, <code class="docutils literal notranslate"><span class="pre">OutlookMailbox</span></code>와 같은 서브 클래스가 있을 수 있습니다.</p>
</div>
<div class="section" id="what-is-a-method">
<h3><a class="toc-backref" href="#id53">메서드는 무엇입니까?</a><a class="headerlink" href="#what-is-a-method" title="제목 주소">¶</a></h3>
<p>메서드는 일반적으로 <code class="docutils literal notranslate"><span class="pre">x.name(arguments...)</span></code>로 호출하는 어떤 객체 <code class="docutils literal notranslate"><span class="pre">x</span></code>의 함수입니다. 메서드는 클래스 정의 내에서 함수로 정의됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-self">
<h3><a class="toc-backref" href="#id54">self는 무엇입니까?</a><a class="headerlink" href="#what-is-self" title="제목 주소">¶</a></h3>
<p>self는 단지 메서드의 첫 번째 인자를 위한 관례적 이름입니다. <code class="docutils literal notranslate"><span class="pre">meth(self,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>로 정의된 메서드는 정의가 등장한 클래스의 어떤 인스턴스 <code class="docutils literal notranslate"><span class="pre">x</span></code>에 대해 <code class="docutils literal notranslate"><span class="pre">x.meth(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>로 호출되어야 합니다; 호출된 메서드는 <code class="docutils literal notranslate"><span class="pre">meth(x,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>처럼 호출되었다고 생각합니다.</p>
<p><a class="reference internal" href="design.html#why-self"><span class="std std-ref">메서드 정의와 호출에서 'self'를 명시적으로 사용해야 하는 이유는 무엇입니까?</span></a> 도 참조하십시오.</p>
</div>
<div class="section" id="how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it">
<h3><a class="toc-backref" href="#id55">객체가 주어진 클래스나 그 서브 클래스의 인스턴스인지 어떻게 확인합니까?</a><a class="headerlink" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" title="제목 주소">¶</a></h3>
<p>내장 함수 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">cls)</span></code>를 사용하십시오. 단일 클래스 대신 튜플을 제공하여 객체가 여러 클래스 중 어느 하나의 인스턴스인지를 확인할 수 있으며 (예를 들어 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">(class1,</span> <span class="pre">class2,</span> <span class="pre">...))</span></code>), 객체가 파이썬의 내장형 중 하나인지 확인할 수도 있습니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">str)</span></code>나 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">(int,</span> <span class="pre">float,</span> <span class="pre">complex))</span></code>).</p>
<p>대부분의 프로그램은 사용자 정의 클래스에서 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>를 자주 사용하지 않음에 유의하십시오. 클래스를 직접 개발하고 있다면, 더 적절한 객체 지향 스타일은 객체의 클래스를 확인하고 클래스에 따라 다른 작업을 수행하는 대신 특정 동작을 캡슐화하는 클래스의 메서드를 정의하는 것입니다. 예를 들어, 무언가를 수행하는 함수가 있다면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mailbox</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># 우편함을 검색하는 코드</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Document</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># 문서를 검색하는 코드</span>
    <span class="k">elif</span> <span class="o">...</span>
</pre></div>
</div>
<p>더 나은 접근법은 모든 클래스에서 <code class="docutils literal notranslate"><span class="pre">search()</span></code> 메서드를 정의하고 단지 그것을 호출하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mailbox</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># 우편함을 검색하는 코드</span>

<span class="k">class</span> <span class="nc">Document</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># 문서를 검색하는 코드</span>

<span class="n">obj</span><span class="o">.</span><span class="n">search</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-delegation">
<h3><a class="toc-backref" href="#id56">위임이란 무엇입니까?</a><a class="headerlink" href="#what-is-delegation" title="제목 주소">¶</a></h3>
<p>위임(delegation)은 객체 지향 기법(디자인 패턴이라고도 합니다)입니다. <code class="docutils literal notranslate"><span class="pre">x</span></code> 객체가 있고 메서드 중 하나의 동작을 변경하고 싶다고 가정해 봅시다. 변경하려는 메서드의 새로운 구현을 제공하고 다른 모든 메서드를 <code class="docutils literal notranslate"><span class="pre">x</span></code>의 해당 메서드에 위임하는 새 클래스를 만들 수 있습니다.</p>
<p>파이썬 프로그래머는 쉽게 위임을 구현할 수 있습니다. 예를 들어, 다음 클래스는 파일처럼 동작하지만, 기록되는 모든 데이터를 대문자로 변환하는 클래스를 구현합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperOut</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span> <span class="o">=</span> <span class="n">outfile</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">UpperOut</span></code> 클래스는 <code class="docutils literal notranslate"><span class="pre">write()</span></code> 메서드를 재정의하여 하부 <code class="docutils literal notranslate"><span class="pre">self._outfile.write()</span></code> 메서드를 호출하기 전에 인자 문자열을 대문자로 변환합니다. 다른 모든 메서드는 하부 <code class="docutils literal notranslate"><span class="pre">self._outfile</span></code> 객체에 위임됩니다. 위임은 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 메서드를 통해 수행됩니다; 어트리뷰트 액세스 제어에 대한 자세한 정보는 <a class="reference internal" href="../reference/datamodel.html#attribute-access"><span class="std std-ref">언어 레퍼런스</span></a>를 참조하십시오.</p>
<p>더 일반적이면 위임이 까다로울 수 있음에 유의하십시오. 어트리뷰트가 조회될 뿐만 아니라 설정되어야 할 때, 클래스는 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 메서드도 정의해야 하며, 아주 신중하게 수행되어야 합니다. <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>의 기본 구현은 다음과 대략 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>대부분의 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 구현은 무한 재귀를 일으키지 않고 self의 지역 상태를 저장하기 위해 <code class="docutils literal notranslate"><span class="pre">self.__dict__</span></code>를 수정해야 합니다.</p>
</div>
<div class="section" id="how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it">
<h3><a class="toc-backref" href="#id57">메서드를 재정의하는 파생 클래스에서 베이스 클래스에 정의된 해당 메서드를 어떻게 호출합니까?</a><a class="headerlink" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-overrides-it" title="제목 주소">¶</a></h3>
<p>내장 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 함수를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Derived</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
</pre></div>
</div>
<p>3.0 이전 버전의 경우, 클래식 클래스를 사용 중일 수 있습니다: <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Derived(Base):</span> <span class="pre">...</span></code>와 같은 클래스 정의의 경우 <code class="docutils literal notranslate"><span class="pre">Base</span></code>(또는 <code class="docutils literal notranslate"><span class="pre">Base</span></code>의 베이스 클래스 중 하나)에 정의된 <code class="docutils literal notranslate"><span class="pre">meth()</span></code> 메서드를 <code class="docutils literal notranslate"><span class="pre">Base.meth(self,</span> <span class="pre">arguments...)</span></code>로 호출할 수 있습니다. 여기서, <code class="docutils literal notranslate"><span class="pre">Base.meth</span></code>는 연결되지 않은 메서드이므로, <code class="docutils literal notranslate"><span class="pre">self</span></code> 인자를 제공해야 합니다.</p>
</div>
<div class="section" id="how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class">
<h3><a class="toc-backref" href="#id58">베이스 클래스를 쉽게 변경할 수 있도록 코드를 구성하려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" title="제목 주소">¶</a></h3>
<p>베이스 클래스를 별칭에 대입하고 별칭에서 파생할 수 있습니다. 그러면 별칭에 대입된 값만 변경하면 됩니다. 또한 이 트릭은 사용할 베이스 클래스를 동적으로 (예를 들어 자원의 가용성에 따라) 결정하려는 경우에도 유용합니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">BaseAlias</span> <span class="o">=</span> <span class="n">Base</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">BaseAlias</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-create-static-class-data-and-static-class-methods">
<h3><a class="toc-backref" href="#id59">정적 클래스 데이터와 정적 클래스 메서드를 만들려면 어떻게 해야 합니까?</a><a class="headerlink" href="#how-do-i-create-static-class-data-and-static-class-methods" title="제목 주소">¶</a></h3>
<p>(C++나 Java의 의미에서) 정적 데이터와 정적 메서드 모두 파이썬에서 지원됩니다.</p>
<p>정적 데이터의 경우, 단순히 클래스 어트리뷰트를 정의하십시오. 어트리뷰트에 새 값을 대입하려면, 대입에서 클래스 이름을 명시적으로 사용해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># C.__init__ 가 호출된 횟수</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">getcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>  <span class="c1"># 또는 return self.count</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">c</span></code> 자체나 <code class="docutils literal notranslate"><span class="pre">c.__class__</span></code>에서 <code class="docutils literal notranslate"><span class="pre">C</span></code>로 돌아가는 베이스 클래스 검색 경로에 놓인 일부 클래스에 의해 재정의되지 않는 한, <code class="docutils literal notranslate"><span class="pre">c.count</span></code>는 <code class="docutils literal notranslate"><span class="pre">isinstance(c,</span> <span class="pre">C)</span></code>가 성립하는 모든 <code class="docutils literal notranslate"><span class="pre">c</span></code>에 대해 <code class="docutils literal notranslate"><span class="pre">C.count</span></code>를 참조합니다.</p>
<p>주의: C의 메서드 내에서, <code class="docutils literal notranslate"><span class="pre">self.count</span> <span class="pre">=</span> <span class="pre">42</span></code>와 같은 대입은 <code class="docutils literal notranslate"><span class="pre">self</span></code>의 자체 딕셔너리에 &quot;count&quot;라는 새롭고 관련이 없는 인스턴스를 만듭니다. 클래스 정적 데이터 이름의 재연결은 항상 메서드 내부에 있는지에 관계없이 클래스를 지정해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">314</span>
</pre></div>
</div>
<p>정적 메서드도 가능합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c1"># &#39;self&#39; 매개변수가 없습니다!</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>그러나, 정적 메서드의 효과를 얻는 훨씬 간단한 방법은 단순한 모듈 수준 함수를 사용하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getcount</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>
</pre></div>
</div>
<p>여러분의 코드가 모듈 당 하나의 클래스 (또는 밀접하게 관련된 클래스 계층 구조)를 정의하도록 구조화되었다면, 이것이 원하는 캡슐화를 제공합니다.</p>
</div>
<div class="section" id="how-can-i-overload-constructors-or-methods-in-python">
<h3><a class="toc-backref" href="#id60">파이썬에서 생성자(또는 메서드)를 어떻게 재정의할 수 있습니까?</a><a class="headerlink" href="#how-can-i-overload-constructors-or-methods-in-python" title="제목 주소">¶</a></h3>
<p>이 답변은 실제로 모든 메서드에 적용되지만, 질문은 일반적으로 생성자 문맥에서 가장 먼저 나옵니다.</p>
<p>C++에서는 다음과 같이 작성합니다</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Argument is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>파이썬에서는 기본 인자를 사용하여 모든 경우를 다루는 단일 생성자를 작성해야 합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No arguments&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Argument is&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 완전히 동등하지는 않지만, 실제로는 아주 가깝습니다.</p>
<p>가변 길이 인자 목록을 시도할 수도 있습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>같은 접근법이 모든 메서드 정의에서도 동작합니다.</p>
</div>
<div class="section" id="i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam">
<h3><a class="toc-backref" href="#id61">__spam을 사용하려고 하는데 _SomeClassName__spam에 대한 에러가 발생합니다.</a><a class="headerlink" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" title="제목 주소">¶</a></h3>
<p>이중 선행 밑줄이 있는 변수 이름은 클래스 비공개(private) 변수를 정의하는 간단하지만, 효과적인 방법을 제공하기 위해 &quot;뒤섞입니다(mangled)&quot;. <code class="docutils literal notranslate"><span class="pre">__spam</span></code> 형식(적어도 두 개의 선행 밑줄, 최대 하나의 후행 밑줄)의 모든 식별자는 <code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code>으로 텍스트 대체되는데, 여기서 <code class="docutils literal notranslate"><span class="pre">classname</span></code> 은 모든 선행 밑줄이 제거된 현재 클래스 이름입니다.</p>
<p>이것은 비공개를 보장하지 않습니다: 외부 사용자는 여전히 &quot;_classname__spam&quot; 어트리뷰트에 의도적으로 액세스할 수 있으며, 비공개 값은 객체의 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>에 나타납니다. 많은 파이썬 프로그래머는 비공개 변수 이름을 전혀 사용하지 않습니다.</p>
</div>
<div class="section" id="my-class-defines-del-but-it-is-not-called-when-i-delete-the-object">
<h3><a class="toc-backref" href="#id62">내 클래스는 __del__을 정의하지만 객체를 삭제할 때 호출되지 않습니다.</a><a class="headerlink" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" title="제목 주소">¶</a></h3>
<p>몇 가지 가능한 이유가 있습니다.</p>
<p>del 문이 반드시 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>을 호출할 필요는 없습니다 -- 단순히 객체의 참조 횟수를 감소시키고, 이것이 0에 도달하면 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>이 호출됩니다.</p>
<p>여러분의 자료 구조가 순환 링크를 포함하면 (예를 들어 각 자식이 부모 참조를 갖고 각 부모에 자식 리스트가 있는 트리), 참조 횟수는 절대 0으로 돌아가지 않습니다. 가끔 파이썬은 이러한 순환을 감지하기 위해 알고리즘을 실행하지만, 가비지 수거기는 여러분의 자료 구조에 대한 마지막 참조가 사라진 후 얼마 후에 실행될 수 있어서, <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는 불편한 임의의 시간에 호출될 수 있습니다. 문제를 재현하려고 한다면 불편합니다. 더 나쁘게도, 객체의 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드가 실행되는 순서가 임의적입니다. <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a>를 실행하여 수거를 강제할 수 있지만, 객체가 수거되지 않는 병리학적 사례가 <em>있습니다</em>.</p>
<p>순환 수거기에도 불구하고, 완료될 때마다 호출될 객체의 명시적인 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 메서드를 정의하는 것이 좋습니다. 그러면 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 메서드는 서브 객체를 참조하는 어트리뷰트를 제거할 수 있습니다. <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>을 직접 호출하지 마십시오 -- <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">close()</span></code>를 호출해야 하며 <code class="docutils literal notranslate"><span class="pre">close()</span></code>는 같은 객체에 대해 두 번 이상 호출될 수 있어야 합니다.</p>
<p>순환 참조를 피하는 또 다른 방법은 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 모듈을 사용하는 것입니다. 이 모듈은 참조 횟수를 늘리지 않고 객체를 가리킬 수 있도록 합니다. 예를 들어, 트리 자료 구조는 부모와 형제 참조에 대해 약한 참조를 사용해야 합니다 (이런 것들이 필요하다면!).</p>
<p>마지막으로, <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드에서 예외가 발생하면, 경고 메시지가 <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>로 인쇄됩니다.</p>
</div>
<div class="section" id="how-do-i-get-a-list-of-all-instances-of-a-given-class">
<h3><a class="toc-backref" href="#id63">주어진 클래스의 모든 인스턴스 목록을 어떻게 얻습니까?</a><a class="headerlink" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" title="제목 주소">¶</a></h3>
<p>파이썬은 클래스(또는 내장형)의 모든 인스턴스를 추적하지 않습니다. 클래스 생성자가 각 인스턴스에 대한 약한 참조 리스트를 유지하여 모든 인스턴스를 추적하도록 프로그래밍 할 수 있습니다.</p>
</div>
<div class="section" id="why-does-the-result-of-id-appear-to-be-not-unique">
<h3><a class="toc-backref" href="#id64"><code class="docutils literal notranslate"><span class="pre">id()</span></code>의 결과가 고유하지 않은 것처럼 보이는 이유는 무엇입니까?</a><a class="headerlink" href="#why-does-the-result-of-id-appear-to-be-not-unique" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 내장은 객체 수명 동안 고유하도록 보장되는 정수를 반환합니다. CPython에서는 이것이 객체의 메모리 주소이므로, 객체가 메모리에서 삭제된 후 새로 만들어진 다음 객체가 메모리의 같은 위치에 할당되는 경우가 자주 발생합니다. 다음과 같이 예시할 수 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> 
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> 
<span class="go">13901272</span>
</pre></div>
</div>
<p>두 개의 id는 다른 정수 객체에 속하는데, <code class="docutils literal notranslate"><span class="pre">id()</span></code> 호출 실행 앞에 만들어지고, 호출 직후 삭제됩니다. id를 검사하려는 객체가 여전히 살아 있도록 하려면, 그 객체에 대한 다른 참조를 만드십시오:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> 
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> 
<span class="go">13891296</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="modules">
<h2><a class="toc-backref" href="#id65">모듈</a><a class="headerlink" href="#modules" title="제목 주소">¶</a></h2>
<div class="section" id="how-do-i-create-a-pyc-file">
<h3><a class="toc-backref" href="#id66">.pyc 파일을 어떻게 만듭니까?</a><a class="headerlink" href="#how-do-i-create-a-pyc-file" title="제목 주소">¶</a></h3>
<p>모듈이 처음 임포트 될 때 (또는 현재 컴파일된 파일이 만들어진 후 소스 파일이 변경되었을 때) 컴파일된 코드를 포함하는 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일은 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 파일을 포함하는 디렉터리의 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 서브 디렉터리에 만들어져야 합니다. <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일은 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 파일과 같은 이름으로 시작하고, <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>로 끝나며, 파일을 만든 특정 <code class="docutils literal notranslate"><span class="pre">python</span></code> 바이너리 파일에 종속되는 중간 구성 요소를 갖는 파일명을 갖습니다. (자세한 내용은 <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>을 참조하십시오.)</p>
<p><code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일이 만들어지지 않을 수 있는 한 가지 이유는 소스 파일이 포함된 디렉터리의 권한 문제입니다. 즉, <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 서브 디렉터리를 만들 수 없다는 뜻입니다. 예를 들어, 한 사용자로 개발했지만 다른 사용자로 실행하는 경우에 이런 일이 일어날 수 있습니다, 가령 웹 서버로 테스트하고 있을 때입니다.</p>
<p><span class="target" id="index-9"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 환경 변수가 설정되어 있지 않은 한, 모듈을 임포트 하고 파이썬이 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 서브 디렉터리를 만들고 컴파일된 모듈을 그 서브 디렉터리에 쓸 수 있는 능력(권한, 여유 공간 등)이 있으면 .pyc 파일의 생성은 자동입니다.</p>
<p>최상위 스크립트에서 파이썬을 실행하는 것은 임포트로 간주하지 않으며 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>가 만들어지지 않습니다. 예를 들어, 다른 모듈 <code class="docutils literal notranslate"><span class="pre">xyz.py</span></code>를 임포트 하는 최상위 모듈 <code class="docutils literal notranslate"><span class="pre">foo.py</span></code>가 있을 때, (<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">foo.py</span></code>를 셸 명령으로 입력하여) <code class="docutils literal notranslate"><span class="pre">foo</span></code>를 실행하면, <code class="docutils literal notranslate"><span class="pre">xyz</span></code>를 임포트 하기 때문에 <code class="docutils literal notranslate"><span class="pre">xyz</span></code>에 대해 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>가 만들어지지만, <code class="docutils literal notranslate"><span class="pre">foo.py</span></code>를 임포트 하지 않기 때문에 <code class="docutils literal notranslate"><span class="pre">foo</span></code>에 대해서는 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일이 만들어지지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">foo</span></code>에 대한 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 만들 필요가 있으면 -- 즉, 임포트 되지 않는 모듈에 대한 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 만들려면 -- <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a>과 <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> 모듈을 사용할 수 있습니다.</p>
<p><a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a> 모듈은 임의의 모듈을 수동으로 컴파일할 수 있습니다. 한 가지 방법은 해당 모듈에서 <code class="docutils literal notranslate"><span class="pre">compile()</span></code> 함수를 대화식으로 사용하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_compile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">py_compile</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;foo.py&#39;</span><span class="p">)</span>                 
</pre></div>
</div>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>를 <code class="docutils literal notranslate"><span class="pre">foo.py</span></code>와 같은 위치에 있는 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 서브 디렉터리에 기록합니다 (또는 선택적 매개변수 <code class="docutils literal notranslate"><span class="pre">cfile</span></code>로 이를 재정의할 수 있습니다).</p>
<p><a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> 모듈을 사용하여 디렉터리의 모든 파일을 자동으로 컴파일할 수도 있습니다. <code class="docutils literal notranslate"><span class="pre">compileall.py</span></code>를 실행하고 컴파일할 파이썬 파일이 포함된 디렉터리의 경로를 제공하여 셸 프롬프트에서 이를 수행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">compileall</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-i-find-the-current-module-name">
<h3><a class="toc-backref" href="#id67">현재 모듈 이름을 어떻게 찾습니까?</a><a class="headerlink" href="#how-do-i-find-the-current-module-name" title="제목 주소">¶</a></h3>
<p>모듈은 사전 정의된 전역 변수 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>을 봄으로써 모듈 자신의 이름을 찾을 수 있습니다. 값이 <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code>이면, 프로그램이 스크립트로 실행 중입니다. 일반적으로 모듈을 임포트 해서 사용하는 많은 모듈은 명령 줄 인터페이스나 자체 테스트를 제공하며, <code class="docutils literal notranslate"><span class="pre">__name__</span></code>을 확인한 후에 만 이 코드를 실행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running test...&#39;</span><span class="p">)</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="how-can-i-have-modules-that-mutually-import-each-other">
<h3><a class="toc-backref" href="#id68">서로 임포트 하는 모듈을 어떻게 만들 수 있습니까?</a><a class="headerlink" href="#how-can-i-have-modules-that-mutually-import-each-other" title="제목 주소">¶</a></h3>
<p>다음 모듈이 있다고 가정하십시오:</p>
<p>foo.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bar</span> <span class="k">import</span> <span class="n">bar_var</span>
<span class="n">foo_var</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>bar.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">foo</span> <span class="k">import</span> <span class="n">foo_var</span>
<span class="n">bar_var</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>문제는 인터프리터가 다음 단계를 수행한다는 것입니다:</p>
<ul class="simple">
<li><p>main이 foo를 임포트 합니다</p></li>
<li><p>foo에 대한 빈 전역이 만들어집니다</p></li>
<li><p>foo가 컴파일되고 실행되기 시작합니다</p></li>
<li><p>foo가 bar를 임포트 합니다</p></li>
<li><p>bar에 대한 빈 전역이 만들어집니다</p></li>
<li><p>바가 컴파일되고 실행되기 시작합니다</p></li>
<li><p>bar가 foo를 임포트 합니다 (이미 foo라는 모듈이 있어서 no-op입니다)</p></li>
<li><p>bar.foo_var = foo.foo_var</p></li>
</ul>
<p>마지막 단계가 실패합니다. 파이썬이 아직 <code class="docutils literal notranslate"><span class="pre">foo</span></code>를 인터프리트 하는 것을 완료하지 않았고 <code class="docutils literal notranslate"><span class="pre">foo</span></code>의 전역 기호 딕셔너리가 여전히 비어 있기 때문입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo</span></code>를 사용하고 전역 코드에서 <code class="docutils literal notranslate"><span class="pre">foo.foo_var</span></code>에 액세스하려고 할 때도 같은 일이 일어납니다.</p>
<p>이 문제에 대해 가능한 (최소한) 세 가지 해결 방법이 있습니다.</p>
<p>Guido van Rossum은 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">&lt;module&gt;</span> <span class="pre">import</span> <span class="pre">...</span></code>을 아예 사용하지 말고, 모든 코드를 함수 내에 배치할 것을 권장합니다. 전역 변수와 클래스 변수의 초기화는 상수나 내장 함수만 사용해야 합니다. 이것은 임포트 된 모듈의 모든 것이 <code class="docutils literal notranslate"><span class="pre">&lt;module&gt;.&lt;name&gt;</span></code>으로 참조됨을 의미합니다.</p>
<p>Jim Roskind는 각 모듈에서 다음 순서로 단계를 수행할 것을 제안합니다:</p>
<ul class="simple">
<li><p>내보내기 (전역, 함수 및 베이스 클래스를 임포트 할 필요가 없는 클래스)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span></code> 문</p></li>
<li><p>활성 코드 (임포트 된 값에서 초기화된 전역 포함).</p></li>
</ul>
<p>van Rossum은 임포트가 이상한 곳에 나타나기 때문에 이 방법을 많이 좋아하지 않지만, 작동합니다.</p>
<p>Matthias Urlichs는 처음부터 재귀 임포트가 필요하지 않도록 코드를 재구성할 것을 권합니다.</p>
<p>이 해결 방법들은 상호 배타적이지 않습니다.</p>
</div>
<div class="section" id="import-x-y-z-returns-module-x-how-do-i-get-z">
<h3><a class="toc-backref" href="#id69">__import__('x.y.z')는 &lt;module 'x'&gt;를 반환합니다; z를 어떻게 얻습니까?</a><a class="headerlink" href="#import-x-y-z-returns-module-x-how-do-i-get-z" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a>의 편의 함수 <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>을 대신 사용하는 곳을 고려하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;x.y.z&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen">
<h3><a class="toc-backref" href="#id70">임포트 된 모듈을 편집하고 다시 임포트 할 때, 변경 사항이 표시되지 않습니다. 왜 이런 일이 발생합니까?</a><a class="headerlink" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" title="제목 주소">¶</a></h3>
<p>효율성뿐만 아니라 일관성의 이유로, 파이썬은 모듈을 처음 임포트 할 때만 모듈 파일을 읽습니다. 그렇지 않으면, 각 모듈이 같은 기본 모듈을 임포트 하는 많은 모듈로 구성된 프로그램에서, 기본 모듈을 여러 번 구문 분석하고 다시 구문 분석하게 됩니다. 변경된 모듈을 강제로 다시 읽으려면, 다음과 같이 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">modname</span>
<span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>
</pre></div>
</div>
<p>경고: 이 기법은 100% 확실하지 않습니다. 특히, 다음과 같은 문장을 포함하는 모듈은</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">modname</span> <span class="k">import</span> <span class="n">some_objects</span>
</pre></div>
</div>
<p>임포트 된 객체의 이전 버전으로 계속 작업합니다. 모듈에 클래스 정의가 포함되면, 새 클래스 정의를 사용하도록 기존 클래스 인스턴스가 갱신되지 <em>않습니다</em>. 이것은 다음과 같은 역설적인 동작으로 이어집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>                <span class="c1"># C의 인스턴스를 만듭니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="go">&lt;module &#39;cls&#39; from &#39;cls.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>       <span class="c1"># isinstance가 거짓이라고?!?</span>
<span class="go">False</span>
</pre></div>
</div>
<p>클래스 객체의 &quot;아이덴티티&quot;를 인쇄하면 문제의 본질이 분명해집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
<span class="go">&#39;0x7352a0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">))</span>
<span class="go">&#39;0x4198d0&#39;</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">프로그래밍 FAQ</a><ul>
<li><a class="reference internal" href="#general-questions">일반적인 질문</a></li>
<li><a class="reference internal" href="#core-language">핵심 언어</a></li>
<li><a class="reference internal" href="#numbers-and-strings">숫자와 문자열</a></li>
<li><a class="reference internal" href="#performance">성능</a></li>
<li><a class="reference internal" href="#sequences-tuples-lists">시퀀스 (튜플/리스트)</a></li>
<li><a class="reference internal" href="#objects">객체</a></li>
<li><a class="reference internal" href="#modules">모듈</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="general.html"
                        title="이전 장">일반적인 파이썬 FAQ</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="design.html"
                        title="다음 장">설계와 역사 FAQ</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="design.html" title="설계와 역사 FAQ"
             >다음</a> |</li>
        <li class="right" >
          <a href="general.html" title="일반적인 파이썬 FAQ"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 자주 나오는 질문들</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>