
.. _lexical:

****************
Lexical analysis
****************

.. index:: lexical analysis, parser, token

A Python program is read by a *parser*.  Input to the parser is a stream of
*tokens*, generated by the *lexical analyzer*.  This chapter describes how the
lexical analyzer breaks a file into tokens.

.. admonition:: flowdas

   구문 분석기가 만들어내는 토큰들의 목록은 :mod:`token` 모듈에서 제공됩니다. :mod:`tokenize` 모듈로 파이썬 소스 파일의 구문 분석을
   수행할 수도 있습니다.

Python reads program text as Unicode code points; the encoding of a source file
can be given by an encoding declaration and defaults to UTF-8, see :pep:`3120`
for details.  If the source file cannot be decoded, a :exc:`SyntaxError` is
raised.


.. _line-structure:

Line structure
==============

.. index:: line structure

A Python program is divided into a number of *logical lines*.


.. _logical-lines:

Logical lines
-------------

.. index:: logical line, physical line, line joining, NEWLINE token

The end of a logical line is represented by the token NEWLINE.  Statements
cannot cross logical line boundaries except where NEWLINE is allowed by the
syntax (e.g., between statements in compound statements). A logical line is
constructed from one or more *physical lines* by following the explicit or
implicit *line joining* rules.

.. admonition:: flowdas

   편집기 상에서 여러 줄로 표현된 텍스트가, 구문 분석 과정에서 하나의 논리적인 줄로 합쳐질 수 있습니다.
   이렇게 물리적인 줄이 논리적인 줄로 합쳐지는 규칙은 :ref:`explicit-joining` 과 :ref:`implicit-joining` 에서 설명합니다.
   구문 분석의 결과로 텍스트는 일련의 토큰들로 변환되는데, 논리적인 줄의 끝을 나타내는 토큰이 NEWLINE 입니다. 이 후의 단계에서는
   논리적인 줄만이 사용됩니다. ``if`` 문이나 ``for`` 문과 같은 복합문들은 여러개의 논리적인 줄로 구성될 수 있지만,
   단순문은 하나의 논리적인 줄로만 구성됩니다.

.. _physical-lines:

Physical lines
--------------

A physical line is a sequence of characters terminated by an end-of-line
sequence.  In source files and strings, any of the standard platform line
termination sequences can be used - the Unix form using ASCII LF (linefeed),
the Windows form using the ASCII sequence CR LF (return followed by linefeed),
or the old Macintosh form using the ASCII CR (return) character.  All of these
forms can be used equally, regardless of platform. The end of input also serves
as an implicit terminator for the final physical line.

.. admonition:: flowdas

   줄의 끝이 여러개의 문자로 표현될 수 있기 때문에 시퀀스라고 표현하고 있습니다. 가령 윈도우에서는 CR 과 LF 두 문자를
   연속으로 붙여서 줄의 끝을 표현합니다. 하지만 파이썬은 현재 사용되고 있는 플랫폼에 관계 없이 세가지 형태를 모두 줄의
   끝으로 인식합니다. 이 때문에 어떤 플랫폼에서 소스 파일을 편집했는지에 관계없이 모든 플랫폼에서 실행될 수 있습니다.

When embedding Python, source code strings should be passed to Python APIs using
the standard C conventions for newline characters (the ``\n`` character,
representing ASCII LF, is the line terminator).

.. admonition:: flowdas

   파이썬을 내장한다는 것은, :ref:`extending-index` 에서 설명하는 방법으로 별도의 응용프로그램에 파이썬 인터프리터를
   내장시킨다는 뜻입니다. 이 경우 :c:func:`PyRun_SimpleString` 와 같은 API 를 사용해서 파이썬 코드를 실행하는데,
   소스 파일에 등장하는 LF, CR LF, CR 들을 모두 ``\n`` 로 변환해서 전달해야한다는 뜻입니다.

.. _comments:

Comments
--------

.. index:: comment, hash character

A comment starts with a hash character (``#``) that is not part of a string
literal, and ends at the end of the physical line.  A comment signifies the end
of the logical line unless the implicit line joining rules are invoked. Comments
are ignored by the syntax; they are not tokens.


.. _encodings:

Encoding declarations
---------------------

.. index:: source character set, encoding declarations (source file)

If a comment in the first or second line of the Python script matches the
regular expression ``coding[=:]\s*([-\w.]+)``, this comment is processed as an
encoding declaration; the first group of this expression names the encoding of
the source code file. The encoding declaration must appear on a line of its
own. If it is the second line, the first line must also be a comment-only line.
The recommended forms of an encoding expression are ::

   # -*- coding: <encoding-name> -*-

which is recognized also by GNU Emacs, and ::

   # vim:fileencoding=<encoding-name>

which is recognized by Bram Moolenaar's VIM.

.. admonition:: flowdas

   주석이 이 정규식과 일치하는 부분을 포함하고 있기만 하면 됩니다. 널리 사용되는 두 편집기와 호환되게 만드는 영리한 정규식입니다.
   이 정규식의 ``([-\w.]+)`` 와 매치되는 부분에서 인코딩 이름을 추출합니다.

If no encoding declaration is found, the default encoding is UTF-8.  In
addition, if the first bytes of the file are the UTF-8 byte-order mark
(``b'\xef\xbb\xbf'``), the declared file encoding is UTF-8 (this is supported,
among others, by Microsoft's :program:`notepad`).

.. admonition:: flowdas

   BOM (Byte Order Mark) 은, 유니코드로 인코딩된 파일이 어떤 형식으로 기록되어 있는지를 표시하기 위해
   파일의 처음에 삽입하는 표식입니다. 유니코드는 UTF-8 외에도 여러가지 방식으로 표현될 수 있는데,
   이 중에는 UTF-8 와는 달리, 기록되는 값이 어떤 바이트 순서를 갖느냐가 지정될 필요가 있는 것들이 있습니다.
   가령 UTF-16 은 리틀 엔디언 (Little-endian) 과 빅 엔디언 (Big-endian) 두가지 방식으로 기록될 수 있는데,
   각각 ``b'\xff\xfe'`` 와 ``b'\xfe\xff'`` 라는 BOM 으로 이 중 어떤 것을 사용하고 있는지 표시할 수 있습니다.
   파이썬 파서는 UTF-8 이외의 BOM 은 지원하지 않습니다. (즉 UTF-8 이외의 BOM 은 BOM 으로 인식하지 않고,
   구문 분석기의 입력으로 들어가기 때문에 결국 :exc:`SyntaxError` 를 일으킵니다.)

.. admonition:: flowdas

   BOM 과 인코딩 선언을 동시에 사용하고, 둘이 서로 다른 주장을 하면 :exc:`SyntaxError` 를 일으킵니다.
   하지만 같은 주장을 하는 경우도, 인코딩 이름으로 ``utf-8`` 이 아니라 ``utf8`` 같은 별칭을 사용하면
   :exc:`SyntaxError` 를 일으키는데, 이 경우는 버그로 보아도 무방할듯합니다.

If an encoding is declared, the encoding name must be recognized by Python. The
encoding is used for all lexical analysis, including string literals, comments
and identifiers.

.. XXX there should be a list of supported encodings.

.. admonition:: flowdas

   파이썬이 인식할 수 있는 인코딩 이름은 표준 라이브러리의 :mod:`codecs` 모듈에서 정의되고 있습니다.

.. admonition:: flowdas

   인코딩 선언을 발견하면 파이썬은 해당 코덱의 디코더를 사용하여 스크립트를 디코딩한 후, 구문 분석기의 다음 단계로 전달합니다.
   때문에 코덱은 파이썬 소스 파일의 전처리기를 제작하는데 사용될 수 있습니다. 물론 이 코덱은 스크립트를 실행하거나
   ``import`` 하기 전에 등록되어 있어야 합니다. ``import`` 의 경우는 사전에 코덱을 등록하면되지만, 스크립트를 직접
   실행하는 경우에도 동작하게 하기 위해서는 ``sitecustomize.py`` 나 ``usercustomize.py`` 파일에 코덱을
   등록하는 코드를 삽입하는 방법을 쓸 수 있습니다.

.. _explicit-joining:

Explicit line joining
---------------------

.. index:: physical line, line joining, line continuation, backslash character

Two or more physical lines may be joined into logical lines using backslash
characters (``\``), as follows: when a physical line ends in a backslash that is
not part of a string literal or comment, it is joined with the following forming
a single logical line, deleting the backslash and the following end-of-line
character.  For example::

   if 1900 < year < 2100 and 1 <= month <= 12 \
      and 1 <= day <= 31 and 0 <= hour < 24 \
      and 0 <= minute < 60 and 0 <= second < 60:   # 유효한 날짜처럼 보입니다
           return 1

A line ending in a backslash cannot carry a comment.  A backslash does not
continue a comment.  A backslash does not continue a token except for string
literals (i.e., tokens other than string literals cannot be split across
physical lines using a backslash).  A backslash is illegal elsewhere on a line
outside a string literal.

.. admonition:: flowdas

   주석 끝에 붙는 역 슬래시는 주석의 일부일 뿐 명시적 줄 결합으로 보지 않습니다.
   주석 앞에 붙는 역 슬래시는 문법에 어긋납니다.

.. admonition:: flowdas

   역 슬래시와 개행 문자 사이에는 공백 문자를 포함해서 어떤 것도 등장할 수 없습니다.
   역 슬래시 다음에 공백 문자가 오면 :exc:`SyntaxError` 를 일으킵니다.


.. _implicit-joining:

Implicit line joining
---------------------

Expressions in parentheses, square brackets or curly braces can be split over
more than one physical line without using backslashes. For example::

   month_names = ['Januari', 'Februari', 'Maart',      # 이것들은
                  'April',   'Mei',      'Juni',       # 일년을 이루는
                  'Juli',    'Augustus', 'September',  # 달들의
                  'Oktober', 'November', 'December']   # 네덜란드 이름입니다

Implicitly continued lines can carry comments.  The indentation of the
continuation lines is not important.  Blank continuation lines are allowed.
There is no NEWLINE token between implicit continuation lines.  Implicitly
continued lines can also occur within triple-quoted strings (see below); in that
case they cannot carry comments.


.. _blank-lines:

Blank lines
-----------

.. index:: single: blank line

A logical line that contains only spaces, tabs, formfeeds and possibly a
comment, is ignored (i.e., no NEWLINE token is generated).  During interactive
input of statements, handling of a blank line may differ depending on the
implementation of the read-eval-print loop.  In the standard interactive
interpreter, an entirely blank logical line (i.e. one containing not even
whitespace or a comment) terminates a multi-line statement.

.. admonition:: flowdas

   스페이스(space)는 `' '` 문자를 가리킬 때 사용합니다. 반면 공백(whitespace)은 스페이스, 탭, 폼피드 문자들을 통칭할
   때 사용합니다.

.. admonition:: flowdas

   REPL 은 Read-Eval-Print Loop 의 약자입니다. 문장을 입력받고 실행한 후 결과를 출력하는 것을 반복하는 대화형 환경의
   인터페이스를 뜻합니다.


.. _indentation:

Indentation
-----------

.. index:: indentation, leading whitespace, space, tab, grouping, statement grouping

Leading whitespace (spaces and tabs) at the beginning of a logical line is used
to compute the indentation level of the line, which in turn is used to determine
the grouping of statements.

Tabs are replaced (from left to right) by one to eight spaces such that the
total number of characters up to and including the replacement is a multiple of
eight (this is intended to be the same rule as used by Unix).  The total number
of spaces preceding the first non-blank character then determines the line's
indentation.  Indentation cannot be split over multiple physical lines using
backslashes; the whitespace up to the first backslash determines the
indentation.

.. admonition:: flowdas

   역 슬래시 앞에 공백 문자 이외의 문자가 오는 경우, 명시적 줄 연결이 들여쓰기 수준을 바꾸지 못함은 자명합니다.
   하지만 역 슬래시 이전에 공백과 탭문자들만 있는 경우, 그 다음 줄의 처음에 등장하는 공백이나 탭이 더해져서 들여쓰기 수준이
   결정되는지 여부는 좀 애매할 수 있습니다. 이 문단은 그 경우를 명확히하고 있는데, 오직 첫번째 물리적 줄에서 들여쓰기 수준이
   결정된다는 것입니다. 아주 예외적인 경우에 대한 정의인데, 아예 이런 상황을 만들지 않는 것이 바람직합니다.

Indentation is rejected as inconsistent if a source file mixes tabs and spaces
in a way that makes the meaning dependent on the worth of a tab in spaces; a
:exc:`TabError` is raised in that case.

.. admonition:: flowdas

   파이썬의 구문 분석기가 탭을 최대 8개의 공백으로 변환한다는 규칙은 늘 유지됩니다. 하지만 편집기는 설정 상태에 따라
   다른 값을 사용하고 있을 수 있습니다. 만약 이 설정 상태에 따라 코드가 다르게 해석될 수 있다면 문제점을 발견하기가
   무척 어렵게 됩니다. 때문에 이런 가능성이 있는 경우 :exc:`TabError` 를 일으킵니다. 탭과 공백을 섞어 쓰더라도,
   다르게 해석될 여지가 없는 경우는 예외를 발생시키지 않습니다. 다르게 해석된다는 것은 문장들의 묶음이 다르게 결정된다는
   것을 뜻합니다.

.. admonition:: flowdas

   :exc:`TabError` 는 :exc:`SyntaxError` 의 서브 클래스입니다. 이처럼 구문분석 단계에서 발생하는 오류는
   :exc:`SyntaxError` 로 이어집니다.

**Cross-platform compatibility note:** because of the nature of text editors on
non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for the
indentation in a single source file.  It should also be noted that different
platforms may explicitly limit the maximum indentation level.

A formfeed character may be present at the start of the line; it will be ignored
for the indentation calculations above.  Formfeed characters occurring elsewhere
in the leading whitespace have an undefined effect (for instance, they may reset
the space count to zero).

.. index:: INDENT token, DEDENT token

The indentation levels of consecutive lines are used to generate INDENT and
DEDENT tokens, using a stack, as follows.

Before the first line of the file is read, a single zero is pushed on the stack;
this will never be popped off again.  The numbers pushed on the stack will
always be strictly increasing from bottom to top.  At the beginning of each
logical line, the line's indentation level is compared to the top of the stack.
If it is equal, nothing happens. If it is larger, it is pushed on the stack, and
one INDENT token is generated.  If it is smaller, it *must* be one of the
numbers occurring on the stack; all numbers on the stack that are larger are
popped off, and for each number popped off a DEDENT token is generated.  At the
end of the file, a DEDENT token is generated for each number remaining on the
stack that is larger than zero.

Here is an example of a correctly (though confusingly) indented piece of Python
code::

   def perm(l):
           # l 의 모든 순열의 리스트를 계산합니다
       if len(l) <= 1:
                     return [l]
       r = []
       for i in range(len(l)):
                s = l[:i] + l[i+1:]
                p = perm(s)
                for x in p:
                 r.append(l[i:i+1] + x)
       return r

The following example shows various indentation errors::

    def perm(l):                       # 에러: 첫 줄을 들여쓰기 했습니다
   for i in range(len(l)):             # 에러: 들여쓰지 않았습니다
       s = l[:i] + l[i+1:]
           p = perm(l[:i] + l[i+1:])   # 에러: 예기치 않은 들여쓰기
           for x in p:
                   r.append(l[i:i+1] + x)
               return r                # 에러: 일관성 없는 내어쓰기

(Actually, the first three errors are detected by the parser; only the last
error is found by the lexical analyzer --- the indentation of ``return r`` does
not match a level popped off the stack.)


.. _whitespace:

Whitespace between tokens
-------------------------

Except at the beginning of a logical line or in string literals, the whitespace
characters space, tab and formfeed can be used interchangeably to separate
tokens.  Whitespace is needed between two tokens only if their concatenation
could otherwise be interpreted as a different token (e.g., ab is one token, but
a b is two tokens).

.. admonition:: flowdas

   반대로 토큰 사이에 공백이 꼭 필요하지 않은 경우에, 공백을 넣는 것은 공백을 넣지 않은 것과 동일한 결과를 줍니다.
   가령 `-5` 는 `-` 와 `5` 두개의 토큰으로 구성됩니다. 이를 `- 5` 로 써도 같은 결과를 줍니다.
   또한 ``' hello '.strip()`` 처럼 리터럴의 메서드를 호출하는 것은 자연스러운 표현입니다. 하지만 숫자 리터럴의 경우는
   ``.`` 이 소수점으로 해석되기 때문에 사용하기가 곤란합니다. 이런 경우 ``.`` 앞에 공백을 삽입하면 됩니다. ``7 .bit_length()``. (물론 괄호로 둘러싸도 됩니다.)


.. _other-tokens:

Other tokens
============

Besides NEWLINE, INDENT and DEDENT, the following categories of tokens exist:
*identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. Whitespace
characters (other than line terminators, discussed earlier) are not tokens, but
serve to delimit tokens. Where ambiguity exists, a token comprises the longest
possible string that forms a legal token, when read from left to right.


.. _identifiers:

Identifiers and keywords
========================

.. index:: identifier, name

Identifiers (also referred to as *names*) are described by the following lexical
definitions.

The syntax of identifiers in Python is based on the Unicode standard annex
UAX-31, with elaboration and changes as defined below; see also :pep:`3131` for
further details.

Within the ASCII range (U+0001..U+007F), the valid characters for identifiers
are the same as in Python 2.x: the uppercase and lowercase letters ``A`` through
``Z``, the underscore ``_`` and, except for the first character, the digits
``0`` through ``9``.

Python 3.0 introduces additional characters from outside the ASCII range (see
:pep:`3131`).  For these characters, the classification uses the version of the
Unicode Character Database as included in the :mod:`unicodedata` module.

Identifiers are unlimited in length.  Case is significant.

.. admonition:: flowdas

   대소문자가 구분된다는 뜻입니다. 유니코드에서는 대문자와 소문자외에도 타이틀문자가 있습니다.
   주로 여러개의 글자가 합쳐서 만들어진 글자들 때문인데, 제목으로 사용되는 단어들을 첫글자만 대문자로 만드는 경우를 위한 것입니다.
   이 세가지를 모두 지칭하기 위해 케이스라는 단어를 사용합니다.

.. productionlist::
   identifier: `xid_start` `xid_continue`*
   id_start: <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property>
   id_continue: <all characters in `id_start`, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property>
   xid_start: <all characters in `id_start` whose NFKC normalization is in "id_start xid_continue*">
   xid_continue: <all characters in `id_continue` whose NFKC normalization is in "id_continue*">

The Unicode category codes mentioned above stand for:

.. admonition:: flowdas

   유니코드에서 엄밀히 정의된 개념을 나타내는 것들이기 때문에, 대부분 번역하지 않고 그대로 둡니다.

* *Lu* - uppercase letters
* *Ll* - lowercase letters
* *Lt* - titlecase letters
* *Lm* - modifier letters
* *Lo* - other letters
* *Nl* - letter numbers
* *Mn* - nonspacing marks
* *Mc* - spacing combining marks
* *Nd* - decimal numbers
* *Pc* - connector punctuations
* *Other_ID_Start* - explicit list of characters in `PropList.txt
  <http://www.unicode.org/Public/11.0.0/ucd/PropList.txt>`_ to support backwards
  compatibility
* *Other_ID_Continue* - likewise

.. admonition:: flowdas

   *Other_ID_Start* 는 6개의 유니코드 문자 U+1885, U+1886, U+2118, U+212E, U+309B, U+309C 를,
   *Other_ID_Continue* 는 12개의 유니코드 문자: U+00B7, U+0387, U+1369..U+1371, U+19DA 를 뜻합니다.

All identifiers are converted into the normal form NFKC while parsing; comparison
of identifiers is based on NFKC.

.. admonition:: flowdas

   유니코드에는 그 생김새와 역할이 동일함에도 불구하고 다른 코드가 할당되어 있는 문자들이 있습니다. 생김새가 다르더라도
   의미적으로 동등한 경우도 있습니다. 이런 문자들을 다른 것으로 인식한다면, 편집기를 통해 사용자는 같은 식별자를 쓰고
   있다고 생각하지만, 실제로 파이썬은 다른 식별자로 취급하고 있는 경우가 발생할 수 있습니다. 이런 경우를 최소화하기 위해
   식별자를 정규화(normalization)라는 과정을 거쳐 어떤 표준적인 형태로 변경한 후에 비교합니다. 유니코드가 정의하고 있는
   정규화 방법은 여러가지가 있습니다: NFD, NFC, NFKD, NFKC. 이 중 식별자의 비교에 사용하고 있는 NFKC 는
   NFKD(호환 분해, compatibility decomposition)후에 정준 결합(canonical composition)하는 방식입니다.
   한글의 경우를 예로 들어보자면, `오`(U+C624) 를 호환 분해 하면 `ㅇㅗ`(U+110B, U+1169; 한글 조합형 자모 영역) 가 됩니다.
   이를 다시 정준 결합하면 `오`(U+C624) 가 됩니다. 원래 값과 같은 값이 되어 쓸데없는 짓을 한 것처럼 보이겠지만, 원래 값이
   (비슷한 모양이지만 사실은 다른 코드 값을 갖는) `ㅇㅗ`(U+3147, U+3157; 한글 호환 자모 영역) 인 경우도 `오` (U+C624)로
   변환됨에 주목한다면, 그 목적을 짐작할 수 있을 것입니다. 정규화의 세부 사항은 이 예 보다는 훨씬 다양한 상황을 다룹니다.
   자세한 내용은 유니코드 표준 부속서 UAX-15 에서 찾을 수 있습니다. 파이썬의 표준 라이브러리 :mod:`unicodedata` 는
   :func:`unicodedata.normalize()` 라는 함수를 통해 정규화를 제공하고 있습니다.
   ``normalize('NFKC', 'ㅇㅗ')`` 를 실행하면 `오` 가 얻어집니다. 이 때문에 ``오=5; print(ㅇㅗ)`` 는 두 변수를
   같은 것으로 취급합니다. 하지만 ASCII 이외의 유니코드를 식별자로 사용하지 않는다면 이런 문제를 만날 일은 없습니다.
   마지막으로 macOS 를 사용하는 경우, OS 가 출력할 때 NFKC 를 적용하기 때문에 분해된 형태를 보기가 어렵습니다.
   이런 경우 문자열의 길이를 확인하면 됩니다.

A non-normative HTML file listing all valid identifier characters for Unicode
4.1 can be found at
https://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html.

.. admonition:: flowdas

   *ID_Start* 와 *ID_Continue* 를 목록화하고 있는데, 브라우저가 폰트를 지원하는 문자들은 그 모습을 볼 수 있도록 구성되어
   있습니다.


.. _keywords:

Keywords
--------

.. index::
   single: keyword
   single: reserved word

The following identifiers are used as reserved words, or *keywords* of the
language, and cannot be used as ordinary identifiers.  They must be spelled
exactly as written here:

.. sourcecode:: text

   False      await      else       import     pass
   None       break      except     in         raise
   True       class      finally    is         return
   and        continue   for        lambda     try
   as         def        from       nonlocal   while
   assert     del        global     not        with
   async      elif       if         or         yield

.. admonition:: flowdas

   파이썬 3.6 까지는 await 와 async 가 이 목록에 포함되지 않았습니다. 이 것들은 평소에는 일반 식별자로 사용될 수 있었는데,
   코루틴의 바디에서는 키워드로 취급되었습니다.
   또한, async 를 식별자로 사용하더라도 ``async def`` 와 같은 문맥에서는 식별자로 인식되지 않았습니다.

   파이썬 3.7 부터는 async 와 await 모두 정식 키워드가 됩니다. 때문에 어느 곳에서도 식별자로 사용될 수 없습니다.

.. _id-classes:

Reserved classes of identifiers
-------------------------------

Certain classes of identifiers (besides keywords) have special meanings.  These
classes are identified by the patterns of leading and trailing underscore
characters:

``_*``
   Not imported by ``from module import *``.  The special identifier ``_`` is used
   in the interactive interpreter to store the result of the last evaluation; it is
   stored in the :mod:`builtins` module.  When not in interactive mode, ``_``
   has no special meaning and is not defined. See section :ref:`import`.

   .. admonition:: flowdas

      식별자가 이런 형태를 갖고 있더라도, ``__all__`` 변수에 포함되어 있다면 ``from module import *`` 에
      의해 임포트 됩니다.

   .. note::

      The name ``_`` is often used in conjunction with internationalization;
      refer to the documentation for the :mod:`gettext` module for more
      information on this convention.

      .. admonition:: flowdas

         예를 들어, :func:`gettext.install()` 함수는 ``_()`` 함수를 :mod:`builtins` 모듈에 설치합니다.
         이 함수는 국제화 과정에서 변환되어야 하는 문자열들을 이런 형태로 감싸는데 사용됩니다. ``_('hello')``.

``__*__``
   System-defined names. These names are defined by the interpreter and its
   implementation (including the standard library).  Current system names are
   discussed in the :ref:`specialnames` section and elsewhere.  More will likely
   be defined in future versions of Python.  *Any* use of ``__*__`` names, in
   any context, that does not follow explicitly documented use, is subject to
   breakage without warning.

``__*``
   Class-private names.  Names in this category, when used within the context of a
   class definition, are re-written to use a mangled form to help avoid name
   clashes between "private" attributes of base and derived classes. See section
   :ref:`atom-identifiers`.


.. _literals:

Literals
========

.. index:: literal, constant

Literals are notations for constant values of some built-in types.


.. _strings:

String and Bytes literals
-------------------------

.. index:: string literal, bytes literal, ASCII

String literals are described by the following lexical definitions:

.. productionlist::
   stringliteral: [`stringprefix`](`shortstring` | `longstring`)
   stringprefix: "r" | "u" | "R" | "U" | "f" | "F"
               : | "fr" | "Fr" | "fR" | "FR" | "rf" | "rF" | "Rf" | "RF"
   shortstring: "'" `shortstringitem`* "'" | '"' `shortstringitem`* '"'
   longstring: "'''" `longstringitem`* "'''" | '"""' `longstringitem`* '"""'
   shortstringitem: `shortstringchar` | `stringescapeseq`
   longstringitem: `longstringchar` | `stringescapeseq`
   shortstringchar: <any source character except "\" or newline or the quote>
   longstringchar: <any source character except "\">
   stringescapeseq: "\" <any source character>

.. productionlist::
   bytesliteral: `bytesprefix`(`shortbytes` | `longbytes`)
   bytesprefix: "b" | "B" | "br" | "Br" | "bR" | "BR" | "rb" | "rB" | "Rb" | "RB"
   shortbytes: "'" `shortbytesitem`* "'" | '"' `shortbytesitem`* '"'
   longbytes: "'''" `longbytesitem`* "'''" | '"""' `longbytesitem`* '"""'
   shortbytesitem: `shortbyteschar` | `bytesescapeseq`
   longbytesitem: `longbyteschar` | `bytesescapeseq`
   shortbyteschar: <any ASCII character except "\" or newline or the quote>
   longbyteschar: <any ASCII character except "\">
   bytesescapeseq: "\" <any ASCII character>

One syntactic restriction not indicated by these productions is that whitespace
is not allowed between the :token:`stringprefix` or :token:`bytesprefix` and the
rest of the literal. The source character set is defined by the encoding
declaration; it is UTF-8 if no encoding declaration is given in the source file;
see section :ref:`encodings`.

.. index:: triple-quoted string, Unicode Consortium, raw string

In plain English: Both types of literals can be enclosed in matching single quotes
(``'``) or double quotes (``"``).  They can also be enclosed in matching groups
of three single or double quotes (these are generally referred to as
*triple-quoted strings*).  The backslash (``\``) character is used to escape
characters that otherwise have a special meaning, such as newline, backslash
itself, or the quote character.

Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an
instance of the :class:`bytes` type instead of the :class:`str` type.  They
may only contain ASCII characters; bytes with a numeric value of 128 or greater
must be expressed with escapes.

Both string and bytes literals may optionally be prefixed with a letter ``'r'``
or ``'R'``; such strings are called :dfn:`raw strings` and treat backslashes as
literal characters.  As a result, in string literals, ``'\U'`` and ``'\u'``
escapes in raw strings are not treated specially. Given that Python 2.x's raw
unicode literals behave differently than Python 3.x's the ``'ur'`` syntax
is not supported.

.. admonition:: flowdas

   파이썬 2.x 에서는 문자열 리터럴의 앞에 `'ur'` 을 붙여서 날 유니코드 리터럴을 만들 수 있는데,
   이 경우는 특별히 `'\U'` 와 `'\u'` 이스케이프를 유니코드 문자열에서와 동일하게 처리합니다.
   파이썬 3.x 는 이 기능을 지원하지 않습니다.

   한편 파이썬 3.0 에서는 기본 문자열이 유니코드이기 때문에 리터럴 앞에 `'u'` 를 붙이는 표현을 지원하지 않았으나,
   파이썬 2.x 와 3.x 에서 동시에 실행될 수 있는 코드 작성을 지원하기 위해 파이썬 3.3 부터 지원하기 시작했습니다.
   그런데 `'ur'` 을 붙이는 경우는 `'r'` 을 붙이는 경우와 동일한 결과를 주어야 하는데, 앞서 언급한 것처럼
   `'\U'` 와 `'\u'` 이스케이프 지원여부에 있어서 이미 파이썬 2.x 와 차이가 나기 시작했습니다.
   이 때문에 `'ur'` 을 붙이는 리터럴을 지원하지 않기로 했습니다. 사용하면 :exc:`SyntaxError` 를 일으킵니다.

.. versionadded:: 3.3
   The ``'rb'`` prefix of raw bytes literals has been added as a synonym
   of ``'br'``.

   .. admonition:: flowdas

      예전에는 리터럴 접두어를 여러개 사용하는 경우, 정해진 순서대로 사용해야만 했습니다. 즉 ``'br'`` 은 가능하지만
      ``'rb'`` 는 허락되지 않는 식입니다. 이는 쓸데없이 프로그래머의 기억력을 시험하는 것이고, 모든
      조합을 허락하는 방향으로 수정되었습니다. 구문 정의를 보면 분명하게 드러납니다.

.. versionadded:: 3.3
   Support for the unicode legacy literal (``u'value'``) was reintroduced
   to simplify the maintenance of dual Python 2.x and 3.x codebases.
   See :pep:`414` for more information.

A string literal with ``'f'`` or ``'F'`` in its prefix is a
:dfn:`formatted string literal`; see :ref:`f-strings`.  The ``'f'`` may be
combined with ``'r'``, but not with ``'b'`` or ``'u'``, therefore raw
formatted strings are possible, but formatted bytes literals are not.

In triple-quoted literals, unescaped newlines and quotes are allowed (and are
retained), except that three unescaped quotes in a row terminate the literal.  (A
"quote" is the character used to open the literal, i.e. either ``'`` or ``"``.)

.. index:: physical line, escape sequence, Standard C, C

Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string and
bytes literals are interpreted according to rules similar to those used by
Standard C.  The recognized escape sequences are:

+-----------------+---------------------------------+-------+
| Escape Sequence | Meaning                         | Notes |
+=================+=================================+=======+
| ``\newline``    | Backslash and newline ignored   |       |
+-----------------+---------------------------------+-------+
| ``\\``          | Backslash (``\``)               |       |
+-----------------+---------------------------------+-------+
| ``\'``          | Single quote (``'``)            |       |
+-----------------+---------------------------------+-------+
| ``\"``          | Double quote (``"``)            |       |
+-----------------+---------------------------------+-------+
| ``\a``          | ASCII Bell (BEL)                |       |
+-----------------+---------------------------------+-------+
| ``\b``          | ASCII Backspace (BS)            |       |
+-----------------+---------------------------------+-------+
| ``\f``          | ASCII Formfeed (FF)             |       |
+-----------------+---------------------------------+-------+
| ``\n``          | ASCII Linefeed (LF)             |       |
+-----------------+---------------------------------+-------+
| ``\r``          | ASCII Carriage Return (CR)      |       |
+-----------------+---------------------------------+-------+
| ``\t``          | ASCII Horizontal Tab (TAB)      |       |
+-----------------+---------------------------------+-------+
| ``\v``          | ASCII Vertical Tab (VT)         |       |
+-----------------+---------------------------------+-------+
| ``\ooo``        | Character with octal value      | (1,3) |
|                 | *ooo*                           |       |
+-----------------+---------------------------------+-------+
| ``\xhh``        | Character with hex value *hh*   | (2,3) |
+-----------------+---------------------------------+-------+

Escape sequences only recognized in string literals are:

+-----------------+---------------------------------+-------+
| Escape Sequence | Meaning                         | Notes |
+=================+=================================+=======+
| ``\N{name}``    | Character named *name* in the   | \(4)  |
|                 | Unicode database                |       |
+-----------------+---------------------------------+-------+
| ``\uxxxx``      | Character with 16-bit hex value | \(5)  |
|                 | *xxxx*                          |       |
+-----------------+---------------------------------+-------+
| ``\Uxxxxxxxx``  | Character with 32-bit hex value | \(6)  |
|                 | *xxxxxxxx*                      |       |
+-----------------+---------------------------------+-------+

Notes:

(1)
   As in Standard C, up to three octal digits are accepted.

(2)
   Unlike in Standard C, exactly two hex digits are required.

(3)
   In a bytes literal, hexadecimal and octal escapes denote the byte with the
   given value. In a string literal, these escapes denote a Unicode character
   with the given value.

(4)
   .. versionchanged:: 3.3
      Support for name aliases [#]_ has been added.

(5)
   Exactly four hex digits are required.

(6)
   Any Unicode character can be encoded this way.  Exactly eight hex digits
   are required.


.. index:: unrecognized escape sequence

Unlike Standard C, all unrecognized escape sequences are left in the string
unchanged, i.e., *the backslash is left in the result*.  (This behavior is
useful when debugging: if an escape sequence is mistyped, the resulting output
is more easily recognized as broken.)  It is also important to note that the
escape sequences only recognized in string literals fall into the category of
unrecognized escapes for bytes literals.

   .. versionchanged:: 3.6
      Unrecognized escape sequences produce a DeprecationWarning.  In
      some future version of Python they will be a SyntaxError.

Even in a raw literal, quotes can be escaped with a backslash, but the
backslash remains in the result; for example, ``r"\""`` is a valid string
literal consisting of two characters: a backslash and a double quote; ``r"\"``
is not a valid string literal (even a raw string cannot end in an odd number of
backslashes).  Specifically, *a raw literal cannot end in a single backslash*
(since the backslash would escape the following quote character).  Note also
that a single backslash followed by a newline is interpreted as those two
characters as part of the literal, *not* as a line continuation.

.. admonition:: flowdas

   날 리터럴에만 해당하는 내용입니다. 보통 리터럴에서는 줄 결합으로 인식됩니다.

.. _string-concatenation:

String literal concatenation
----------------------------

Multiple adjacent string or bytes literals (delimited by whitespace), possibly
using different quoting conventions, are allowed, and their meaning is the same
as their concatenation.  Thus, ``"hello" 'world'`` is equivalent to
``"helloworld"``.  This feature can be used to reduce the number of backslashes
needed, to split long strings conveniently across long lines, or even to add
comments to parts of strings, for example::

   re.compile("[A-Za-z_]"       # 영문자 또는 밑줄
              "[A-Za-z0-9_]*"   # 영문자, 숫자 또는 밑줄
             )

.. admonition:: flowdas

   두 문자열 리터럴 사이에 공백이 없어도 됩니다.

.. admonition:: flowdas

   문자열 리터럴과 바이트열 리터럴을 이어붙이는 것은 허용되지 않습니다. 시도하면 :exc:`SyntaxError` 를 일으킵니다.

Note that this feature is defined at the syntactical level, but implemented at
compile time.  The '+' operator must be used to concatenate string expressions
at run time.  Also note that literal concatenation can use different quoting
styles for each component (even mixing raw strings and triple quoted strings),
and formatted string literals may be concatenated with plain string literals.

.. admonition:: flowdas

   파이썬 코드를 바이트코드로 변환하는 단계를 컴파일 단계라고 합니다. 이 바이트 코드를 실행하는 단계를 실행 단계라고 합니다.
   컴파일 시점에 이어붙이기가 구현된다는 말의 뜻은, 바이트코드에 이미 이어붙여진 문자열 리터럴이 들어가고, 실행 시점에서는
   이어붙이기가 발생하지 않는다는 뜻입니다. 그러면 실행시점에 값이 구해지는 f-문자열이 포함될 경우 어떻게 되는가 하는 의문이
   들 수 있습니다. 컴파일 시점에 이어붙이기가 일어나지만 그 결과가 f-문자열입니다.


.. index::
   single: formatted string literal
   single: interpolated string literal
   single: string; formatted literal
   single: string; interpolated literal
   single: f-string
.. _f-strings:

Formatted string literals
-------------------------

.. versionadded:: 3.6

A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal
that is prefixed with ``'f'`` or ``'F'``.  These strings may contain
replacement fields, which are expressions delimited by curly braces ``{}``.
While other string literals always have a constant value, formatted strings
are really expressions evaluated at run time.

Escape sequences are decoded like in ordinary string literals (except when
a literal is also marked as a raw string).  After decoding, the grammar
for the contents of the string is:

.. productionlist::
   f_string: (`literal_char` | "{{" | "}}" | `replacement_field`)*
   replacement_field: "{" `f_expression` ["!" `conversion`] [":" `format_spec`] "}"
   f_expression: (`conditional_expression` | "*" `or_expr`)
               :   ("," `conditional_expression` | "," "*" `or_expr`)* [","]
               : | `yield_expression`
   conversion: "s" | "r" | "a"
   format_spec: (`literal_char` | NULL | `replacement_field`)*
   literal_char: <any code point except "{", "}" or NULL>

The parts of the string outside curly braces are treated literally,
except that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced
with the corresponding single curly brace.  A single opening curly
bracket ``'{'`` marks a replacement field, which starts with a
Python expression.  After the expression, there may be a conversion field,
introduced by an exclamation point ``'!'``.  A format specifier may also
be appended, introduced by a colon ``':'``.  A replacement field ends
with a closing curly bracket ``'}'``.

Expressions in formatted string literals are treated like regular
Python expressions surrounded by parentheses, with a few exceptions.
An empty expression is not allowed, and a :keyword:`lambda` expression
must be surrounded by explicit parentheses.  Replacement expressions
can contain line breaks (e.g. in triple-quoted strings), but they
cannot contain comments.  Each expression is evaluated in the context
where the formatted string literal appears, in order from left to right.

If a conversion is specified, the result of evaluating the expression
is converted before formatting.  Conversion ``'!s'`` calls :func:`str` on
the result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`.

The result is then formatted using the :func:`format` protocol.  The
format specifier is passed to the :meth:`__format__` method of the
expression or conversion result.  An empty string is passed when the
format specifier is omitted.  The formatted result is then included in
the final value of the whole string.

Top-level format specifiers may include nested replacement fields. These nested
fields may include their own conversion fields and :ref:`format specifiers
<formatspec>`, but may not include more deeply-nested replacement fields. The
:ref:`format specifier mini-language <formatspec>` is the same as that used by
the string .format() method.

Formatted string literals may be concatenated, but replacement fields
cannot be split across literals.

Some examples of formatted string literals::

   >>> name = "Fred"
   >>> f"He said his name is {name!r}."
   "He said his name is 'Fred'."
   >>> f"He said his name is {repr(name)}."  # repr() 은 !r 과 같습니다
   "He said his name is 'Fred'."
   >>> width = 10
   >>> precision = 4
   >>> value = decimal.Decimal("12.34567")
   >>> f"result: {value:{width}.{precision}}"  # 중첩된 필드
   'result:      12.35'
   >>> today = datetime(year=2017, month=1, day=27)
   >>> f"{today:%B %d, %Y}"  # 날짜 포맷 지정자 사용
   'January 27, 2017'
   >>> number = 1024
   >>> f"{number:#0x}"  # 정수 포맷 지정자 사용
   '0x400'

.. admonition:: flowdas

   원문에서는 ``'January 27, 2017'`` 가 출력된다고 나와있으나, 이는 오류입니다. ``'Jan 27, 2017'`` 가 실제 결과입니다.

A consequence of sharing the same syntax as regular string literals is
that characters in the replacement fields must not conflict with the
quoting used in the outer formatted string literal::

   f"abc {a["x"]} def"    # 에러: 바깥 문자열 리터럴이 너무 일찍 종료되었습니다
   f"abc {a['x']} def"    # 해결 방법: 다른 따옴표를 사용하세요

Backslashes are not allowed in format expressions and will raise
an error::

   f"newline: {ord('\n')}"  # SyntaxError 를 일으킵니다

To include a value in which a backslash escape is required, create
a temporary variable.

   >>> newline = ord('\n')
   >>> f"newline: {newline}"
   'newline: 10'

Formatted string literals cannot be used as docstrings, even if they do not
include expressions.

::

   >>> def foo():
   ...     f"Not a docstring"
   ...
   >>> foo.__doc__ is None
   True

See also :pep:`498` for the proposal that added formatted string literals,
and :meth:`str.format`, which uses a related format string mechanism.

.. admonition:: flowdas

   포맷 바이트열 리터럴을 지원하지 않는 가장 중요한 이유는 포맷 프로토콜이 바이트열을 제공하지 않는다는 것입니다.

.. admonition:: flowdas

   포멧 문자열 리터럴이 수용하는 표현식은 그 본래의 목적에 비해 지나치다 싶을 정도로 자유도가 높습니다.
   구문 해석적으로 문제가 없는 이상 파이썬의 표현식 전체를 허락하려고 하고 있습니다. 그 중간 지대를 설정하는 것이
   까다롭기 때문일 것으로 짐작되는데, 다음과 같은 괴상한 상황도 발생합니다.

    >>> list((lambda: f"{yield 1}")())
    [1]

    치환 표현식을 남용하지 말고 읽기 쉬운 상태를 유지하는 것이 바람직합니다.

.. admonition:: flowdas

   치환 표현식은 임의의 인스턴스를 돌려줄 수 있습니다. 최종 출력을 결정하는 것은 이 인스턴스의 ``__format__()`` 메서드 인데,
   얼마든지 새로 정의할 수 있는 메서드입니다. ``':'`` 문자 뒤에 오는 포맷 지정자를 처리하는 것도 같은 메쏘드이기 때문에,
   인스턴스 전용의 포맷 지정자를 정의하는 것도 가능합니다.

.. admonition:: flowdas

   :meth:`str.format()` 은 그 형식이 포맷 문자열 리터럴과 유사하기 때문에, 포맷 문자열 리터럴이 지원되지 않는 3.6 이전의
   버전에서는 이런 식으로 그 표현의 일부를 흉내낼 수 있습니다.

      >>> def f(s):
      ...     frame = sys._getframe(1)
      ...     return s.format(**frame.f_locals)
      ...
      >>> name = "Fred"
      >>> f"He said his name is {name!r}."
      "He said his name is 'Fred'."
      >>> width = 10
      >>> precision = 4
      >>> value = decimal.Decimal("12.34567")
      >>> f("result: {value:{width}.{precision}}")
      'result:      12.35'
      >>> today = datetime(year=2017, month=1, day=27)
      >>> f("{today:%b %d, %Y}")
      'Jan 27, 2017'
      >>> number = 1024
      >>> f("{number:#0x}")
      '0x400'

.. _numbers:

Numeric literals
----------------

.. index:: number, numeric literal, integer literal
   floating point literal, hexadecimal literal
   octal literal, binary literal, decimal literal, imaginary literal, complex literal

There are three types of numeric literals: integers, floating point numbers, and
imaginary numbers.  There are no complex literals (complex numbers can be formed
by adding a real number and an imaginary number).

Note that numeric literals do not include a sign; a phrase like ``-1`` is
actually an expression composed of the unary operator '``-``' and the literal
``1``.

.. admonition:: flowdas

   파이썬의 ``float`` 형이 표현하는 값을 가리키는데 "실수(real number)" 라는 용어를 사용합니다.
   하지만 다른 대부분의 언어들과 마찬가지로 실제값은 부동소수점수 (floating point number) 로 표현되는데,
   그 정밀도가 유한하기 때문에 무리수와 이진법 표현에서 무한히 반복되는 유리수를 표현할 수 없습니다.
   사실 상 실수를 유한한 개수의 유리수들 중 하나로 근사한 값을 사용하는 것입니다. 때문에 엄밀히 따지자면 부동소수점수가
   더 정확한 표현이지만, 그 용도가 실수를 다루기 위한 것이기 때문에 간단히 실수라고 표기합니다.


.. _integers:

Integer literals
----------------

Integer literals are described by the following lexical definitions:

.. productionlist::
   integer: `decinteger` | `bininteger` | `octinteger` | `hexinteger`
   decinteger: `nonzerodigit` (["_"] `digit`)* | "0"+ (["_"] "0")*
   bininteger: "0" ("b" | "B") (["_"] `bindigit`)+
   octinteger: "0" ("o" | "O") (["_"] `octdigit`)+
   hexinteger: "0" ("x" | "X") (["_"] `hexdigit`)+
   nonzerodigit: "1"..."9"
   digit: "0"..."9"
   bindigit: "0" | "1"
   octdigit: "0"..."7"
   hexdigit: `digit` | "a"..."f" | "A"..."F"

There is no limit for the length of integer literals apart from what can be
stored in available memory.

Underscores are ignored for determining the numeric value of the literal.  They
can be used to group digits for enhanced readability.  One underscore can occur
between digits, and after base specifiers like ``0x``.

Note that leading zeros in a non-zero decimal number are not allowed. This is
for disambiguation with C-style octal literals, which Python used before version
3.0.

Some examples of integer literals::

   7     2147483647                        0o177    0b100110111
   3     79228162514264337593543950336     0o377    0xdeadbeef
         100_000_000_000                   0b_1110_0101

.. versionchanged:: 3.6
   Underscores are now allowed for grouping purposes in literals.

.. admonition:: flowdas

   접두어 ``0b`` 나 ``0B`` 는 이진수 리터럴, ``0o`` 나 ``0O`` 는 8진수 리터럴, ``0x`` 나 ``0X`` 는 16진수 리터럴을 표현할 때 사용됩니다.


.. _floating:

Floating point literals
-----------------------

Floating point literals are described by the following lexical definitions:

.. productionlist::
   floatnumber: `pointfloat` | `exponentfloat`
   pointfloat: [`digitpart`] `fraction` | `digitpart` "."
   exponentfloat: (`digitpart` | `pointfloat`) `exponent`
   digitpart: `digit` (["_"] `digit`)*
   fraction: "." `digitpart`
   exponent: ("e" | "E") ["+" | "-"] `digitpart`

Note that the integer and exponent parts are always interpreted using radix 10.
For example, ``077e010`` is legal, and denotes the same number as ``77e10``. The
allowed range of floating point literals is implementation-dependent.  As in
integer literals, underscores are supported for digit grouping.

Some examples of floating point literals::

   3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93

.. versionchanged:: 3.6
   Underscores are now allowed for grouping purposes in literals.

.. admonition:: flowdas

   정수 리터럴과 마찬가지로, 실수 리터럴 자체의 길이 제한은 없습니다. 하지만 파이썬의 정수는 무한 길이 정수를 지원하고 있는 반면,
   실수는 고정된 크기의 메모리에 저장됩니다. 이 때문에 리터럴에 아무리 많은 숫자가 표현되더라도 실제 저장되는 값은 그 값의
   근사값입니다.

.. admonition:: flowdas

   리터럴의 허락된 범위가 구현 세부 사항이라는 뜻은, 파이썬은 실수를 표시하기 위해 플랫폼의 배정도 실수 표현을 그대로 사용하고,
   이 표현은 플랫폼마다 다를 수 있다는 뜻입니다. 하지만 현대적인 대부분의 플랫폼에서는 IEEE 754 가 정의하는 배정도 부동 소수점
   표현을 사용하기 때문에 대체로 같습니다. 현재 플랫폼에서 지원되는 가장 큰 실수는 :attr:`sys.float_info.max` 이고,
   가장 작은 실수는 그 것의 음의 값입니다. 절대값이 가장 작은 실수는 :attr:`sys.float_info.min` 입니다.
   IEEE 754 에서 두 값은 각각 ``1.7976931348623157e+308`` 과 ``2.2250738585072014e-308`` 입니다.


.. _imaginary:

Imaginary literals
------------------

Imaginary literals are described by the following lexical definitions:

.. productionlist::
   imagnumber: (`floatnumber` | `digitpart`) ("j" | "J")

An imaginary literal yields a complex number with a real part of 0.0.  Complex
numbers are represented as a pair of floating point numbers and have the same
restrictions on their range.  To create a complex number with a nonzero real
part, add a floating point number to it, e.g., ``(3+4j)``.  Some examples of
imaginary literals::

   3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j


.. _operators:

Operators
=========

.. index:: single: operators

The following tokens are operators:

.. code-block:: none


   +       -       *       **      /       //      %      @
   <<      >>      &       |       ^       ~
   <       >       <=      >=      ==      !=


.. _delimiters:

Delimiters
==========

.. index:: single: delimiters

The following tokens serve as delimiters in the grammar:

.. code-block:: none

   (       )       [       ]       {       }
   ,       :       .       ;       @       =       ->
   +=      -=      *=      /=      //=     %=      @=
   &=      |=      ^=      >>=     <<=     **=

The period can also occur in floating-point and imaginary literals.  A sequence
of three periods has a special meaning as an ellipsis literal. The second half
of the list, the augmented assignment operators, serve lexically as delimiters,
but also perform an operation.

The following printing ASCII characters have special meaning as part of other
tokens or are otherwise significant to the lexical analyzer:

.. code-block:: none

   '       "       #       \

The following printing ASCII characters are not used in Python.  Their
occurrence outside string literals and comments is an unconditional error:

.. code-block:: none

   $       ?       `


.. rubric:: Footnotes

.. [#] http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt
