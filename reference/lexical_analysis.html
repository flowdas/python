
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2. 어휘 분석 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="3. 데이터 모델" href="datamodel.html" />
    <link rel="prev" title="1. 개요" href="introduction.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/reference/lexical_analysis.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="datamodel.html" title="3. 데이터 모델"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="1. 개요"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lexical-analysis">
<span id="lexical"></span><h1>2. 어휘 분석<a class="headerlink" href="#lexical-analysis" title="제목 주소">¶</a></h1>
<p id="index-0">파이썬 프로그램은 <em>파서(parser)</em> 에 의해 읽힙니다. 파서의 입력은 <em>어휘 분석기(lexical analyzer)</em> 가 만들어내는 <em>토큰(token)</em> 들의 스트림입니다. 이 장에서는 어휘 분석기가 어떻게 파일을 토큰들로 분해하는지 설명합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">구문 분석기가 만들어내는 토큰들의 목록은 <a class="reference internal" href="../library/token.html#module-token" title="token: Constants representing terminal nodes of the parse tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">token</span></code></a> 모듈에서 제공됩니다. <a class="reference internal" href="../library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tokenize</span></code></a> 모듈로 파이썬 소스 파일의 구문 분석을
수행할 수도 있습니다.</p>
</div>
<p>파이썬은 프로그램 텍스트를 유니코드 코드값으로 읽습니다; 소스 파일의 인코딩은 인코딩 선언을 통해 지정될 수 있고, 기본값은 UTF-8입니다. 자세한 내용은 <span class="target" id="index-30"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a> 에 나옵니다. 소스 파일을 디코딩할 수 없을 때는 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 가 발생합니다.</p>
<div class="section" id="line-structure">
<span id="id1"></span><h2>2.1. 줄 구조(Line structure)<a class="headerlink" href="#line-structure" title="제목 주소">¶</a></h2>
<p id="index-2">파이썬 프로그램은 여러 개의 <em>논리적인 줄(logical lines)</em> 들로 나뉩니다.</p>
<div class="section" id="logical-lines">
<span id="id2"></span><h3>2.1.1. 논리적인 줄<a class="headerlink" href="#logical-lines" title="제목 주소">¶</a></h3>
<p id="index-3">논리적인 줄의 끝은 NEWLINE 토큰으로 표현됩니다. 문법이 허락하지 않는 이상 (예를 들어 복합문에서 문장들 사이) 문장은 논리적인 줄 간의 경계를 가로지를 수 없습니다. 논리적인 줄은 명시적이거나 묵시적인 <em>줄 결합(line joining)</em> 규칙에 따라 하나 이상의 <em>물리적인 줄(physical lines)</em> 들로 구성됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">편집기 상에서 여러 줄로 표현된 텍스트가, 구문 분석 과정에서 하나의 논리적인 줄로 합쳐질 수 있습니다.
이렇게 물리적인 줄이 논리적인 줄로 합쳐지는 규칙은 <a class="reference internal" href="#explicit-joining"><span class="std std-ref">명시적인 줄 결합</span></a> 과 <a class="reference internal" href="#implicit-joining"><span class="std std-ref">묵시적인 줄 결합</span></a> 에서 설명합니다.
구문 분석의 결과로 텍스트는 일련의 토큰들로 변환되는데, 논리적인 줄의 끝을 나타내는 토큰이 NEWLINE 입니다. 이 후의 단계에서는
논리적인 줄만이 사용됩니다. <code class="docutils literal notranslate"><span class="pre">if</span></code> 문이나 <code class="docutils literal notranslate"><span class="pre">for</span></code> 문과 같은 복합문들은 여러개의 논리적인 줄로 구성될 수 있지만,
단순문은 하나의 논리적인 줄로만 구성됩니다.</p>
</div>
</div>
<div class="section" id="physical-lines">
<span id="id3"></span><h3>2.1.2. 물리적인 줄<a class="headerlink" href="#physical-lines" title="제목 주소">¶</a></h3>
<p>물리적인 줄은 줄의 끝을 나타내는 시퀀스로 끝나는 문자들의 시퀀스입니다. 소스 파일과 문자열에는 플랫폼들의 표준 줄 종료 시퀀스들이 모두 사용될 수 있습니다 - ASCII LF (개행문자)를 사용하는 유닉스 형, ASCII 시퀀스 CR LF(캐리지 리턴 다음에 오는 개행 문자)를 사용하는 윈도우 형, ASCII CR(캐리지 리턴)을 사용하는 예전의 매킨토시 형. 이 형태들은 플랫폼의 종류와 관계없이 동등하게 사용할 수 있습니다. 입력의 끝은 마지막 물리적인 줄의 묵시적 종결자 역할을 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">줄의 끝이 여러개의 문자로 표현될 수 있기 때문에 시퀀스라고 표현하고 있습니다. 가령 윈도우에서는 CR 과 LF 두 문자를
연속으로 붙여서 줄의 끝을 표현합니다. 하지만 파이썬은 현재 사용되고 있는 플랫폼에 관계 없이 세가지 형태를 모두 줄의
끝으로 인식합니다. 이 때문에 어떤 플랫폼에서 소스 파일을 편집했는지에 관계없이 모든 플랫폼에서 실행될 수 있습니다.</p>
</div>
<p>파이썬을 내장할 때는, 소스 코드 문자열은 반드시 줄 종료 문자에 표준 C 관행(ASCII LF를 표현하는 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 문자로 줄이 종료됩니다)을 적용해서 파이썬 API로 전달되어야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">파이썬을 내장한다는 것은, <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">파이썬 인터프리터 확장 및 내장</span></a> 에서 설명하는 방법으로 별도의 응용프로그램에 파이썬 인터프리터를
내장시킨다는 뜻입니다. 이 경우 <a class="reference internal" href="../c-api/veryhigh.html#c.PyRun_SimpleString" title="PyRun_SimpleString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyRun_SimpleString()</span></code></a> 와 같은 API 를 사용해서 파이썬 코드를 실행하는데,
소스 파일에 등장하는 LF, CR LF, CR 들을 모두 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 로 변환해서 전달해야한다는 뜻입니다.</p>
</div>
</div>
<div class="section" id="comments">
<span id="id4"></span><h3>2.1.3. 주석<a class="headerlink" href="#comments" title="제목 주소">¶</a></h3>
<p id="index-4">주석은 문자열 리터럴에 포함되지 않는 해시 문자(<code class="docutils literal notranslate"><span class="pre">#</span></code>)로 시작하고 물리적인 줄의 끝에서 끝납니다. 묵시적인 줄 결합 규칙이 유효하지 않은 이상, 주석은 논리적인 줄을 종료시킵니다. 주석은 문법이 무시합니다; 토큰으로 만들어지지 않습니다.</p>
</div>
<div class="section" id="encoding-declarations">
<span id="encodings"></span><h3>2.1.4. 인코딩 선언<a class="headerlink" href="#encoding-declarations" title="제목 주소">¶</a></h3>
<p id="index-5">파이썬 스크립트의 첫 번 째나 두 번째 줄에 있는 주석이 정규식 <code class="docutils literal notranslate"><span class="pre">coding[=:]\s*([-\w.]+)</span></code> 과 매치되면, 이 주석은 인코딩 선언으로 처리됩니다. 이 정규식의 첫 번째 그룹은 소스 코드 파일의 인코딩 이름을 지정합니다. 인코딩 선언은 줄 전체에 홀로 나와야 합니다. 만약 두 번째 줄이라면, 첫 번째 줄 역시 주석만 있어야 합니다. 인코딩 선언의 권장 형태는 두 개입니다. 하나는</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: &lt;encoding-name&gt; -*-</span>
</pre></div>
</div>
<p>인데 GNU Emacs에서도 인식됩니다. 다른 하나는</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># vim:fileencoding=&lt;encoding-name&gt;</span>
</pre></div>
</div>
<p>인데 Bram Moolenaar 의 VIM에서 인식됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">주석이 이 정규식과 일치하는 부분을 포함하고 있기만 하면 됩니다. 널리 사용되는 두 편집기와 호환되게 만드는 영리한 정규식입니다.
이 정규식의 <code class="docutils literal notranslate"><span class="pre">([-\w.]+)</span></code> 와 매치되는 부분에서 인코딩 이름을 추출합니다.</p>
</div>
<p>인코딩 선언이 발견되지 않으면 기본 인코딩은 UTF-8입니다. 여기에 더해, 파일의 처음이 UTF-8 BOM (<code class="docutils literal notranslate"><span class="pre">b'\xef\xbb\xbf'</span></code>)이면 파일 인코딩이 UTF-8으로 선언된 것으로 봅니다. (이 방식은 마이크로소프트의 <strong class="program">notepad</strong> 에서 지원됩니다.)</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">BOM (Byte Order Mark) 은, 유니코드로 인코딩된 파일이 어떤 형식으로 기록되어 있는지를 표시하기 위해
파일의 처음에 삽입하는 표식입니다. 유니코드는 UTF-8 외에도 여러가지 방식으로 표현될 수 있는데,
이 중에는 UTF-8 와는 달리, 기록되는 값이 어떤 바이트 순서를 갖느냐가 지정될 필요가 있는 것들이 있습니다.
가령 UTF-16 은 리틀 엔디언 (Little-endian) 과 빅 엔디언 (Big-endian) 두가지 방식으로 기록될 수 있는데,
각각 <code class="docutils literal notranslate"><span class="pre">b'\xff\xfe'</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b'\xfe\xff'</span></code> 라는 BOM 으로 이 중 어떤 것을 사용하고 있는지 표시할 수 있습니다.
파이썬 파서는 UTF-8 이외의 BOM 은 지원하지 않습니다. (즉 UTF-8 이외의 BOM 은 BOM 으로 인식하지 않고,
구문 분석기의 입력으로 들어가기 때문에 결국 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으킵니다.)</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">BOM 과 인코딩 선언을 동시에 사용하고, 둘이 서로 다른 주장을 하면 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으킵니다.
하지만 같은 주장을 하는 경우도, 인코딩 이름으로 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 이 아니라 <code class="docutils literal notranslate"><span class="pre">utf8</span></code> 같은 별칭을 사용하면
<a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으키는데, 이 경우는 버그로 보아도 무방할듯합니다.</p>
</div>
<p>인코딩이 선언되면, 인코딩 이름은 파이썬이 인식할 수 있어야 합니다. 인코딩은 문자열 리터럴, 주석, 식별자를 포함한 모든 어휘 분석에서 모두 사용됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">파이썬이 인식할 수 있는 인코딩 이름은 표준 라이브러리의 <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 모듈에서 정의되고 있습니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">인코딩 선언을 발견하면 파이썬은 해당 코덱의 디코더를 사용하여 스크립트를 디코딩한 후, 구문 분석기의 다음 단계로 전달합니다.
때문에 코덱은 파이썬 소스 파일의 전처리기를 제작하는데 사용될 수 있습니다. 물론 이 코덱은 스크립트를 실행하거나
<code class="docutils literal notranslate"><span class="pre">import</span></code> 하기 전에 등록되어 있어야 합니다. <code class="docutils literal notranslate"><span class="pre">import</span></code> 의 경우는 사전에 코덱을 등록하면되지만, 스크립트를 직접
실행하는 경우에도 동작하게 하기 위해서는 <code class="docutils literal notranslate"><span class="pre">sitecustomize.py</span></code> 나 <code class="docutils literal notranslate"><span class="pre">usercustomize.py</span></code> 파일에 코덱을
등록하는 코드를 삽입하는 방법을 쓸 수 있습니다.</p>
</div>
</div>
<div class="section" id="explicit-line-joining">
<span id="explicit-joining"></span><h3>2.1.5. 명시적인 줄 결합<a class="headerlink" href="#explicit-line-joining" title="제목 주소">¶</a></h3>
<p id="index-6">둘 이상의 물리적인 줄은 역 슬래시 문자(<code class="docutils literal notranslate"><span class="pre">\</span></code>)를 사용해서 논리적인 줄로 결합할 수 있습니다: 물리적인 줄이 문자열 리터럴이나 주석의 일부가 아닌 역 슬래시 문자로 끝나면, 역 슬래시와 뒤따르는 개행 문자가 제거된 채로, 현재 만들어지고 있는 논리적인 줄에 합쳐집니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="mi">1900</span> <span class="o">&lt;</span> <span class="n">year</span> <span class="o">&lt;</span> <span class="mi">2100</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">month</span> <span class="o">&lt;=</span> <span class="mi">12</span> \
   <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">day</span> <span class="o">&lt;=</span> <span class="mi">31</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hour</span> <span class="o">&lt;</span> <span class="mi">24</span> \
   <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minute</span> <span class="o">&lt;</span> <span class="mi">60</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">second</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">:</span>   <span class="c1"># 유효한 날짜처럼 보입니다</span>
        <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<p>역 슬래시로 끝나는 줄은 주석이 포함될 수 없습니다. 역 슬래시는 주석을 결합하지 못합니다. 역 슬래시는 문자열 리터럴을 제외한 어떤 토큰도 결합하지 못합니다 (즉, 문자열 리터럴 이외의 어떤 토큰도 역 슬래시를 사용해서 두 줄에 나누어 기록할 수 없습니다.). 문자열 리터럴 밖에 있는 역 슬래시가 앞에서 언급한 장소 이외의 곳에 등장하는 것은 문법에 어긋납니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">주석 끝에 붙는 역 슬래시는 주석의 일부일 뿐 명시적 줄 결합으로 보지 않습니다.
주석 앞에 붙는 역 슬래시는 문법에 어긋납니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">역 슬래시와 개행 문자 사이에는 공백 문자를 포함해서 어떤 것도 등장할 수 없습니다.
역 슬래시 다음에 공백 문자가 오면 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으킵니다.</p>
</div>
</div>
<div class="section" id="implicit-line-joining">
<span id="implicit-joining"></span><h3>2.1.6. 묵시적인 줄 결합<a class="headerlink" href="#implicit-line-joining" title="제목 주소">¶</a></h3>
<p>괄호(<code class="docutils literal notranslate"><span class="pre">()</span></code>), 꺾쇠괄호(<code class="docutils literal notranslate"><span class="pre">[]</span></code>), 중괄호(<code class="docutils literal notranslate"><span class="pre">{}</span></code>)가 사용되는 표현은 역 슬래시 없이도 여러 개의 물리적인 줄로 나눌 수 있습니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">month_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Januari&#39;</span><span class="p">,</span> <span class="s1">&#39;Februari&#39;</span><span class="p">,</span> <span class="s1">&#39;Maart&#39;</span><span class="p">,</span>      <span class="c1"># 이것들은</span>
               <span class="s1">&#39;April&#39;</span><span class="p">,</span>   <span class="s1">&#39;Mei&#39;</span><span class="p">,</span>      <span class="s1">&#39;Juni&#39;</span><span class="p">,</span>       <span class="c1"># 일년을 이루는</span>
               <span class="s1">&#39;Juli&#39;</span><span class="p">,</span>    <span class="s1">&#39;Augustus&#39;</span><span class="p">,</span> <span class="s1">&#39;September&#39;</span><span class="p">,</span>  <span class="c1"># 달들의</span>
               <span class="s1">&#39;Oktober&#39;</span><span class="p">,</span> <span class="s1">&#39;November&#39;</span><span class="p">,</span> <span class="s1">&#39;December&#39;</span><span class="p">]</span>   <span class="c1"># 네덜란드 이름입니다</span>
</pre></div>
</div>
<p>묵시적으로 이어지는 줄들은 주석을 포함할 수 있습니다. 이어지는 줄들의 들여쓰기는 중요하지 않습니다. 중간에 빈 줄이 들어가도 됩니다. 묵시적으로 줄 결합하는 줄 들 간에는 NEWLINE 토큰이 만들어지지 않습니다. 묵시적으로 이어지는 줄들은 삼중 따옴표 된 문자열들에서도 등장할 수 있는데 (아래를 보라), 이 경우는 주석이 포함될 수 없습니다.</p>
</div>
<div class="section" id="blank-lines">
<span id="id5"></span><h3>2.1.7. 빈 줄<a class="headerlink" href="#blank-lines" title="제목 주소">¶</a></h3>
<p id="index-7">스페이스, 탭, 폼 피드(formfeed) 와 주석만으로 구성된 논리적인 줄은 무시됩니다. (즉 NEWLINE 토큰이 만들어지지 않습니다.) 대화형으로 문장이 입력되는 도중에는 빈 줄의 처리가 REPL 구현에 따라 달라질 수 있습니다. 표준 대화형 인터프리터에서는, 완전히 빈 줄(즉 공백이나 주석조차 없는 것)은 다중 행 문장을 종료시킵니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">스페이스(space)는 <cite>' '</cite> 문자를 가리킬 때 사용합니다. 반면 공백(whitespace)은 스페이스, 탭, 폼피드 문자들을 통칭할
때 사용합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">REPL 은 Read-Eval-Print Loop 의 약자입니다. 문장을 입력받고 실행한 후 결과를 출력하는 것을 반복하는 대화형 환경의
인터페이스를 뜻합니다.</p>
</div>
</div>
<div class="section" id="indentation">
<span id="id6"></span><h3>2.1.8. 들여쓰기<a class="headerlink" href="#indentation" title="제목 주소">¶</a></h3>
<p id="index-8">논리적인 줄의 제일 앞에 오는 공백(스페이스와 탭)은 줄의 들여쓰기 수준을 계산하는 데 사용되고, 이는 다시 문장들의 묶음을 결정하는 데 사용되게 됩니다.</p>
<p>탭은 (왼쪽에서 오른쪽으로) 1~8개의 스페이스로 변환되는데, 치환된 후의 총 스페이스 문자 수가 8의 배수가 되도록 맞춥니다. (유닉스에서 사용되는 규칙에 맞추려는 것입니다.) 첫 번째 비 공백 문자 앞에 나오는 공백의 총수가 줄의 들여쓰기를 결정합니다. 들여쓰기는 역 슬래시를 사용해서 여러 개의 물리적인 줄로 나눠질 수 없습니다; 첫 번째 역 슬래시 이전의 공백이 들여쓰기를 결정합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">역 슬래시 앞에 공백 문자 이외의 문자가 오는 경우, 명시적 줄 연결이 들여쓰기 수준을 바꾸지 못함은 자명합니다.
하지만 역 슬래시 이전에 공백과 탭문자들만 있는 경우, 그 다음 줄의 처음에 등장하는 공백이나 탭이 더해져서 들여쓰기 수준이
결정되는지 여부는 좀 애매할 수 있습니다. 이 문단은 그 경우를 명확히하고 있는데, 오직 첫번째 물리적 줄에서 들여쓰기 수준이
결정된다는 것입니다. 아주 예외적인 경우에 대한 정의인데, 아예 이런 상황을 만들지 않는 것이 바람직합니다.</p>
</div>
<p>소스 파일이 탭과 스페이스를 섞어 쓰는 경우, 탭이 몇 개의 스페이스에 해당하는지에 따라 다르게 해석될 수 있으면 <a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> 를 일으킵니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">파이썬의 구문 분석기가 탭을 최대 8개의 공백으로 변환한다는 규칙은 늘 유지됩니다. 하지만 편집기는 설정 상태에 따라
다른 값을 사용하고 있을 수 있습니다. 만약 이 설정 상태에 따라 코드가 다르게 해석될 수 있다면 문제점을 발견하기가
무척 어렵게 됩니다. 때문에 이런 가능성이 있는 경우 <a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> 를 일으킵니다. 탭과 공백을 섞어 쓰더라도,
다르게 해석될 여지가 없는 경우는 예외를 발생시키지 않습니다. 다르게 해석된다는 것은 문장들의 묶음이 다르게 결정된다는
것을 뜻합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> 는 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 의 서브 클래스입니다. 이처럼 구문분석 단계에서 발생하는 오류는
<a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 로 이어집니다.</p>
</div>
<p><strong>크로스-플랫폼 호환성 유의 사항:</strong> UNIX 이외의 플랫폼에서 편집기들이 동작하는 방식 때문에, 하나의 파일 내에서 들여쓰기를 위해 탭과 스페이스를 섞어 쓰는 것은 현명한 선택이 아닙니다. 다른 플랫폼들에서는 최대 들여쓰기 수준에 제한이 있을 수도 있다는 점도 주의해야 합니다.</p>
<p>폼 피드 문자는 줄의 처음에 나올 수 있습니다; 앞서 설명한 들여쓰기 수준 계산에서는 무시됩니다. 페이지 넘김 문자 앞에 공백이나 탭이 있는 경우는 정의되지 않은 효과를 줄 수 있습니다 (가령, 스페이스 수가 0으로 초기화될 수 있습니다).</p>
<p id="index-9">연속된 줄의 들여쓰기 수준은, 스택을 사용해서, 다음과 같은 방법으로 INDENT와 DEDENT 토큰을 만드는 데 사용됩니다.</p>
<p>파일의 첫 줄을 읽기 전에 0하나를 스택에 넣습니다(push); 이 값은 다시 꺼내는(pop) 일이 없습니다. 스택에 넣는 값은 항상 스택의 아래에서 위로 올라갈 때 단조 증가합니다. 각 논리적인 줄의 처음에서 줄의 들여쓰기 수준이 스택의 가장 위에 있는 값과 비교됩니다. 같다면 아무런 일도 일어나지 않습니다. 더 크다면 그 값을 스택에 넣고 하나의 INDENT 토큰을 만듭니다. 더 작다면 이 값은 스택에 있는 값 중 하나여야만 합니다. 이 값보다 큰 모든 스택의 값들을 꺼내고(pop), 꺼낸 횟수만큼의 DEDENT 토큰을 만듭니다. 파일의 끝에서, 스택에 남아있는 0보다 큰 값의 개수만큼 DEDENT 토큰을 만듭니다.</p>
<p>여기에 (혼란스럽다 할지라도) 올바르게 들여쓰기 된 파이썬 코드 조각이 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="c1"># l 의 모든 순열의 리스트를 계산합니다</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="k">return</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
             <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
             <span class="n">p</span> <span class="o">=</span> <span class="n">perm</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
              <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>다음 예는 여러 가지 들여쓰기 에러를 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span> <span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>                       <span class="c1"># 에러: 첫 줄을 들여쓰기 했습니다</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>             <span class="c1"># 에러: 들여쓰지 않았습니다</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">perm</span><span class="p">(</span><span class="n">l</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>   <span class="c1"># 에러: 예기치 않은 들여쓰기</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>                <span class="c1"># 에러: 일관성 없는 내어쓰기</span>
</pre></div>
</div>
<p>(사실, 처음 세 개의 에러는 파서가 감지합니다. 단지 마지막 에러만 어휘 분석기가 감지합니다. --- <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">r</span></code> 의 들여쓰기가 스택에 있는 값과 일치하지 않습니다.)</p>
</div>
<div class="section" id="whitespace-between-tokens">
<span id="whitespace"></span><h3>2.1.9. 토큰 사이의 공백<a class="headerlink" href="#whitespace-between-tokens" title="제목 주소">¶</a></h3>
<p>논리적인 줄의 처음과 문자열 리터럴을 제외하고, 공백 문자인 스페이스, 탭, 폼 피드는 토큰을 분리하기 위해 섞어 쓸 수 있습니다. 두 토큰을 붙여 쓸 때 다른 토큰으로 해석될 수 있는 경우만 토큰 사이에 공백이 필요합니다. (예를 들어, ab 는 하나의 토큰이지만, a b 는 두 개의 토큰입니다.)</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">반대로 토큰 사이에 공백이 꼭 필요하지 않은 경우에, 공백을 넣는 것은 공백을 넣지 않은 것과 동일한 결과를 줍니다.
가령 <cite>-5</cite> 는 <cite>-</cite> 와 <cite>5</cite> 두개의 토큰으로 구성됩니다. 이를 <cite>- 5</cite> 로 써도 같은 결과를 줍니다.
또한 <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">hello</span> <span class="pre">'.strip()</span></code> 처럼 리터럴의 메서드를 호출하는 것은 자연스러운 표현입니다. 하지만 숫자 리터럴의 경우는
<code class="docutils literal notranslate"><span class="pre">.</span></code> 이 소수점으로 해석되기 때문에 사용하기가 곤란합니다. 이런 경우 <code class="docutils literal notranslate"><span class="pre">.</span></code> 앞에 공백을 삽입하면 됩니다. <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">.bit_length()</span></code>. (물론 괄호로 둘러싸도 됩니다.)</p>
</div>
</div>
</div>
<div class="section" id="other-tokens">
<span id="id7"></span><h2>2.2. 다른 토큰들<a class="headerlink" href="#other-tokens" title="제목 주소">¶</a></h2>
<p>NEWLINE, INDENT, DEDENT 와는 별도로, 다음과 같은 유형의 토큰들이 존재합니다: <em>식별자(identifier)</em>, <em>키워드(keyword)</em>, <em>리터럴(literal)</em>, <em>연산자(operator)</em>, <em>구분자(delimiter)</em>. (앞에서 살펴본 줄 종료 이외의) 공백 문자들은 토큰이 아니지만, 토큰을 분리하는 역할을 담당합니다. 모호할 경우, 왼쪽에서 오른쪽으로 읽을 때, 하나의 토큰은 올바르고 가능한 한 최대 길이의 문자열로 구성되는 것을 선호합니다.</p>
</div>
<div class="section" id="identifiers">
<span id="identifiers-and-keywords"></span><h2>2.3. 식별자와 키워드<a class="headerlink" href="#identifiers" title="제목 주소">¶</a></h2>
<p id="index-10">식별자 (<em>이름(name)</em> 이라고도 합니다) 은 다음과 같은 어휘 정의로 기술됩니다.</p>
<p>파이썬에서 식별자의 문법은 유니코드 표준 부속서 UAX-31 에 기반을 두는데, 여기에 덧붙이거나 바꾼 내용은 아래에서 정의합니다. 좀 더 상세한 내용은 <span class="target" id="index-31"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3131"><strong>PEP 3131</strong></a> 에서 찾을 수 있습니다.</p>
<p>ASCII 범위 (U+0001..U+007F) 내에서, 올바른 식별자 문자는 파이썬 2.x 와 같습니다: <code class="docutils literal notranslate"><span class="pre">A</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">Z</span></code> 범위의 대문자와 소문자, 밑줄 <code class="docutils literal notranslate"><span class="pre">_</span></code>, 첫 문자를 제외하고, 숫자 <code class="docutils literal notranslate"><span class="pre">0</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
<p>파이썬 3.0은 ASCII 범위 밖의 문자들을 도입합니다 (<span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3131"><strong>PEP 3131</strong></a> 참조). 이 문자들의 경우, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 모듈에 포함된 버전의 유니코드 문자 데이터베이스에 따라 분류됩니다.</p>
<p>식별자는 길이에 제한이 없고, 케이스(case)는 구분됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">대소문자가 구분된다는 뜻입니다. 유니코드에서는 대문자와 소문자외에도 타이틀문자가 있습니다.
주로 여러개의 글자가 합쳐서 만들어진 글자들 때문인데, 제목으로 사용되는 단어들을 첫글자만 대문자로 만드는 경우를 위한 것입니다.
이 세가지를 모두 지칭하기 위해 케이스라는 단어를 사용합니다.</p>
</div>
<pre>
<strong id="grammar-token-identifier">identifier  </strong> ::=  <a class="reference internal" href="#grammar-token-xid-start"><code class="xref docutils literal notranslate"><span class="pre">xid_start</span></code></a> <a class="reference internal" href="#grammar-token-xid-continue"><code class="xref docutils literal notranslate"><span class="pre">xid_continue</span></code></a>*
<strong id="grammar-token-id-start">id_start    </strong> ::=  &lt;all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property&gt;
<strong id="grammar-token-id-continue">id_continue </strong> ::=  &lt;all characters in <a class="reference internal" href="#grammar-token-id-start"><code class="xref docutils literal notranslate"><span class="pre">id_start</span></code></a>, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property&gt;
<strong id="grammar-token-xid-start">xid_start   </strong> ::=  &lt;all characters in <a class="reference internal" href="#grammar-token-id-start"><code class="xref docutils literal notranslate"><span class="pre">id_start</span></code></a> whose NFKC normalization is in &quot;id_start xid_continue*&quot;&gt;
<strong id="grammar-token-xid-continue">xid_continue</strong> ::=  &lt;all characters in <a class="reference internal" href="#grammar-token-id-continue"><code class="xref docutils literal notranslate"><span class="pre">id_continue</span></code></a> whose NFKC normalization is in &quot;id_continue*&quot;&gt;
</pre>
<p>위에서 언급한 유니코드 카테고리 코드들의 의미는 이렇습니다:</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">유니코드에서 엄밀히 정의된 개념을 나타내는 것들이기 때문에, 대부분 번역하지 않고 그대로 둡니다.</p>
</div>
<ul class="simple">
<li><em>Lu</em> - uppercase letters</li>
<li><em>Ll</em> - lowercase letters</li>
<li><em>Lt</em> - titlecase letters</li>
<li><em>Lm</em> - modifier letters</li>
<li><em>Lo</em> - other letters</li>
<li><em>Nl</em> - letter numbers</li>
<li><em>Mn</em> - nonspacing marks</li>
<li><em>Mc</em> - spacing combining marks</li>
<li><em>Nd</em> - decimal numbers</li>
<li><em>Pc</em> - connector punctuations</li>
<li><em>Other_ID_Start</em> - 하위 호환성 지원을 위해 <a class="reference external" href="http://www.unicode.org/Public/11.0.0/ucd/PropList.txt">PropList.txt</a> 에서 명시적으로 나열된 문자들</li>
<li><em>Other_ID_Continue</em> - 마찬가지</li>
</ul>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>Other_ID_Start</em> 는 6개의 유니코드 문자 U+1885, U+1886, U+2118, U+212E, U+309B, U+309C 를,
<em>Other_ID_Continue</em> 는 12개의 유니코드 문자: U+00B7, U+0387, U+1369..U+1371, U+19DA 를 뜻합니다.</p>
</div>
<p>모든 식별자는 파서에 의해 NFKC 정규화 형식으로 변환되고, 식별자의 비교는 NFKC 에 기반을 둡니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">유니코드에는 그 생김새와 역할이 동일함에도 불구하고 다른 코드가 할당되어 있는 문자들이 있습니다. 생김새가 다르더라도
의미적으로 동등한 경우도 있습니다. 이런 문자들을 다른 것으로 인식한다면, 편집기를 통해 사용자는 같은 식별자를 쓰고
있다고 생각하지만, 실제로 파이썬은 다른 식별자로 취급하고 있는 경우가 발생할 수 있습니다. 이런 경우를 최소화하기 위해
식별자를 정규화(normalization)라는 과정을 거쳐 어떤 표준적인 형태로 변경한 후에 비교합니다. 유니코드가 정의하고 있는
정규화 방법은 여러가지가 있습니다: NFD, NFC, NFKD, NFKC. 이 중 식별자의 비교에 사용하고 있는 NFKC 는
NFKD(호환 분해, compatibility decomposition)후에 정준 결합(canonical composition)하는 방식입니다.
한글의 경우를 예로 들어보자면, '오'(U+C624) 를 호환 분해 하면 'ㅇㅗ'(U+110B, U+1169; 한글 조합형 자모 영역) 가 됩니다.
이를 다시 정준 결합하면 '오'(U+C624) 가 됩니다. 원래 값과 같은 값이 되어 쓸데없는 짓을 한 것처럼 보이겠지만, 원래 값이
(비슷한 모양이지만 사실은 다른 코드 값을 갖는) 'ㅇㅗ'(U+3147, U+3157; 한글 호환 자모 영역) 인 경우도 '오'(U+C624)로
변환됨에 주목한다면, 그 목적을 짐작할 수 있을 것입니다. 정규화의 세부 사항은 이 예 보다는 훨씬 다양한 상황을 다룹니다.
자세한 내용은 유니코드 표준 부속서 UAX-15 에서 찾을 수 있습니다. 파이썬의 표준 라이브러리 <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 는
<a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a> 라는 함수를 통해 정규화를 제공하고 있습니다.
<code class="docutils literal notranslate"><span class="pre">normalize('NFKC',</span> <span class="pre">'ㅇㅗ')</span></code> 를 실행하면 '오' 가 얻어집니다. 이 때문에 <code class="docutils literal notranslate"><span class="pre">오=5;</span> <span class="pre">print(ㅇㅗ)</span></code> 는 두 변수를
같은 것으로 취급합니다. 하지만 ASCII 이외의 유니코드를 식별자로 사용하지 않는다면 이런 문제를 만날 일은 없습니다.
마지막으로, macOS 를 사용하는 경우, OS 가 출력할 때 NFKC 를 적용하기 때문에 분해된 형태를 보기가 어렵습니다.
이런 경우 문자열의 길이를 확인하면 됩니다.</p>
</div>
<p>유니코드 4.1의 올바른 식별자 문자들의 비규범적인 목록을 HTML 파일로 정리한 문서를 <a class="reference external" href="https://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html">https://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html</a> 에서 열람할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>ID_Start</em> 와 <em>ID_Continue</em> 를 목록화하고 있는데, 브라우저가 폰트를 지원하는 문자들은 그 모습을 볼 수 있도록 구성되어
있습니다.</p>
</div>
<div class="section" id="keywords">
<span id="id8"></span><h3>2.3.1. 키워드<a class="headerlink" href="#keywords" title="제목 주소">¶</a></h3>
<p id="index-13">다음 식별자들은 예약어, 또는 언어의 키워드, 로 사용되고, 일반적인 식별자로 사용될 수 없습니다. 여기 쓰여 있는 것과 정확히 같게 사용되어야 합니다:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>파이썬 3.6 까지는 await 와 async 가 이 목록에 포함되지 않았습니다. 이 것들은 평소에는 일반 식별자로 사용될 수 있었는데,
코루틴의 바디에서는 키워드로 취급되었습니다.
또한, async 를 식별자로 사용하더라도 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 와 같은 문맥에서는 식별자로 인식되지 않았습니다.</p>
<p class="last">파이썬 3.7 부터는 async 와 await 모두 정식 키워드가 됩니다. 때문에 어느 곳에서도 식별자로 사용될 수 없습니다.</p>
</div>
</div>
<div class="section" id="reserved-classes-of-identifiers">
<span id="id-classes"></span><h3>2.3.2. 식별자의 예약 영역<a class="headerlink" href="#reserved-classes-of-identifiers" title="제목 주소">¶</a></h3>
<p>(키워드와는 별개로) 어떤 부류의 식별자들은 특별한 의미가 있습니다. 이 부류의 식별자들은 시작과 끝의 밑줄 문자 패턴으로 구분됩니다:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">_*</span></code></dt>
<dd><p class="first"><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 에 의해 임포트되지 않습니다. 특별한 식별자 <code class="docutils literal notranslate"><span class="pre">_</span></code> 는 대화형 인터프리터에서 마지막에 실행한 결과의 값을 저장하는 용도로 사용됩니다; <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 모듈에 저장됩니다. 대화형 모드가 아닐 경우 <code class="docutils literal notranslate"><span class="pre">_</span></code> 는 특별한 의미가 없고, 정의되지도 않습니다. <a class="reference internal" href="simple_stmts.html#import"><span class="std std-ref">임포트(import) 문</span></a> 섹션을 보세요.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">식별자가 이런 형태를 갖고 있더라도, <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 변수에 포함되어 있다면 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 에
의해 임포트 됩니다.</p>
</div>
<div class="last admonition note">
<p class="first admonition-title">주석</p>
<p>이름 <code class="docutils literal notranslate"><span class="pre">_</span></code> 은 종종 국제화(internationalization)와 관련되어 사용됩니다. 이 관례에 관해서는 <a class="reference internal" href="../library/gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 모듈의 문서를 참조하십시오.</p>
<div class="admonition-flowdas last admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">예를 들어, <a class="reference internal" href="../library/gettext.html#gettext.install" title="gettext.install"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext.install()</span></code></a> 함수는 <code class="docutils literal notranslate"><span class="pre">_()</span></code> 함수를 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 모듈에 설치합니다.
이 함수는 국제화 과정에서 변환되어야 하는 문자열들을 이런 형태로 감싸는데 사용됩니다. <code class="docutils literal notranslate"><span class="pre">_('hello')</span></code>.</p>
</div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__*__</span></code></dt>
<dd>시스템 정의 이름. 이 이름들은 인터프리터와 그 구현(표준 라이브러리를 포함합니다)이 정의합니다. 현재 정의된 시스템 이름은 <a class="reference internal" href="datamodel.html#specialnames"><span class="std std-ref">특수 메서드 이름들</span></a> 섹션과 그 외의 곳에서 논의됩니다. 파이썬의 미래 버전에서는 더 많은 것들이 정의될 가능성이 큽니다. 어떤 문맥에서건, 명시적으로 문서로 만들어진 사용법을 벗어나는 <code class="docutils literal notranslate"><span class="pre">__*__</span></code> 이름의 <em>모든</em> 사용은, 경고 없이 손상될 수 있습니다.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__*</span></code></dt>
<dd>클래스-비공개 이름. 이 부류의 이름들을 클래스 정의 문맥에서 사용하면 뒤섞인 형태로 변형됩니다. 부모 클래스와 자식 클래스의 &quot;비공개(private)&quot; 어트리뷰트 간의 이름 충돌을 피하기 위함입니다. <a class="reference internal" href="expressions.html#atom-identifiers"><span class="std std-ref">식별자 (이름)</span></a> 섹션을 보세요.</dd>
</dl>
</div>
</div>
<div class="section" id="literals">
<span id="id9"></span><h2>2.4. 리터럴<a class="headerlink" href="#literals" title="제목 주소">¶</a></h2>
<p id="index-14">리터럴(literal)은 몇몇 내장형들의 상숫값을 위한 표기법입니다.</p>
<div class="section" id="string-and-bytes-literals">
<span id="strings"></span><h3>2.4.1. 문자열과 바이트열 리터럴<a class="headerlink" href="#string-and-bytes-literals" title="제목 주소">¶</a></h3>
<p id="index-15">문자열 리터럴은 다음과 같은 어휘 정의로 기술됩니다:</p>
<pre>
<strong id="grammar-token-stringliteral">stringliteral  </strong> ::=  [<a class="reference internal" href="#grammar-token-stringprefix"><code class="xref docutils literal notranslate"><span class="pre">stringprefix</span></code></a>](<a class="reference internal" href="#grammar-token-shortstring"><code class="xref docutils literal notranslate"><span class="pre">shortstring</span></code></a> | <a class="reference internal" href="#grammar-token-longstring"><code class="xref docutils literal notranslate"><span class="pre">longstring</span></code></a>)
<strong id="grammar-token-stringprefix">stringprefix   </strong> ::=  &quot;r&quot; | &quot;u&quot; | &quot;R&quot; | &quot;U&quot; | &quot;f&quot; | &quot;F&quot;
                     | &quot;fr&quot; | &quot;Fr&quot; | &quot;fR&quot; | &quot;FR&quot; | &quot;rf&quot; | &quot;rF&quot; | &quot;Rf&quot; | &quot;RF&quot;
<strong id="grammar-token-shortstring">shortstring    </strong> ::=  &quot;'&quot; <a class="reference internal" href="#grammar-token-shortstringitem"><code class="xref docutils literal notranslate"><span class="pre">shortstringitem</span></code></a>* &quot;'&quot; | '&quot;' <a class="reference internal" href="#grammar-token-shortstringitem"><code class="xref docutils literal notranslate"><span class="pre">shortstringitem</span></code></a>* '&quot;'
<strong id="grammar-token-longstring">longstring     </strong> ::=  &quot;'''&quot; <a class="reference internal" href="#grammar-token-longstringitem"><code class="xref docutils literal notranslate"><span class="pre">longstringitem</span></code></a>* &quot;'''&quot; | '&quot;&quot;&quot;' <a class="reference internal" href="#grammar-token-longstringitem"><code class="xref docutils literal notranslate"><span class="pre">longstringitem</span></code></a>* '&quot;&quot;&quot;'
<strong id="grammar-token-shortstringitem">shortstringitem</strong> ::=  <a class="reference internal" href="#grammar-token-shortstringchar"><code class="xref docutils literal notranslate"><span class="pre">shortstringchar</span></code></a> | <a class="reference internal" href="#grammar-token-stringescapeseq"><code class="xref docutils literal notranslate"><span class="pre">stringescapeseq</span></code></a>
<strong id="grammar-token-longstringitem">longstringitem </strong> ::=  <a class="reference internal" href="#grammar-token-longstringchar"><code class="xref docutils literal notranslate"><span class="pre">longstringchar</span></code></a> | <a class="reference internal" href="#grammar-token-stringescapeseq"><code class="xref docutils literal notranslate"><span class="pre">stringescapeseq</span></code></a>
<strong id="grammar-token-shortstringchar">shortstringchar</strong> ::=  &lt;any source character except &quot;\&quot; or newline or the quote&gt;
<strong id="grammar-token-longstringchar">longstringchar </strong> ::=  &lt;any source character except &quot;\&quot;&gt;
<strong id="grammar-token-stringescapeseq">stringescapeseq</strong> ::=  &quot;\&quot; &lt;any source character&gt;
</pre>
<pre>
<strong id="grammar-token-bytesliteral">bytesliteral  </strong> ::=  <a class="reference internal" href="#grammar-token-bytesprefix"><code class="xref docutils literal notranslate"><span class="pre">bytesprefix</span></code></a>(<a class="reference internal" href="#grammar-token-shortbytes"><code class="xref docutils literal notranslate"><span class="pre">shortbytes</span></code></a> | <a class="reference internal" href="#grammar-token-longbytes"><code class="xref docutils literal notranslate"><span class="pre">longbytes</span></code></a>)
<strong id="grammar-token-bytesprefix">bytesprefix   </strong> ::=  &quot;b&quot; | &quot;B&quot; | &quot;br&quot; | &quot;Br&quot; | &quot;bR&quot; | &quot;BR&quot; | &quot;rb&quot; | &quot;rB&quot; | &quot;Rb&quot; | &quot;RB&quot;
<strong id="grammar-token-shortbytes">shortbytes    </strong> ::=  &quot;'&quot; <a class="reference internal" href="#grammar-token-shortbytesitem"><code class="xref docutils literal notranslate"><span class="pre">shortbytesitem</span></code></a>* &quot;'&quot; | '&quot;' <a class="reference internal" href="#grammar-token-shortbytesitem"><code class="xref docutils literal notranslate"><span class="pre">shortbytesitem</span></code></a>* '&quot;'
<strong id="grammar-token-longbytes">longbytes     </strong> ::=  &quot;'''&quot; <a class="reference internal" href="#grammar-token-longbytesitem"><code class="xref docutils literal notranslate"><span class="pre">longbytesitem</span></code></a>* &quot;'''&quot; | '&quot;&quot;&quot;' <a class="reference internal" href="#grammar-token-longbytesitem"><code class="xref docutils literal notranslate"><span class="pre">longbytesitem</span></code></a>* '&quot;&quot;&quot;'
<strong id="grammar-token-shortbytesitem">shortbytesitem</strong> ::=  <a class="reference internal" href="#grammar-token-shortbyteschar"><code class="xref docutils literal notranslate"><span class="pre">shortbyteschar</span></code></a> | <a class="reference internal" href="#grammar-token-bytesescapeseq"><code class="xref docutils literal notranslate"><span class="pre">bytesescapeseq</span></code></a>
<strong id="grammar-token-longbytesitem">longbytesitem </strong> ::=  <a class="reference internal" href="#grammar-token-longbyteschar"><code class="xref docutils literal notranslate"><span class="pre">longbyteschar</span></code></a> | <a class="reference internal" href="#grammar-token-bytesescapeseq"><code class="xref docutils literal notranslate"><span class="pre">bytesescapeseq</span></code></a>
<strong id="grammar-token-shortbyteschar">shortbyteschar</strong> ::=  &lt;any ASCII character except &quot;\&quot; or newline or the quote&gt;
<strong id="grammar-token-longbyteschar">longbyteschar </strong> ::=  &lt;any ASCII character except &quot;\&quot;&gt;
<strong id="grammar-token-bytesescapeseq">bytesescapeseq</strong> ::=  &quot;\&quot; &lt;any ASCII character&gt;
</pre>
<p>이 생성 규칙이 보여주지 못하는 한 가지 문법적 제약은 <a class="reference internal" href="#grammar-token-stringprefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">stringprefix</span></code></a> 나 <a class="reference internal" href="#grammar-token-bytesprefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">bytesprefix</span></code></a> 와 리터럴의 나머지 부분 사이에 공백이 허락되지 않는다는 것입니다. 소스 문자 집합은 인코딩 선언으로 정의됩니다; 소스 파일에 인코딩 선언이 없으면 UTF-8입니다. <a class="reference internal" href="#encodings"><span class="std std-ref">인코딩 선언</span></a> 섹션을 보세요.</p>
<p id="index-16">쉬운 말로 하자면, 두 가지 리터럴은 한 쌍의 작은따옴표(<code class="docutils literal notranslate"><span class="pre">'</span></code>) 나 큰따옴표(<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>)로 둘러싸일 수 있습니다. 또한, 둘 다 한 쌍의 삼중 작은따옴표나 큰따옴표로 둘러싸일 수도 있습니다 (이것들은 보통 <em>삼중 따옴표 된 문자열</em> 이라고 불립니다). 역 슬래시(<code class="docutils literal notranslate"><span class="pre">\</span></code>) 문자는 홀로 쓰이면 특별한 의미가 있는 문자들을 이스케이핑할 때 사용되는데, 개행문자, 역 슬래시 자신, 따옴표 문자가 그것입니다.</p>
<p>바이트열(bytes) 리터럴은 항상 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'B'</span></code> 를 앞에 붙입니다; <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 형의 인스턴스 대신 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 형의 인스턴스를 만듭니다. 오직 ASCII 문자들만 포함할 수 있습니다. 코드값이 128보다 크거나 같은 값들은 반드시 이스케이핑으로 표현되어야 합니다.</p>
<p>문자열과 바이트열 리터럴 모두 선택적으로 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">'R'</span></code> 문자를 앞에 붙일 수 있습니다. 이런 문자열을 날 문자열(<em class="dfn">raw strings</em>) 이라고 하는데, 역 슬래시를 평범한 문자로 취급합니다. 결과적으로, 문자열 리터럴에서, 날 문자열에 있는 <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> 와 <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> 이스케이프는 특별하게 처리되지 않습니다. 파이썬 2.x의 날 유니코드 리터럴이 파이썬 3.x와 다르게 동작합니다는 것을 고려해서, <code class="docutils literal notranslate"><span class="pre">'ur'</span></code> 문법은 지원되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>파이썬 2.x 에서는 문자열 리터럴의 앞에 <cite>'ur'</cite> 을 붙여서 날 유니코드 리터럴을 만들 수 있는데,
이 경우는 특별히 <cite>'U'</cite> 와 <cite>'u'</cite> 이스케이프를 유니코드 문자열에서와 동일하게 처리합니다.
파이썬 3.x 는 이 기능을 지원하지 않습니다.</p>
<p class="last">한편 파이썬 3.0 에서는 기본 문자열이 유니코드이기 때문에 리터럴 앞에 <cite>'u'</cite> 를 붙이는 표현을 지원하지 않았으나,
파이썬 2.x 와 3.x 에서 동시에 실행될 수 있는 코드 작성을 지원하기 위해 파이썬 3.3 부터 지원하기 시작했습니다.
그런데 <cite>'ur'</cite> 을 붙이는 경우는 <cite>'r'</cite> 을 붙이는 경우와 동일한 결과를 주어야 하는데, 앞서 언급한 것처럼
<cite>'U'</cite> 와 <cite>'u'</cite> 이스케이프 지원여부에 있어서 이미 파이썬 2.x 와 차이가 나기 시작했습니다.
이 때문에 <cite>'ur'</cite> 을 붙이는 리터럴을 지원하지 않기로 했습니다. 사용하면 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으킵니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span>날 바이트열 리터럴의 <code class="docutils literal notranslate"><span class="pre">'br'</span></code> 와 같은 의미가 있는 <code class="docutils literal notranslate"><span class="pre">'rb'</span></code> 접두어가 추가되었습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">예전에는 리터럴 접두어를 여러개 사용하는 경우, 정해진 순서대로 사용해야만 했습니다. 즉 <code class="docutils literal notranslate"><span class="pre">'br'</span></code> 은 가능하지만
<code class="docutils literal notranslate"><span class="pre">'rb'</span></code> 는 허락되지 않는 식입니다. 이는 쓸데없이 프로그래머의 기억력을 시험하는 것이고, 모든
조합을 허락하는 방향으로 수정되었습니다. 구문 정의를 보면 분명하게 드러납니다.</p>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span>파이썬 2.x 와 3.x 에서 동시에 지원하는 코드들의 유지보수를 단순화하기 위해 예전에 사용되던 유니코드 리터럴 (<code class="docutils literal notranslate"><span class="pre">u'value'</span></code>)이 다시 도입되었습니다. 자세한 정보는 <span class="target" id="index-33"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0414"><strong>PEP 414</strong></a> 에 나옵니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'f'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'F'</span></code> 를 접두어로 갖는 문자열 리터럴은 포맷 문자열 리터럴(<em class="dfn">formatted string literal</em>)입니다; <a class="reference internal" href="#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a> 을 보세요. <code class="docutils literal notranslate"><span class="pre">'f'</span></code> 는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 과 결합할 수 있습니다, 하지만, <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'u'</span></code> 와는 결합할 수 없습니다. 따라서 날 포맷 문자열은 가능하지만, 포맷 바이트열 리터럴은 불가능합니다.</p>
<p>삼중 따옴표 된 리터럴에서, 세 개의 이스케이핑 되지 않은 개행 문자와 따옴표가 허락됩니다 (그리고 유지됩니다). 예외는 한 줄에 세 개의 이스케이핑 되지 않은 따옴표가 나오는 것인데, 리터럴을 종료시킵니다. (&quot;따옴표&quot;는 리터럴을 시작하는데 사용한 문자입니다. 즉, <code class="docutils literal notranslate"><span class="pre">'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>)</p>
<p id="index-18"><code class="docutils literal notranslate"><span class="pre">'r'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'R'</span></code> 접두어가 붙지 않은 이상, 문자열과 바이트열 리터럴에 포함된 이스케이프 시퀀스는 표준 C에서 사용된 것과 비슷한 규칙으로 해석됩니다. 인식되는 이스케이프 시퀀스는 이렇습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="58%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">이스케이프 시퀀스</th>
<th class="head">의미</th>
<th class="head">유의 사항</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\newline</span></code></td>
<td>역 슬래시와 개행 문자가 무시됩니다</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\\</span></code></td>
<td>역 슬래시 (<code class="docutils literal notranslate"><span class="pre">\</span></code>)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\'</span></code></td>
<td>작은따옴표 (<code class="docutils literal notranslate"><span class="pre">'</span></code>)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\&quot;</span></code></td>
<td>큰따옴표 (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\a</span></code></td>
<td>ASCII 벨 (BEL)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\b</span></code></td>
<td>ASCII 백스페이스 (BS)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\f</span></code></td>
<td>ASCII 폼 피드 (FF)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\n</span></code></td>
<td>ASCII 라인 피드 (LF)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\r</span></code></td>
<td>ASCII 캐리지 리턴 (CR)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\t</span></code></td>
<td>ASCII 가로 탭 (TAB)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\v</span></code></td>
<td>ASCII 세로 탭 (VT)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\ooo</span></code></td>
<td>8진수 <em>ooo</em> 로 지정된 문자</td>
<td>(1,3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\xhh</span></code></td>
<td>16진수 <em>hh</em> 로 지정된 문자</td>
<td>(2,3)</td>
</tr>
</tbody>
</table>
<p>문자열 리터럴에서만 인식되는 이스케이프 시퀀스는:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="58%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">이스케이프 시퀀스</th>
<th class="head">의미</th>
<th class="head">유의 사항</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\N{name}</span></code></td>
<td>유니코드 데이터베이스에서 <em>name</em> 이라고 이름 붙여진 문자</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\uxxxx</span></code></td>
<td>16-bit 16진수 <em>xxxx</em> 로 지정된 문자</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\Uxxxxxxxx</span></code></td>
<td>32-bit 16진수 <em>xxxxxxxx</em> 로 지정된 문자</td>
<td>(6)</td>
</tr>
</tbody>
</table>
<p>유의 사항:</p>
<ol class="arabic">
<li><p class="first">표준 C와 마찬가지로, 최대 세 개의 8진수가 허용됩니다.</p>
</li>
<li><p class="first">표준 C와는 달리, 정확히 두 개의 16진수가 제공되어야 합니다.</p>
</li>
<li><p class="first">바이트열 리터럴에서, 16진수와 8진수 이스케이프는 지정된 값의 바이트를 표현합니다. 문자열 리터럴에서는, 이 이스케이프는 지정된 값의 유니코드 문자를 표현합니다.</p>
</li>
<li><div class="first versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>별칭 <a class="footnote-reference" href="#id13" id="id10">[1]</a> 지원이 추가되었습니다</p>
</div>
</li>
<li><p class="first">정확히 4개의 16진수를 필요로 합니다.</p>
</li>
<li><p class="first">이 방법으로 모든 유니코드를 인코딩할 수 있습니다. 정확히 8개의 16진수가 필요합니다.</p>
</li>
</ol>
<p id="index-19">표준 C와는 달리, 인식되지 않는 모든 이스케이프 시퀀스는 문자열에 변경되지 않은 상태로 남게 됩니다. 즉, <em>역 슬래시가 결과에 남게 됩니다</em>. (이 동작은 디버깅할 때 쓸모가 있습니다. 이스케이프 시퀀스가 잘못 입력되었을 때, 최종 결과에서 잘못된 부분을 쉽게 인지할 수 있습니다.) 문자열 리터럴에서만 인식되는 이스케이프 시퀀스가, 바이트열 리터럴에서는 인식되지 않는 부류임에 주목하십시오.</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>인식되지 않는 이스케이프 시퀀스는 DeprecationWarning 을 만듭니다. 언젠가 파이썬의 미래 버전에서는 SyntaxError 로 취급될 것입니다.</p>
</div>
</div></blockquote>
<p>날 리터럴에서 조차, 따옴표는 역 슬래시로 이스케이프 됩니다. 하지만 역 슬래시가 결과에 남게 됩니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">r&quot;\&quot;&quot;</span></code> 는 올바른 문자열 리터럴인데, 두 개의 문자가 들어있습니다: 역 슬래시와 큰따옴표; <code class="docutils literal notranslate"><span class="pre">r&quot;\&quot;</span></code> 는 올바른 문자열 리터럴이 아닙니다 (날 문자열조차 홀수개의 역 슬래시로 끝날 수 없습니다.). 좀 더 명확하게 말하자면, 날 리터럴은 하나의 역 슬래시로 끝날 수 없습니다(역 슬래시가 뒤에 오는 따옴표를 이스케이프 시키기 때문입니다). 역 슬래시와 바로 뒤에 오는 개행문자는 줄 결합이 <em>아니라</em> 리터럴에 포함되는 두 개의 문자로 인식됨에 주의해야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">날 리터럴에만 해당하는 내용입니다. 보통 리터럴에서는 줄 결합으로 인식됩니다.</p>
</div>
</div>
<div class="section" id="string-literal-concatenation">
<span id="string-concatenation"></span><h3>2.4.2. 문자열 리터럴 이어붙이기<a class="headerlink" href="#string-literal-concatenation" title="제목 주소">¶</a></h3>
<p>여러 개의 문자열이나 바이트열 리터럴을 (공백으로 분리해서) 여러 개 인접해서 나열하는 것이 허락되고, 그 의미는 이어붙인 것과 같습니다. 각 리터럴이 서로 다른 따옴표를 사용해도 됩니다. 그래서, <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span> <span class="pre">'world'</span></code> 는 <code class="docutils literal notranslate"><span class="pre">&quot;helloworld&quot;</span></code> 와 동등합니다. 이 기능은 긴 문자열을 편의상 여러 줄로 나눌 때 필요한 역 슬래시를 줄여줍니다. 각 문자열 단위마다 주석을 붙이는 것도 가능합니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;[A-Za-z_]&quot;</span>       <span class="c1"># 영문자 또는 밑줄</span>
           <span class="s2">&quot;[A-Za-z0-9_]*&quot;</span>   <span class="c1"># 영문자, 숫자 또는 밑줄</span>
          <span class="p">)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">두 문자열 리터럴 사이에 공백이 없어도 됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">문자열 리터럴과 바이트열 리터럴을 이어붙이는 것은 허용되지 않습니다. 시도하면 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으킵니다.</p>
</div>
<p>이 기능이 문법 수준에서 정의되고는 있지만, 컴파일 시점에 구현됨에 주의해야 합니다. 실행 시간에 문자열 표현을 이어붙이기 위해서는 '+' 연산자를 사용해야 합니다. 리터럴 이어붙이기가 요소별로 다른 따옴표를 사용할 수 있고 (날 문자열과 삼중 따옴표 문자열을 이어붙이는 것조차 가능합니다), 포맷 문자열 리터럴을 보통 문자열 리터럴과 이어붙일 수 있음에 유의해야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">파이썬 코드를 바이트코드로 변환하는 단계를 컴파일 단계라고 합니다. 이 바이트 코드를 실행하는 단계를 실행 단계라고 합니다.
컴파일 시점에 이어붙이기가 구현된다는 말의 뜻은, 바이트코드에 이미 이어붙여진 문자열 리터럴이 들어가고, 실행 시점에서는
이어붙이기가 발생하지 않는다는 뜻입니다. 그러면 실행시점에 값이 구해지는 f-문자열이 포함될 경우 어떻게 되는가 하는 의문이
들 수 있습니다. 컴파일 시점에 이어붙이기가 일어나지만 그 결과가 f-문자열입니다.</p>
</div>
</div>
<div class="section" id="formatted-string-literals">
<span id="f-strings"></span><span id="index-20"></span><h3>2.4.3. 포맷 문자열 리터럴<a class="headerlink" href="#formatted-string-literals" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
<p>포맷 문자열 리터럴(<em class="dfn">formatted string literal</em>) 또는 <em class="dfn">f-문자열 (f-string)</em> 은 <code class="docutils literal notranslate"><span class="pre">'f'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'F'</span></code> 를 앞에 붙인 문자열 리터럴입니다. 이 문자열은 치환 필드를 포함할 수 있는데, 중괄호 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 로 구분되는 표현식입니다. 다른 문자열 리터럴이 항상 상숫값을 갖지만, 포맷 문자열 리터럴은 실행시간에 계산되는 표현식입니다.</p>
<p>이스케이프 시퀀스는 일반 문자열 리터럴처럼 디코딩됩니다 (동시에 날 문자열인 경우는 예외입니다). 디코딩 후에 문자열의 내용은 다음과 같은 문법을 따릅니다:</p>
<pre>
<strong id="grammar-token-f-string">f_string         </strong> ::=  (<a class="reference internal" href="#grammar-token-literal-char"><code class="xref docutils literal notranslate"><span class="pre">literal_char</span></code></a> | &quot;{{&quot; | &quot;}}&quot; | <a class="reference internal" href="#grammar-token-replacement-field"><code class="xref docutils literal notranslate"><span class="pre">replacement_field</span></code></a>)*
<strong id="grammar-token-replacement-field">replacement_field</strong> ::=  &quot;{&quot; <a class="reference internal" href="#grammar-token-f-expression"><code class="xref docutils literal notranslate"><span class="pre">f_expression</span></code></a> [&quot;!&quot; <a class="reference internal" href="#grammar-token-conversion"><code class="xref docutils literal notranslate"><span class="pre">conversion</span></code></a>] [&quot;:&quot; <a class="reference internal" href="#grammar-token-format-spec"><code class="xref docutils literal notranslate"><span class="pre">format_spec</span></code></a>] &quot;}&quot;
<strong id="grammar-token-f-expression">f_expression     </strong> ::=  (<a class="reference internal" href="expressions.html#grammar-token-conditional-expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)
                         (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-conditional-expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | &quot;,&quot; &quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-or-expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)* [&quot;,&quot;]
                       | <a class="reference internal" href="expressions.html#grammar-token-yield-expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>
<strong id="grammar-token-conversion">conversion       </strong> ::=  &quot;s&quot; | &quot;r&quot; | &quot;a&quot;
<strong id="grammar-token-format-spec">format_spec      </strong> ::=  (<a class="reference internal" href="#grammar-token-literal-char"><code class="xref docutils literal notranslate"><span class="pre">literal_char</span></code></a> | NULL | <a class="reference internal" href="#grammar-token-replacement-field"><code class="xref docutils literal notranslate"><span class="pre">replacement_field</span></code></a>)*
<strong id="grammar-token-literal-char">literal_char     </strong> ::=  &lt;any code point except &quot;{&quot;, &quot;}&quot; or NULL&gt;
</pre>
<p>중괄호 바깥 부분은 일반 리터럴처럼 취급되는데, 이중 중괄호 <code class="docutils literal notranslate"><span class="pre">'{{'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'}}'</span></code> 가 대응하는 단일 중괄호로 치환된다는 점만 예외입니다. 하나의 여는 중괄호 <code class="docutils literal notranslate"><span class="pre">'{'</span></code> 는 치환 필드를 시작시키는데, 파이썬 표현식이 뒤따릅니다. 표현식 뒤로는 변환(conversion) 필드가 올 수 있는데, 느낌표 <code class="docutils literal notranslate"><span class="pre">'!'</span></code> 로 시작합니다. 포맷 지정자(format specifier)도 덧붙일 수 있는데, 콜론 <code class="docutils literal notranslate"><span class="pre">':'</span></code> 으로 시작합니다. 치환 필드는 닫는 중괄호 <code class="docutils literal notranslate"><span class="pre">'}'</span></code> 로 끝납니다.</p>
<p>포맷 문자열 리터럴의 표현식은 괄호로 둘러싸인 일반적인 파이썬 표현식으로 취급되는데, 몇 가지 예외가 있습니다. 빈 표현식은 허락되지 않고, <a class="reference internal" href="expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 표현식은 명시적인 괄호로 둘러싸야 합니다. 치환 표현식은 개행문자를 포함할 수 있으나 (예를 들어, 삼중 따옴표 된 문자열) 주석은 포함할 수 없습니다. 각 표현식은 포맷 문자열 리터럴이 등장한 지점의 문맥에서 왼쪽에서 오른쪽으로 계산됩니다.</p>
<p>변환(conversion)이 지정되면, 표현식의 결과가 포매팅 전에 변환됩니다. 변환 <code class="docutils literal notranslate"><span class="pre">'!s'</span></code> 는 결과에 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 을 호출하고, <code class="docutils literal notranslate"><span class="pre">'!r'</span></code> 은 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 을 호출하고, <code class="docutils literal notranslate"><span class="pre">'!a'</span></code> 은 <a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a> 를 호출합니다.</p>
<p>결과는 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 프로토콜로 포매팅합니다. 포맷 지정자는 표현식이나 변환 결과의 <a class="reference internal" href="datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 메서드 로 전달됩니다. 포맷 지정자가 생략되면 빈 문자열이 전달됩니다. 이제 포맷된 결과가 최종 문자열에 삽입됩니다.</p>
<p>최상위 포맷 지정자는 중첩된 치환 필드들을 포함할 수 있습니다. 이 중첩된 필드들은 그들 자신의 변환 필드와 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">포맷 지정자</span></a>를 포함할 수 있지만, 깊이 중첩된 치환 필드들을 포함할 수는 없습니다. <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">포맷 지정자 간이 언어</span></a>는 문자열 .format() 메서드에서 사용되는 것과 같습니다.</p>
<p>포맷 문자열 리터럴을 이어붙일 수는 있지만, 치환 필드가 여러 리터럴로 쪼개질 수는 없습니다.</p>
<p>포맷 문자열 리터럴의 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Fred&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s2">&quot;He said his name is </span><span class="si">{name!r}</span><span class="s2">.&quot;</span>
<span class="go">&quot;He said his name is &#39;Fred&#39;.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s2">&quot;He said his name is {repr(name)}.&quot;</span>  <span class="c1"># repr() 은 !r 과 같습니다</span>
<span class="go">&quot;He said his name is &#39;Fred&#39;.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;12.34567&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s2">&quot;result: {value:</span><span class="si">{width}</span><span class="s2">.</span><span class="si">{precision}</span><span class="s2">}&quot;</span>  <span class="c1"># 중첩된 필드</span>
<span class="go">&#39;result:      12.35&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2017</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s2">&quot;{today:%B </span><span class="si">%d</span><span class="s2">, %Y}&quot;</span>  <span class="c1"># 날짜 포맷 지정자 사용</span>
<span class="go">&#39;January 27, 2017&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{number:#0x}</span><span class="s2">&quot;</span>  <span class="c1"># 정수 포맷 지정자 사용</span>
<span class="go">&#39;0x400&#39;</span>
</pre></div>
</div>
<p>일반적인 문자열 리터럴과 같은 문법을 공유하는 것으로 인한 결과는 치환 필드에 사용되는 문자들이 포맷 문자열 리터럴을 감싸는 따옴표와 충돌하지 않아야 한다는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="s2">&quot;abc </span><span class="si">{a[&quot;x&quot;]}</span><span class="s2"> def&quot;</span>    <span class="c1"># 에러: 바깥 문자열 리터럴이 너무 일찍 종료되었습니다</span>
<span class="n">f</span><span class="s2">&quot;abc </span><span class="si">{a[&#39;x&#39;]}</span><span class="s2"> def&quot;</span>    <span class="c1"># 해결 방법: 다른 따옴표를 사용하세요</span>
</pre></div>
</div>
<p>포맷 표현식에는 역 슬래시를 사용할 수 없고, 사용하면 에러가 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="s2">&quot;newline: {ord(&#39;</span><span class="se">\n</span><span class="s2">&#39;)}&quot;</span>  <span class="c1"># SyntaxError 를 일으킵니다</span>
</pre></div>
</div>
<p>역 슬래시 이스케이프가 필요한 값을 포함하려면, 임시 변수를 만들면 됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">newline</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s2">&quot;newline: </span><span class="si">{newline}</span><span class="s2">&quot;</span>
<span class="go">&#39;newline: 10&#39;</span>
</pre></div>
</div>
<p>포맷 문자열 리터럴은 독스트링(docstring)으로 사용될 수 없습니다. 표현식이 전혀 없더라도 마찬가집니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">f</span><span class="s2">&quot;Not a docstring&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>포맷 문자열 리터럴 추가에 대한 제안은 <span class="target" id="index-34"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0498"><strong>PEP 498</strong></a> 을 참조하고, 관련된 포맷 문자열 메커니즘을 사용하는 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 도 살펴보는 것이 좋습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">포맷 바이트열 리터럴을 지원하지 않는 가장 중요한 이유는 포맷 프로토콜이 바이트열을 제공하지 않는다는 것입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>포멧 문자열 리터럴이 수용하는 표현식은 그 본래의 목적에 비해 지나치다 싶을 정도로 자유도가 높습니다.
구문 해석적으로 문제가 없는 이상 파이썬의 표현식 전체를 허락하려고 하고 있습니다. 그 중간 지대를 설정하는 것이
까다롭기 때문일 것으로 짐작되는데, 다음과 같은 괴상한 상황도 발생합니다.</p>
<blockquote class="last">
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">((</span><span class="k">lambda</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;{yield 1}&quot;</span><span class="p">)())</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>치환 표현식을 남용하지 말고 읽기 쉬운 상태를 유지하는 것이 바람직합니다.</p>
</div></blockquote>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">치환 표현식은 임의의 인스턴스를 돌려줄 수 있습니다. 최종 출력을 결정하는 것은 이 인스턴스의 <code class="docutils literal notranslate"><span class="pre">__format__()</span></code> 메서드 인데,
얼마든지 새로 정의할 수 있는 메서드입니다. <code class="docutils literal notranslate"><span class="pre">':'</span></code> 문자 뒤에 오는 포맷 지정자를 처리하는 것도 같은 메서드이기 때문에,
인스턴스 전용의 포맷 지정자를 정의하는 것도 가능합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p><a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 은 그 형식이 포맷 문자열 리터럴과 유사하기 때문에, 포맷 문자열 리터럴이 지원되지 않는 3.6 이전의
버전에서는 이런 식으로 그 표현의 일부를 흉내낼 수 있습니다.</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Fred&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="s2">&quot;He said his name is </span><span class="si">{name!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="go">&quot;He said his name is &#39;Fred&#39;.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;12.34567&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="s2">&quot;result: {value:</span><span class="si">{width}</span><span class="s2">.</span><span class="si">{precision}</span><span class="s2">}&quot;</span><span class="p">)</span>
<span class="go">&#39;result:      12.35&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2017</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="s2">&quot;{today:%B </span><span class="si">%d</span><span class="s2">, %Y}&quot;</span><span class="p">)</span>
<span class="go">&#39;January 27, 2017&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{number:#0x}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&#39;0x400&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="numeric-literals">
<span id="numbers"></span><h3>2.4.4. 숫자 리터럴<a class="headerlink" href="#numeric-literals" title="제목 주소">¶</a></h3>
<p id="index-22">숫자 리터럴에는 세 가지 종류가 있습니다: 정수, 실수, 허수. 복소수 리터럴 같은 것은 없습니다 (복소수는 실수와 허수를 더해서 만들어집니다.)</p>
<p>숫자 리터럴이 부호를 포함하지 않는 것에 주의해야 합니다; <code class="docutils literal notranslate"><span class="pre">-1</span></code> 과 같은 구문은 일 항 연산자 '<code class="docutils literal notranslate"><span class="pre">-</span></code>' 과 리터럴 <code class="docutils literal notranslate"><span class="pre">1</span></code> 로 구성된 표현식입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">파이썬의 <code class="docutils literal notranslate"><span class="pre">float</span></code> 형이 표현하는 값을 가리키는데 &quot;실수(real number)&quot; 라는 용어를 사용합니다.
하지만 다른 대부분의 언어들과 마찬가지로 실제값은 부동소수점수 (floating point number) 로 표현되는데,
그 정밀도가 유한하기 때문에 무리수와 이진법 표현에서 무한히 반복되는 유리수를 표현할 수 없습니다.
사실 상 실수를 유한한 개수의 유리수들 중 하나로 근사한 값을 사용하는 것입니다. 때문에 엄밀히 따지자면 부동소수점수가
더 정확한 표현이지만, 그 용도가 실수를 다루기 위한 것이기 때문에 간단히 실수라고 표기합니다.</p>
</div>
</div>
<div class="section" id="integer-literals">
<span id="integers"></span><h3>2.4.5. 정수 리터럴<a class="headerlink" href="#integer-literals" title="제목 주소">¶</a></h3>
<p>정수 리터럴은 다음과 같은 어휘 정의로 표현됩니다:</p>
<pre>
<strong id="grammar-token-integer">integer     </strong> ::=  <a class="reference internal" href="#grammar-token-decinteger"><code class="xref docutils literal notranslate"><span class="pre">decinteger</span></code></a> | <a class="reference internal" href="#grammar-token-bininteger"><code class="xref docutils literal notranslate"><span class="pre">bininteger</span></code></a> | <a class="reference internal" href="#grammar-token-octinteger"><code class="xref docutils literal notranslate"><span class="pre">octinteger</span></code></a> | <a class="reference internal" href="#grammar-token-hexinteger"><code class="xref docutils literal notranslate"><span class="pre">hexinteger</span></code></a>
<strong id="grammar-token-decinteger">decinteger  </strong> ::=  <a class="reference internal" href="#grammar-token-nonzerodigit"><code class="xref docutils literal notranslate"><span class="pre">nonzerodigit</span></code></a> ([&quot;_&quot;] <a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>)* | &quot;0&quot;+ ([&quot;_&quot;] &quot;0&quot;)*
<strong id="grammar-token-bininteger">bininteger  </strong> ::=  &quot;0&quot; (&quot;b&quot; | &quot;B&quot;) ([&quot;_&quot;] <a class="reference internal" href="#grammar-token-bindigit"><code class="xref docutils literal notranslate"><span class="pre">bindigit</span></code></a>)+
<strong id="grammar-token-octinteger">octinteger  </strong> ::=  &quot;0&quot; (&quot;o&quot; | &quot;O&quot;) ([&quot;_&quot;] <a class="reference internal" href="#grammar-token-octdigit"><code class="xref docutils literal notranslate"><span class="pre">octdigit</span></code></a>)+
<strong id="grammar-token-hexinteger">hexinteger  </strong> ::=  &quot;0&quot; (&quot;x&quot; | &quot;X&quot;) ([&quot;_&quot;] <a class="reference internal" href="#grammar-token-hexdigit"><code class="xref docutils literal notranslate"><span class="pre">hexdigit</span></code></a>)+
<strong id="grammar-token-nonzerodigit">nonzerodigit</strong> ::=  &quot;1&quot;...&quot;9&quot;
<strong id="grammar-token-digit">digit       </strong> ::=  &quot;0&quot;...&quot;9&quot;
<strong id="grammar-token-bindigit">bindigit    </strong> ::=  &quot;0&quot; | &quot;1&quot;
<strong id="grammar-token-octdigit">octdigit    </strong> ::=  &quot;0&quot;...&quot;7&quot;
<strong id="grammar-token-hexdigit">hexdigit    </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a> | &quot;a&quot;...&quot;f&quot; | &quot;A&quot;...&quot;F&quot;
</pre>
<p>가용한 메모리에 저장될 수 있는지와는 별개로 정수 리터럴의 길이에 제한은 없습니다.</p>
<p>밑줄은 리터럴의 숫자 값을 결정할 때 고려되지 않습니다. 가독성을 높이기 위해 숫자들을 무리 지을 때 쓸모가 있습니다. 밑줄은 숫자 사이나 <code class="docutils literal notranslate"><span class="pre">0x</span></code> 와 같은 진수 지정자(base specifier) 다음에 나올 수 있는데, 한 번에 하나만 사용될 수 있습니다.</p>
<p>0 이 아닌 10진수가 0으로 시작할 수 없음에 주의해야 합니다. 3.0 버전 이전의 파이썬에서 사용한 C 스타일의 8진수 리터럴과 혼동되는 것을 막기 위함입니다.</p>
<p>정수 리터럴의 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span>     <span class="mi">2147483647</span>                        <span class="mo">0o177</span>    <span class="mb">0b100110111</span>
<span class="mi">3</span>     <span class="mi">79228162514264337593543950336</span>     <span class="mo">0o377</span>    <span class="mh">0xdeadbeef</span>
      <span class="mi">100</span><span class="n">_000_000_000</span>                   <span class="mi">0</span><span class="n">b_1110_0101</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>리터럴에서 숫자들의 그룹을 표현할 목적으로 밑줄을 허락합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">접두어 <code class="docutils literal notranslate"><span class="pre">0b</span></code> 나 <code class="docutils literal notranslate"><span class="pre">0B</span></code> 는 이진수 리터럴, <code class="docutils literal notranslate"><span class="pre">0o</span></code> 나 <code class="docutils literal notranslate"><span class="pre">0O</span></code> 는 8진수 리터럴, <code class="docutils literal notranslate"><span class="pre">0x</span></code> 나 <code class="docutils literal notranslate"><span class="pre">0X</span></code> 는 16진수 리터럴을 표현할 때 사용됩니다.</p>
</div>
</div>
<div class="section" id="floating-point-literals">
<span id="floating"></span><h3>2.4.6. 실수 리터럴<a class="headerlink" href="#floating-point-literals" title="제목 주소">¶</a></h3>
<p>실수 리터럴은 다음과 같은 어휘 정의로 표현됩니다:</p>
<pre>
<strong id="grammar-token-floatnumber">floatnumber  </strong> ::=  <a class="reference internal" href="#grammar-token-pointfloat"><code class="xref docutils literal notranslate"><span class="pre">pointfloat</span></code></a> | <a class="reference internal" href="#grammar-token-exponentfloat"><code class="xref docutils literal notranslate"><span class="pre">exponentfloat</span></code></a>
<strong id="grammar-token-pointfloat">pointfloat   </strong> ::=  [<a class="reference internal" href="#grammar-token-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a>] <a class="reference internal" href="#grammar-token-fraction"><code class="xref docutils literal notranslate"><span class="pre">fraction</span></code></a> | <a class="reference internal" href="#grammar-token-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a> &quot;.&quot;
<strong id="grammar-token-exponentfloat">exponentfloat</strong> ::=  (<a class="reference internal" href="#grammar-token-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a> | <a class="reference internal" href="#grammar-token-pointfloat"><code class="xref docutils literal notranslate"><span class="pre">pointfloat</span></code></a>) <a class="reference internal" href="#grammar-token-exponent"><code class="xref docutils literal notranslate"><span class="pre">exponent</span></code></a>
<strong id="grammar-token-digitpart">digitpart    </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a> ([&quot;_&quot;] <a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>)*
<strong id="grammar-token-fraction">fraction     </strong> ::=  &quot;.&quot; <a class="reference internal" href="#grammar-token-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a>
<strong id="grammar-token-exponent">exponent     </strong> ::=  (&quot;e&quot; | &quot;E&quot;) [&quot;+&quot; | &quot;-&quot;] <a class="reference internal" href="#grammar-token-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a>
</pre>
<p>정수부와 지수부는 항상 10진법으로 해석된다는 것에 주의해야 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">077e010</span></code> 는 올바른 표현이고, <code class="docutils literal notranslate"><span class="pre">77e10</span></code> 과 같은 숫자를 표현합니다. 실수 리터럴의 허락된 범위는 구현 세부 사항입니다. 정수 리터럴에서와 마찬가지로 밑줄로 숫자들의 묶음을 만드는 것도 지원됩니다.</p>
<p>실수 리터럴의 몇 가지 예를 듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">3.14</span>    <span class="mf">10.</span>    <span class="o">.</span><span class="mi">001</span>    <span class="mf">1e100</span>    <span class="mf">3.14e-10</span>    <span class="mf">0e0</span>    <span class="mf">3.14</span><span class="n">_15_93</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>리터럴에서 숫자들의 그룹을 표현할 목적으로 밑줄을 허락합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">정수 리터럴과 마찬가지로, 실수 리터럴 자체의 길이 제한은 없습니다. 하지만 파이썬의 정수는 무한 길이 정수를 지원하고 있는 반면,
실수는 고정된 크기의 메모리에 저장됩니다. 이 때문에 리터럴에 아무리 많은 숫자가 표현되더라도 실제 저장되는 값은 그 값의
근사값입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">리터럴의 허락된 범위가 구현 세부 사항이라는 뜻은, 파이썬은 실수를 표시하기 위해 플랫폼의 배정도 실수 표현을 그대로 사용하고,
이 표현은 플랫폼마다 다를 수 있다는 뜻입니다. 하지만 현대적인 대부분의 플랫폼에서는 IEEE 754 가 정의하는 배정도 부동 소수점
표현을 사용하기 때문에 대체로 같습니다. 현재 플랫폼에서 지원되는 가장 큰 실수는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.float_info.max</span></code> 이고,
가장 작은 실수는 그 것의 음의 값입니다. 절대값이 가장 작은 실수는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.float_info.min</span></code> 입니다.
IEEE 754 에서 두 값은 각각 <code class="docutils literal notranslate"><span class="pre">1.7976931348623157e+308</span></code> 과 <code class="docutils literal notranslate"><span class="pre">2.2250738585072014e-308</span></code> 입니다.</p>
</div>
</div>
<div class="section" id="imaginary-literals">
<span id="imaginary"></span><h3>2.4.7. 허수 리터럴<a class="headerlink" href="#imaginary-literals" title="제목 주소">¶</a></h3>
<p>허수 리터럴은 다음과 같은 어휘 정의로 표현됩니다:</p>
<pre>
<strong id="grammar-token-imagnumber">imagnumber</strong> ::=  (<a class="reference internal" href="#grammar-token-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a>) (&quot;j&quot; | &quot;J&quot;)
</pre>
<p>허수 리터럴은 실수부가 0.0인 복소수를 만듭니다. 복소수는 실수와 같은 범위 제약이 적용되는 한 쌍의 실수로 표현됩니다. 0이 아닌 실수부를 갖는 복소수를 만들려면, 실수를 더하면 됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(3+4j)</span></code>. 허수 리터럴의 몇 가지 예를 듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">3.14</span><span class="n">j</span>   <span class="mf">10.</span><span class="n">j</span>    <span class="mi">10</span><span class="n">j</span>     <span class="o">.</span><span class="mi">001</span><span class="n">j</span>   <span class="mf">1e100j</span>   <span class="mf">3.14e-10</span><span class="n">j</span>   <span class="mf">3.14</span><span class="n">_15_93j</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="operators">
<span id="id11"></span><h2>2.5. 연산자<a class="headerlink" href="#operators" title="제목 주소">¶</a></h2>
<p id="index-23">다음과 같은 토큰들은 연산자입니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+       -       *       **      /       //      %      @
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~
&lt;       &gt;       &lt;=      &gt;=      ==      !=
</pre></div>
</div>
</div>
<div class="section" id="delimiters">
<span id="id12"></span><h2>2.6. 구분자<a class="headerlink" href="#delimiters" title="제목 주소">¶</a></h2>
<p id="index-24">다음 토큰들은 문법에서 구분자(delimiter)로 기능합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(       )       [       ]       {       }
,       :       .       ;       @       =       -&gt;
+=      -=      *=      /=      //=     %=      @=
&amp;=      |=      ^=      &gt;&gt;=     &lt;&lt;=     **=
</pre></div>
</div>
<p>마침표는 실수와 허수 리터럴에서도 등장할 수 있습니다. 연속된 마침표 세 개는 생략부호 리터럴(ellipsis literal)이라는 특별한 의미가 있습니다. 목록 후반의 증분 대입 연산자(augmented assignment operator)들은 어휘적으로는 구분자로 기능하지만, 동시에 연산을 수행합니다.</p>
<p>다음의 인쇄되는 ASCII 문자들은 다른 토큰들 일부로서 특별한 의미가 있거나, 그렇지 않으면 어휘 분석기에 유의미합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&#39;       &quot;       #       \
</pre></div>
</div>
<p>다음의 인쇄되는 ASCII 문자들은 파이썬에서 사용되지 않습니다. 문자열 리터럴과 주석 이외의 곳에서 사용되는 것은 조건 없는 에러입니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$       ?       `
</pre></div>
</div>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[1]</a></td><td><a class="reference external" href="http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt">http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. 어휘 분석</a><ul>
<li><a class="reference internal" href="#line-structure">2.1. 줄 구조(Line structure)</a><ul>
<li><a class="reference internal" href="#logical-lines">2.1.1. 논리적인 줄</a></li>
<li><a class="reference internal" href="#physical-lines">2.1.2. 물리적인 줄</a></li>
<li><a class="reference internal" href="#comments">2.1.3. 주석</a></li>
<li><a class="reference internal" href="#encoding-declarations">2.1.4. 인코딩 선언</a></li>
<li><a class="reference internal" href="#explicit-line-joining">2.1.5. 명시적인 줄 결합</a></li>
<li><a class="reference internal" href="#implicit-line-joining">2.1.6. 묵시적인 줄 결합</a></li>
<li><a class="reference internal" href="#blank-lines">2.1.7. 빈 줄</a></li>
<li><a class="reference internal" href="#indentation">2.1.8. 들여쓰기</a></li>
<li><a class="reference internal" href="#whitespace-between-tokens">2.1.9. 토큰 사이의 공백</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-tokens">2.2. 다른 토큰들</a></li>
<li><a class="reference internal" href="#identifiers">2.3. 식별자와 키워드</a><ul>
<li><a class="reference internal" href="#keywords">2.3.1. 키워드</a></li>
<li><a class="reference internal" href="#reserved-classes-of-identifiers">2.3.2. 식별자의 예약 영역</a></li>
</ul>
</li>
<li><a class="reference internal" href="#literals">2.4. 리터럴</a><ul>
<li><a class="reference internal" href="#string-and-bytes-literals">2.4.1. 문자열과 바이트열 리터럴</a></li>
<li><a class="reference internal" href="#string-literal-concatenation">2.4.2. 문자열 리터럴 이어붙이기</a></li>
<li><a class="reference internal" href="#formatted-string-literals">2.4.3. 포맷 문자열 리터럴</a></li>
<li><a class="reference internal" href="#numeric-literals">2.4.4. 숫자 리터럴</a></li>
<li><a class="reference internal" href="#integer-literals">2.4.5. 정수 리터럴</a></li>
<li><a class="reference internal" href="#floating-point-literals">2.4.6. 실수 리터럴</a></li>
<li><a class="reference internal" href="#imaginary-literals">2.4.7. 허수 리터럴</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operators">2.5. 연산자</a></li>
<li><a class="reference internal" href="#delimiters">2.6. 구분자</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="introduction.html"
                        title="이전 장">1. 개요</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="datamodel.html"
                        title="다음 장">3. 데이터 모델</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="datamodel.html" title="3. 데이터 모델"
             >다음</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="1. 개요"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>