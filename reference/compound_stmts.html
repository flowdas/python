
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8. 복합문(Compound statements) &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="9. 최상위 요소들" href="toplevel_components.html" />
    <link rel="prev" title="7. 단순문(Simple statements)" href="simple_stmts.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/reference/compound_stmts.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="toplevel_components.html" title="9. 최상위 요소들"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="compound-statements">
<span id="compound"></span><h1>8. 복합문(Compound statements)<a class="headerlink" href="#compound-statements" title="제목 주소">¶</a></h1>
<p id="index-0">복합문은 다른 문장들(의 그룹들)을 포함합니다; 어떤 방법으로 그 다른 문장들의 실행에 영향을 주거나 제어합니다. 간단하게 표현할 때, 전체 복합문을 한 줄로 쓸 수 있기는 하지만, 일반적으로 복합문은 여러 줄에 걸칩니다.</p>
<p><a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>, <a class="reference internal" href="#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문장은 전통적인 제어 흐름 구조를 구현합니다. 문장들의 그룹에 대해 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 는 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 반면, <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 코드 블록 주변으로 초기화와 파이널리제이션 코드를 실행할 수 있도록 합니다. 함수와 클래스 정의 또한 문법적으로 복합문입니다.</p>
<p id="index-1">복합문은 하나나 그 이상의 '절'로 구성됩니다. 절은 헤더와 '스위트(suite)'로 구성됩니다. 특정 복합문의 절 헤더들은 모두 같은 들여쓰기 수준을 갖습니다. 각 절 헤더는 특별하게 식별되는 키워드로 시작하고 콜론으로 끝납니다. 스위트는 절에 의해 제어되는 문장들의 그룹입니다. 스위트는 헤더의 콜론 뒤에서 같은 줄에 세미콜론으로 분리된 하나나 그 이상의 단순문일 수 있습니다. 또는 그다음 줄에 들여쓰기 된 하나나 그 이상의 문장들일 수도 있습니다. 오직 후자의 형태만 중첩된 복합문을 포함할 수 있습니다; 다음과 같은 것은 올바르지 않은데, 대체로 뒤따르는 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절이 있다면 어떤 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 절에 속하는지 명확하지 않기 때문입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">test1</span><span class="p">:</span> <span class="k">if</span> <span class="n">test2</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>또한, 이 문맥에서 세미콜론이 콜론보다 더 강하게 결합해서, 다음과 같은 예에서, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 호출들은 모두 실행되거나 어느 하나도 실행되지 않습니다는 것에 주의해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>요약하면:</p>
<pre>
<strong id="grammar-token-compound-stmt">compound_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-if-stmt"><code class="xref docutils literal notranslate"><span class="pre">if_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-while-stmt"><code class="xref docutils literal notranslate"><span class="pre">while_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-for-stmt"><code class="xref docutils literal notranslate"><span class="pre">for_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-try-stmt"><code class="xref docutils literal notranslate"><span class="pre">try_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-with-stmt"><code class="xref docutils literal notranslate"><span class="pre">with_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-funcdef"><code class="xref docutils literal notranslate"><span class="pre">funcdef</span></code></a>
                   | <a class="reference internal" href="#grammar-token-classdef"><code class="xref docutils literal notranslate"><span class="pre">classdef</span></code></a>
                   | <a class="reference internal" href="#grammar-token-async-with-stmt"><code class="xref docutils literal notranslate"><span class="pre">async_with_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-async-for-stmt"><code class="xref docutils literal notranslate"><span class="pre">async_for_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-async-funcdef"><code class="xref docutils literal notranslate"><span class="pre">async_funcdef</span></code></a>
<strong id="grammar-token-suite">suite        </strong> ::=  <a class="reference internal" href="#grammar-token-stmt-list"><code class="xref docutils literal notranslate"><span class="pre">stmt_list</span></code></a> NEWLINE | NEWLINE INDENT <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">statement</span></code></a>+ DEDENT
<strong id="grammar-token-statement">statement    </strong> ::=  <a class="reference internal" href="#grammar-token-stmt-list"><code class="xref docutils literal notranslate"><span class="pre">stmt_list</span></code></a> NEWLINE | <a class="reference internal" href="#grammar-token-compound-stmt"><code class="xref docutils literal notranslate"><span class="pre">compound_stmt</span></code></a>
<strong id="grammar-token-stmt-list">stmt_list    </strong> ::=  <a class="reference internal" href="simple_stmts.html#grammar-token-simple-stmt"><code class="xref docutils literal notranslate"><span class="pre">simple_stmt</span></code></a> (&quot;;&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-simple-stmt"><code class="xref docutils literal notranslate"><span class="pre">simple_stmt</span></code></a>)* [&quot;;&quot;]
</pre>
<p id="index-2">문장들이 항상 <code class="docutils literal notranslate"><span class="pre">NEWLINE</span></code> 으로 끝나고 <code class="docutils literal notranslate"><span class="pre">DEDENT</span></code> 가 그 뒤를 따를 수 있음에 주목해야 합니다. 또한, 생략 가능한 연결 절들이 항상 문장을 시작시킬 수 없는 키워드로 시작하기 때문에, 모호함이 없다는 것도 주목하세요 (파이썬에서는 중첩된 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문이 들여쓰기 되는 것을 요구함으로써 '매달린(dangling) <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a>' 문제를 해결합니다).</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">'매달린(dangling) <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a>' 문제는, <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문이 중첩될 때, 뒤 따르는
<a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 가 어떤 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 와 결합하는지 모호함이 발생할 수 있다는 것입니다.
많은 언어들에서는 괄호를 사용한 구조를 통해 모호함을 제거하는 반면, 파이썬에서는 들여쓰기로 해결합니다.</p>
</div>
<p>명확함을 위해 다음에 오는 절들에서 나오는 문법 규칙들은 각 절을 별도의 줄에 놓도록 포매팅합니다.</p>
<div class="section" id="the-if-statement">
<span id="else"></span><span id="elif"></span><span id="if"></span><h2>8.1. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 문<a class="headerlink" href="#the-if-statement" title="제목 주소">¶</a></h2>
<p id="index-3"><a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문은 조건부 실행에 사용됩니다:</p>
<pre>
<strong id="grammar-token-if-stmt">if_stmt</strong> ::=  &quot;if&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
             (&quot;elif&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>)*
             [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
</pre>
<p>참이 되는 것을 발견할 때까지 표현식들의 값을 하나씩 차례대로 구해서 정확히 하나의 스위트를 선택합니다 (참과 거짓의 정의는 <a class="reference internal" href="expressions.html#booleans"><span class="std std-ref">논리 연산(Boolean operations)</span></a> 섹션을 보세요); 그런 다음 그 스위트를 실행합니다 (그리고는 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문의 다른 어떤 부분도 실행되거나 값이 구해지지 않습니다). 모든 표현식들이 거짓이면 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절의 스위트가 (있다면) 실행됩니다.</p>
</div>
<div class="section" id="the-while-statement">
<span id="while"></span><h2>8.2. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code> 문<a class="headerlink" href="#the-while-statement" title="제목 주소">¶</a></h2>
<p id="index-4"><a class="reference internal" href="#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 문은 표현식이 참인 동안 실행을 반복하는 데 사용됩니다:</p>
<pre>
<strong id="grammar-token-while-stmt">while_stmt</strong> ::=  &quot;while&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
                [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
</pre>
<p>이것은 표현식을 반복적으로 검사하고, 참이면, 첫 번째 스위트를 실행합니다; 표현식이 거짓이면 (처음부터 거짓일 수도 있습니다) <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절의 스위트가 (있다면) 실행되고 루프를 종료합니다.</p>
<p id="index-5">첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절을 실행하지 않고 루프를 종료합니다. 첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문은 스위트의 나머지 부분을 건너뛰고 표현식의 검사로 돌아갑니다.</p>
</div>
<div class="section" id="the-for-statement">
<span id="for"></span><h2>8.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 문<a class="headerlink" href="#the-for-statement" title="제목 주소">¶</a></h2>
<p id="index-6"><a class="reference internal" href="#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문은 (문자열, 튜플, 리스트 같은) 시퀀스 나 다른 이터러블 객체의 요소들을 이터레이트하는데 사용됩니다:</p>
<pre>
<strong id="grammar-token-for-stmt">for_stmt</strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target-list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="expressions.html#grammar-token-expression-list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
              [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
</pre>
<p>표현식 목록은 한 번만 값이 구해집니다; 이터러블 객체가 나와야 합니다. <code class="docutils literal notranslate"><span class="pre">expression_list</span></code> 의 결과로 이터레이터가 만들어집니다. 그런 다음 이터레이터가 제공하는 항목마다, 이터레이터가 돌려주는 순서대로, 스위트가 한 번씩 실행됩니다. 순환마다 각 항목이 대입의 표준 규칙 (<a class="reference internal" href="simple_stmts.html#assignment"><span class="std std-ref">대입문</span></a> 을 보세요) 으로 타깃 목록에 대입된 다음, 스위트가 실행됩니다. 항목들이 소진되었을 때 (이터레이터가 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으킬 때나 빈 시퀀스인 경우는 즉시 발생합니다), the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절의 스위트가 (있다면) 실행되고 루프를 종료합니다.</p>
<p id="index-7">첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절을 실행하지 않고 루프를 종료합니다. 첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문은 스위트의 나머지 부분을 건너뛰고 다음 항목으로 넘어가거나, 다음 항목이 없으면 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절로 갑니다.</p>
<p>for-루프는 타깃 목록의 변수들에 대입합니다. for-루프의 스위트에서 이루어진 것들도 포함해서, 그 변수에 앞서 대입된 값들을 모두 덮어씁니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>             <span class="c1"># 이렇게 해도 범위내의 다음 인덱스로</span>
                      <span class="c1"># 덮어쓰기 때문에 for-루프에</span>
                      <span class="c1"># 영향을 주지 않습니다</span>
</pre></div>
</div>
<p id="index-8">타깃 목록의 이름들은 루프가 종료될 때 삭제되지 않지만, 시퀀스가 비어있다면, 루프에 의해 전혀 대입이 일어나지 않을 수도 있습니다. 힌트: 내장 함수 <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a> 는 파스칼의 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">a</span> <span class="pre">to</span> <span class="pre">b</span> <span class="pre">do</span></code> 의 효과를 흉내 내는데 적합한 정수의 이터레이터를 돌려줍니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">list(range(3))</span></code> 는 리스트 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code> 를 돌려줍니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p id="index-9">시퀀스가 루프에 의해 수정될 때는 미묘한 점이 있습니다 (이것은 오직 가변 시퀀스에서만 일어납니다, 가령 리스트). 다음에 어떤 항목이 사용될지를 추적하는 내부 카운터가 사용되고, 각 이터레이션마다 증가합니다. 이 카운터가 시퀀스의 길이에 도달하면 루프가 종료됩니다. 이것은 만약 스위트가 시퀀스에서 현재 (또는 그 이전의) 항목을 삭제하면, 다음 항목을 건너뛰게 된다는 뜻입니다 (다음 항목이 이미 다뤄진 현재 항목의 인덱스를 갖게 되기 때문입니다). 마찬가지로, 스위트가 현재 항목 앞으로 시퀀스에 항목을 삽입하면, 현재 항목은 루프의 다음 순환에서 현재 항목이 한 번 더 다뤄지게 됩니다. 이것은 고약한 버그로 이어질 수 있는데, 전체 시퀀스의 슬라이스로 임시 사본을 만듦으로써 피할 수 있습니다, 예를 들어</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[:]:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-flowdas last admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">본문에서 언급하고 있는 카운터는 for-루프가 유지하는 것이 아닙니다. 이 카운터를 유지하는 것은
시퀀스의 이터레이터입니다. 때문에 for-루프 자체의 문제가 아니라 시퀀스의 이터레이터가 갖고 있는
문제입니다.</p>
</div>
</div>
</div>
<div class="section" id="the-try-statement">
<span id="finally"></span><span id="except"></span><span id="try"></span><h2>8.4. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 문<a class="headerlink" href="#the-try-statement" title="제목 주소">¶</a></h2>
<p id="index-10"><a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문은 문장 그룹에 대한 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 데 사용됩니다.</p>
<pre>
<strong id="grammar-token-try-stmt">try_stmt </strong> ::=  <a class="reference internal" href="#grammar-token-try1-stmt"><code class="xref docutils literal notranslate"><span class="pre">try1_stmt</span></code></a> | <a class="reference internal" href="#grammar-token-try2-stmt"><code class="xref docutils literal notranslate"><span class="pre">try2_stmt</span></code></a>
<strong id="grammar-token-try1-stmt">try1_stmt</strong> ::=  &quot;try&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
               (&quot;except&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>)+
               [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
               [&quot;finally&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
<strong id="grammar-token-try2-stmt">try2_stmt</strong> ::=  &quot;try&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
               &quot;finally&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
</pre>
<p><a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 절(들)은 하나나 그 이상의 예외 처리기를 지정합니다. <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 절에서 예외가 발생하지 않으면 아무런 예외 처리기도 실행되지 않습니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 스위트에서 예외가 발생할 때, 예외 처리기 검색이 시작됩니다. 이 검색은 그 예외에 매치되는 것을 발견할 때까지 except 절을 차례대로 들여다봅니다. 표현식이 없는 except 절이 있다면 가장 마지막에 와야 합니다; 모든 예외와 매치됩니다. 표현식이 있는 except 절의 경우, 표현식의 값을 구하고, 결과 객체가 예외와 &quot;호환&quot; 되면 그 절이 예외에 매치됩니다. 객체는 예외 객체의 클래스나 베이스 클래스일 때, 또는 예외와 호환되는 항목을 포함한 튜플일 때 예외와 호환됩니다.</p>
<p>except 절 중 어느 것도 예외와 매치되지 않으면, 예외 처리기 검색은 둘러싼 코드와 호출 스택에서 계속됩니다. <a class="footnote-reference" href="#id4" id="id1">[1]</a></p>
<p>만약 except 절의 헤더에 있는 표현식의 값을 구할 때 예외가 발생하면, 원래의 처리기 검색은 취소되고 둘러싼 코드와 호출 스택에서 새 예외에 대해 검사가 시작됩니다 (<a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문 전체가 예외를 일으킨 것으로 취급됩니다).</p>
<p id="index-11">매치되는 except 절이 발견되면, 예외는 그 except 절에 있는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 키워드 (가 있다면) 뒤에 지정된 타깃에 대입되고, except 절의 스위트가 실행됩니다. 모든 except 절은 실행 가능한 블록을 가져야 합니다. 블록의 끝에 도달하면, try 문 전체의 뒤에서 일반적인 실행이 계속됩니다. (이것은 같은 예외에 대해 두 개의 중첩된 처리기가 있고, 예외가 안쪽 처리기의 try 절에서 발생했다면, 바깥 처리기는 예외를 처리하지 않게 된다는 뜻이 됩니다.)</p>
<p>예외가 <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">target</span></code> 을 사용해서 대입될 때, except 절 끝에서 삭제됩니다. 이것은 마치</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">except</span> <span class="n">E</span> <span class="k">as</span> <span class="n">N</span><span class="p">:</span>
    <span class="n">foo</span>
</pre></div>
</div>
<p>가 이렇게 변환되는 것과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">except</span> <span class="n">E</span> <span class="k">as</span> <span class="n">N</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">foo</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">N</span>
</pre></div>
</div>
<p>이것은 except 절 후에 참조하려면 예외를 다른 이름에 대입해야 한다는 뜻입니다. 예외를 제거하는 이유는, 그것에 첨부된 트레이스백으로 인해, 스택 프레임과 참조 순환을 형성해서 다음 가비지 수거가 일어나기 전까지 그 프레임의 모든 지역 변수들을 잡아두기 때문입니다.</p>
<p id="index-12">except 절의 스위트가 실행되기 전에, 예외의 상세 내용이 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 모듈에 저장되는데, <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 를 통해 액세스할 수 있습니다. <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 는 예외 클래스, 예외 인스턴스, 예외가 프로그램의 어디에서 발생했는지를 알려주는 트레이스백 객체 (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 를 보세요) 로 이루어진 3-튜플을 돌려줍니다. <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 값들은 예외를 처리한 함수로부터 복귀할 때 이전 값으로 복구됩니다.</p>
<p id="index-13">생략 가능한 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절은 제어 흐름이 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 스위트를 빠져나가고, 예외가 발생하지 않았고, <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 또는 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문이 실행되지 않으면 실행됩니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절에서 발생하는 예외는 앞에 나오는 <a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 절에서 처리되지 않습니다.</p>
<p id="index-14"><a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 가 있으면, '정리(cleanup)' 처리기를 지정합니다. <a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 와 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 절을 포함해서, 먼저 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 절이 실행됩니다. 이 절들의 어디에서건 예외가 일어나면, 예외는 임시 저장됩니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절이 실행됩니다. 만약 저장된 예외가 있으면, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절의 끝에서 다시 발생시킨다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절이 다른 예외를 일으키면, 저장된 예외는 새 예외의 컨텍스트(context) 로 설정됩니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절이 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 이나 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문을 실행하면, 저장된 예외는 버립니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">42</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절에서 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 이나 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 가
실행되면 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문은 어떤 예외도 확산시키지 않습니다. 예외가 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>
스위트에서 발생하건, <a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 절의 표현식의 값을 구할 때 발생하건 마찬가지입니다.</p>
</div>
<p><a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 실행하는 동안 예외 정보는 프로그램에 제공되지 않습니다.</p>
<p id="index-15"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 문의 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 스위트에서 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문이 실행될 때, <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절도 '나가는 길에' 실행됩니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절에서는 <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문을 사용할 수 없습니다. (그 이유는 현재 구현에 있는 문제 때문입니다 --- 이 제약은 미래에 제거될 수 있습니다).</p>
<p>함수의 반환 값은 마지막에 실행된 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문으로 결정됩니다. <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 항상 실행되기 때문에, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절에서 실행되는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 문이 항상 마지막에 실행되는 것이 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">&#39;try&#39;</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">&#39;finally&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">&#39;finally&#39;</span>
</pre></div>
</div>
<p>예외에 관한 추가의 정보는 <a class="reference internal" href="executionmodel.html#exceptions"><span class="std std-ref">예외</span></a> 섹션에서 찾을 수 있고, 예외를 일으키기 위해 <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 문을 사용하는 것에 관한 정보는 <a class="reference internal" href="simple_stmts.html#raise"><span class="std std-ref">raise 문</span></a> 섹션에서 찾을 수 있습니다.</p>
</div>
<div class="section" id="the-with-statement">
<span id="as"></span><span id="with"></span><h2>8.5. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문<a class="headerlink" href="#the-with-statement" title="제목 주소">¶</a></h2>
<p id="index-16"><a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 블록의 실행을 컨텍스트 관리자 (<a class="reference internal" href="datamodel.html#context-managers"><span class="std std-ref">with 문 컨텍스트 관리자</span></a> 섹션을 보세요) 가 정의한 메서드들로 감싸는 데 사용됩니다. 이것은 흔한 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>...<a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 사용 패턴을 편리하게 재사용할 수 있도록 캡슐화할 수 있도록 합니다.</p>
<pre>
<strong id="grammar-token-with-stmt">with_stmt</strong> ::=  &quot;with&quot; <a class="reference internal" href="#grammar-token-with-item"><code class="xref docutils literal notranslate"><span class="pre">with_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-with-item"><code class="xref docutils literal notranslate"><span class="pre">with_item</span></code></a>)* &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
<strong id="grammar-token-with-item">with_item</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;as&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>]
</pre>
<p>하나의 &quot;item&quot; 을 사용하는 <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문의 실행은 다음과 같이 진행됩니다:</p>
<ol class="arabic">
<li><p class="first">컨텍스트 관리자를 얻기 위해 컨텍스트 표현식 (<a class="reference internal" href="#grammar-token-with-item"><code class="xref std std-token docutils literal notranslate"><span class="pre">with_item</span></code></a> 에 주어진 expression) 의 값을 구합니다.</p>
</li>
<li><p class="first">나중에 사용하기 위해 컨텍스트 관리자의 <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 가 로드됩니다.</p>
</li>
<li><p class="first">컨텍스트 관리자의 <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드를 호출합니다.</p>
</li>
<li><p class="first"><a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 타깃이 포함되었으면, 그것에 <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 의 반환 값을 대입합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드가 에러 없이 돌아왔을 때, <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 가 항상 호출됨을 보장합니다. 그래서, 타깃에 대입하는 동안 에러가 발생하면, 스위트 안에서 에러가 발생한 것과 같이 취급됩니다. 아래의 6단계를 보세요.</p>
</div>
</li>
<li><p class="first">스위트가 실행됩니다.</p>
</li>
<li><p class="first">컨텍스트 관리자의 <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드를 호출합니다. 예외가 스위트를 종료되도록 만들었다면, 그것의 형, 값, 트레이스백이 <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 의 인자로 전달됩니다. 그렇지 않으면 세 개의 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 인자로 공급됩니다.</p>
<p>스위트가 예외 때문에 종료되었고, <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드의 반환 값이 거짓이면, 그 예외를 다시 일으킨다. 반환 값이 참이면, 예외를 억누르고, <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문 뒤에 오는 문장으로 실행을 계속합니다.</p>
<p>스위트가 예외 이외의 이유로 종료되면, <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 의 반환 값은 무시되고, 해당 종료의 종류에 맞는 위치에서 실행을 계속합니다.</p>
</li>
</ol>
<p>하나 보다 많은 항목을 주면, 컨텍스트 관리자는 <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문이 중첩된 것처럼 진행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
    <span class="n">suite</span>
</pre></div>
</div>
<p>는 다음과 동등합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">B</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">suite</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>다중 컨텍스트 표현식의 지원</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; 문</dt>
<dd>파이썬 <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문의 규격, 배경, 예.</dd>
</dl>
</div>
</div>
<div class="section" id="function-definitions">
<span id="def"></span><span id="function"></span><span id="index-18"></span><h2>8.6. 함수 정의<a class="headerlink" href="#function-definitions" title="제목 주소">¶</a></h2>
<p id="index-19">함수 정의는 사용자 정의 함수 객체 (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 섹션을 보세요) 를 정의합니다:</p>
<pre>
<strong id="grammar-token-funcdef">funcdef                </strong> ::=  [<a class="reference internal" href="#grammar-token-decorators"><code class="xref docutils literal notranslate"><span class="pre">decorators</span></code></a>] &quot;def&quot; <a class="reference internal" href="#grammar-token-funcname"><code class="xref docutils literal notranslate"><span class="pre">funcname</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-parameter-list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;)&quot;
                             [&quot;-&gt;&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
<strong id="grammar-token-decorators">decorators             </strong> ::=  <a class="reference internal" href="#grammar-token-decorator"><code class="xref docutils literal notranslate"><span class="pre">decorator</span></code></a>+
<strong id="grammar-token-decorator">decorator              </strong> ::=  &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-dotted-name"><code class="xref docutils literal notranslate"><span class="pre">dotted_name</span></code></a> [&quot;(&quot; [<a class="reference internal" href="expressions.html#grammar-token-argument-list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;]] &quot;)&quot;] NEWLINE
<strong id="grammar-token-dotted-name">dotted_name            </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
<strong id="grammar-token-parameter-list">parameter_list         </strong> ::=  <a class="reference internal" href="#grammar-token-defparameter"><code class="xref docutils literal notranslate"><span class="pre">defparameter</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-defparameter"><code class="xref docutils literal notranslate"><span class="pre">defparameter</span></code></a>)* [&quot;,&quot; [<a class="reference internal" href="#grammar-token-parameter-list-starargs"><code class="xref docutils literal notranslate"><span class="pre">parameter_list_starargs</span></code></a>]]
                             | <a class="reference internal" href="#grammar-token-parameter-list-starargs"><code class="xref docutils literal notranslate"><span class="pre">parameter_list_starargs</span></code></a>
<strong id="grammar-token-parameter-list-starargs">parameter_list_starargs</strong> ::=  &quot;*&quot; [<a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a>] (&quot;,&quot; <a class="reference internal" href="#grammar-token-defparameter"><code class="xref docutils literal notranslate"><span class="pre">defparameter</span></code></a>)* [&quot;,&quot; [&quot;**&quot; <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> [&quot;,&quot;]]]
                             | &quot;**&quot; <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> [&quot;,&quot;]
<strong id="grammar-token-parameter">parameter              </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-defparameter">defparameter           </strong> ::=  <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> [&quot;=&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-funcname">funcname               </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>함수 정의는 실행할 수 있는 문장입니다. 실행하면 현재 지역 이름 공간의 함수 이름을 함수 객체 (함수의 실행 가능한 코드를 둘러싼 래퍼(wrapper)). 이 함수 객체는 현재의 이름 공간에 대한 참조를 포함하는데, 함수가 호출될 때 전역 이름 공간으로 사용됩니다.</p>
<p>함수 정의는 함수의 바디를 실행하지 않습니다. 함수가 호출될 때 실행됩니다. <a class="footnote-reference" href="#id5" id="id2">[2]</a></p>
<p id="index-20">함수 정의는 하나나 그 이상의 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a> 표현식으로 감싸질 수 있습니다. 데코레이터 표현식은 함수가 정의될 때, 함수 정의를 포함하는 스코프에서 값을 구합니다. 그 결과는 콜러블이어야 하는데, 함수 객체만을 인자로 사용해서 호출됩니다. 반환 값이 함수 객체 대신 함수의 이름에 연결됩니다. 여러 개의 데코레이터는 중첩되는 방식으로 적용됩니다. 예를 들어, 다음과 같은 코드</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="nd">@f2</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span> <span class="k">pass</span>
</pre></div>
</div>
<p>는 대략 다음과 동등합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">():</span> <span class="k">pass</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)(</span><span class="n">f2</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
</pre></div>
</div>
<p>원래의 함수가 임시로 이름 <code class="docutils literal notranslate"><span class="pre">func</span></code> 에 연결되지 않는다는 점만 다릅니다.</p>
<p id="index-21">하나나 그 이상의 <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">매개변수</span></a> 들이 <em>parameter</em> <code class="docutils literal notranslate"><span class="pre">=</span></code> <em>expression</em> 형태를 가질 때, 함수가 &quot;기본 매개변수 값&quot;을 갖는다고 말합니다. 기본값이 있는 매개변수의 경우, 호출할 때 대응하는 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">인자</span></a> 를 생략할 수 있고, 그럴 때 매개변수의 기본값이 적용됩니다. 만약 매개변수가 기본값을 가지면, &quot;<code class="docutils literal notranslate"><span class="pre">*</span></code>&quot; 까지 그 뒤를 따르는 모든 매개변수도 기본값을 가져야 합니다 --- 이것은 문법 규칙에서 표현되지 않는 문법적 제약입니다.</p>
<p><strong>함수 정의가 실행될 때, 기본 매개변수 값은 왼쪽에서 오른쪽으로 값이 구해집니다.</strong> 이것은 표현식이 함수가 정의될 때 한 번 값이 구해지고, 호출마다 같은 &quot;미리 계산된&quot; 값이 사용된다는 것을 뜻합니다. 이것을 이해하는 것은 특히 기본값이 리스트나 딕셔너리와 같은 가변 객체일 때 중요합니다: 만약 함수가 그 객체를 수정하면 (가령, 리스트에 항목을 추가합니다), 그 결과 기본값이 수정됩니다. 이것은 일반적으로 의도하고 있는 것이 아니다. 이 문제를 회피하는 방법은 기본값으로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 사용하고, 함수 바디에서 명시적으로 검사하는 것입니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">whats_on_the_telly</span><span class="p">(</span><span class="n">penguin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">penguin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">penguin</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">penguin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;property of the zoo&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">penguin</span>
</pre></div>
</div>
<p id="index-22">함수 호출의 의미는 섹션 <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 에서 더 자세히 설명됩니다. 함수 호출은 항상 매개변수 목록에서 언급하는 모든 매개변수에 값을 대입하는데, 위치 인자들에서 올 수도, 키워드 인자들에서 올 수도, 기본값에서 올 수도 있습니다. &quot;<code class="docutils literal notranslate"><span class="pre">*identifier</span></code>&quot; 형태가 존재하면, 남는 위치 매개변수들을 받는 튜플로 초기화됩니다. 기본값은 빈 튜플입니다. &quot;<code class="docutils literal notranslate"><span class="pre">**identifier</span></code>&quot; 형태가 존재하면, 남는 키워드 인자들을 받는 순서 있는 매핑으로 초기화됩니다. 기본값은 빈 매핑입니다. &quot;<code class="docutils literal notranslate"><span class="pre">*</span></code>&quot; 나 &quot;<code class="docutils literal notranslate"><span class="pre">*identifier</span></code>&quot; 뒤에 오는 매개변수들은 키워드 전용 매개변수들이고, 키워드 인자로만 전달될 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">&quot;<code class="docutils literal notranslate"><span class="pre">**identifier</span></code>&quot; 형태는 순서있는 매핑입니다. 즉 키워드 인자들이 주어진 순서가 보존됩니다.
현재 구현에서는 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 가 넘어오는데, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 는 순서있는 매핑입니다.</p>
</div>
<p id="index-23">매개변수들은 매개변수 이름 뒤에 오는 &quot;<code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">expression</span></code>&quot; 형태의 <a class="reference internal" href="../glossary.html#term-function-annotation"><span class="xref std std-term">어노테이션</span></a>을 가질 수 있습니다. 모든 매개변수는 어노테이션을 가질 수 있는데, <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> 나 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 형태조차 그렇습니다. 함수는 매개변수 목록 뒤에 오는 &quot;<code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">expression</span></code>&quot; 형태의 반환(&quot;return&quot;) 어노테이션을 가질 수 있습니다. 이 어노테이션들은 올바른 파이썬 표현식이면 어떤 것이건 될 수 있습니다. 어노테이션의 존재는 함수의 의미를 바꾸지 않습니다. 어노테이션 값들은 함수 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트에서 매개변수의 이름을 키로 하는 딕셔너리의 값으로 제공됩니다. <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 에서 <code class="docutils literal notranslate"><span class="pre">annotations</span></code> 을 임포트하면, 지연된 평가가 활성화되어 어노테이션은 실행시간에 문자열로 보존됩니다. 그렇지 않으면 함수 정의가 실행될 때 평가됩니다. 이 경우 어노테이션은 소스 코드에 나오는 순서와 다른 순서로 평가될 수 있습니다.</p>
<p id="index-24">표현식에서 즉시 사용하기 위해, 이름 없는 함수(이름에 연결되지 않은 함수)를 만드는 것도 가능합니다. 이것은 람다 표현식을 사용하는데, <a class="reference internal" href="expressions.html#lambda"><span class="std std-ref">람다(Lambdas)</span></a> 섹션에서 설명합니다. 람다 표현식은 단순화된 함수 정의를 위한 줄임 표현에 지나지 않는다는 것에 주의하세요; &quot;<a class="reference internal" href="#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>&quot; 문장에서 정의된 함수는 람다 표현식으로 정의된 함수처럼 전달되거나 다른 이름에 대입될 수 있습니다. 여러 개의 문장을 실행하는 것과 어노테이션을 허락하기 때문에, &quot;<code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code>&quot; 형태가 사실 더 강력합니다.</p>
<p><strong>프로그래머 유의 사항:</strong> 함수는 퍼스트 클래스(first-class) 객체다. 함수 정의 안에서 실행되는 &quot;<code class="docutils literal notranslate"><span class="pre">def</span></code>&quot; 문은 돌려주거나 전달할 수 있는 지역 함수를 정의합니다. 중첩된 함수에서 사용되는 자유 변수들은 그 def 를 포함하는 함수의 지역 변수들을 액세스할 수 있습니다. 더 자세한 내용은 <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">이름과 연결(binding)</span></a> 섹션을 보세요.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3107"><strong>PEP 3107</strong></a> - 함수 어노테이션</dt>
<dd>함수 어노테이션의 최초 규격.</dd>
<dt><span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - 형 힌트</dt>
<dd>어노테이션에 대한 표준 의미 정의: 형 힌트.</dd>
<dt><span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> - 변수 어노테이션 문법</dt>
<dd>클래스 변수 및 인스턴스 변수를 포함하는 변수 선언에 형 힌트를 줄 수 있는 기능</dd>
<dt><span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0563"><strong>PEP 563</strong></a> - 어노테이션의 지연된 평가</dt>
<dd>즉시 평가하는 대신 실행시간에 어노테이션을 문자열 형식으로 보존하여 어노테이션 내에서의 전방 참조를 지원합니다.</dd>
</dl>
</div>
</div>
<div class="section" id="class-definitions">
<span id="class"></span><h2>8.7. 클래스 정의<a class="headerlink" href="#class-definitions" title="제목 주소">¶</a></h2>
<p id="index-29">클래스 정의는 클래스 객체(<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 섹션을 보세요)를 정의합니다:</p>
<pre>
<strong id="grammar-token-classdef">classdef   </strong> ::=  [<a class="reference internal" href="#grammar-token-decorators"><code class="xref docutils literal notranslate"><span class="pre">decorators</span></code></a>] &quot;class&quot; <a class="reference internal" href="#grammar-token-classname"><code class="xref docutils literal notranslate"><span class="pre">classname</span></code></a> [<a class="reference internal" href="#grammar-token-inheritance"><code class="xref docutils literal notranslate"><span class="pre">inheritance</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
<strong id="grammar-token-inheritance">inheritance</strong> ::=  &quot;(&quot; [<a class="reference internal" href="expressions.html#grammar-token-argument-list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a>] &quot;)&quot;
<strong id="grammar-token-classname">classname  </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>클래스 정의는 실행 가능한 문장입니다. 계승(inheritance) 목록은 보통 베이스 클래스들의 목록을 제공하는데 (더 고급 사용에 대해서는 <a class="reference internal" href="datamodel.html#metaclasses"><span class="std std-ref">메타 클래스</span></a> 를 보세요), 목록의 각 항목은 값을 구할 때 서브클래싱을 허락하는 클래스 객체가 되어야 합니다. 계승 목록이 없는 클래스는, 기본적으로, 베이스 클래스 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 를 계승합니다; 그래서</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>는 다음과 동등합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>클래스의 스위트는 새로 만들어진 지역 이름 공간과 원래의 전역 이름 공간을 사용하는 새 실행 프레임 (<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">이름과 연결(binding)</span></a> 을 보세요)에서 실행됩니다. (보통, 스위트는 대부분 함수 정의들을 포함합니다.) 클래스의 스위트가 실행을 마치면, 실행 프레임은 파기하지만, 그것의 지역 이름 공간은 보존합니다. <a class="footnote-reference" href="#id6" id="id3">[3]</a> 그런 다음, 계승 목록을 베이스 클래스들로, 보존된 지역 이름 공간을 어트리뷰트 딕셔너리로 사용해서 새 클래스 객체를 만듭니다. 클래스의 이름은 원래의 지역 이름 공간에서 이 클래스 객체와 연결됩니다.</p>
<p>클래스 바디에서 어트리뷰트가 정의되는 순서는, 새 클래스의 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 에 보존됩니다. 이것은 클래스가 만들어진 직후에, 정의 문법을 사용해서 정의되는 클래스들에서만 신뢰할 수 있다는 것에 주의해야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">클래스 어트리뷰트의 순서가 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 에 보존되는 것 역시, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 가 삽입순서를
보존한다는 것에 의존합니다. 하지만 이 보존 상태는 클래스가 만들어지는 직후에만 보장될 뿐, 그 이후의
어느 시점엔가 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 가 애초의 순서를 보존하지 않는 상태로 바뀔 수도 있음을 시사하고 있습니다.
이 직후라는 것은 보통 <a class="reference internal" href="datamodel.html#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__init_subclass__()</span></code></a> 가 호출되는 시점이나, 그 근처를
뜻합니다. 또한 클래스 정의 문법을 사용하지 않는 경우에는 이 순서의 보존이 보장되지 않는다고 말하고 있는데,
클래스 정의 문법을 사용하지 않는다는 것은 메타클래스를 사용해서 동적으로 클래스를 만드는 경우입니다.</p>
</div>
<p>클래스 생성은 <a class="reference internal" href="datamodel.html#metaclasses"><span class="std std-ref">메타 클래스</span></a> 를 사용해서 심하게 커스터마이즈할 수 있습니다.</p>
<p id="index-30">클래스 역시 함수를 데코레이팅할 때처럼 테코레이트할 수 있습니다,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="nd">@f2</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
<p>는 대략 다음과 동등합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">Foo</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)(</span><span class="n">f2</span><span class="p">(</span><span class="n">Foo</span><span class="p">))</span>
</pre></div>
</div>
<p>데코레이터 표현식의 값을 구하는 규칙은 함수 데코레이터와 같습니다. 그런 다음 그 결과가 클래스 이름에 연결됩니다.</p>
<p><strong>프로그래머 유의 사항:</strong> 클래스 정의에서 정의되는 변수들은 클래스 어트리뷰트입니다; 이것들은 인스턴스 간에 공유됩니다. 인스턴스 어트리뷰트는 메서드에서 <code class="docutils literal notranslate"><span class="pre">self.name</span> <span class="pre">=</span> <span class="pre">value</span></code> 로 설정될 수 있습니다. 클래스와 인스턴스 어트리뷰트 모두 &quot;<code class="docutils literal notranslate"><span class="pre">self.name</span></code>&quot; 표기법으로 액세스할 수 있고, 이런 식으로 액세스할 때 인스턴스 어트리뷰트는 같은 이름의 클래스 어트리뷰트를 가립니다. 클래스 어트리뷰트는 인스턴스 어트리뷰트의 기본값으로 사용될 수 있지만, 가변 값을 사용하는 것은 예상하지 않은 결과를 줄 수 있습니다. <a class="reference internal" href="datamodel.html#descriptors"><span class="std std-ref">디스크립터</span></a> 를 다른 구현 상세를 갖는 인스턴스 변수를 만드는데 사용할 수 있습니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - 파이썬 3000의 메타 클래스</dt>
<dd>메타 클래스 선언을 현재 문법으로 변경하고, 메타 클래스가 있는 클래스를 구성하는 방법의 의미를 변경하는 제안.</dd>
<dt><span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3129"><strong>PEP 3129</strong></a> - 클래스 데코레이터</dt>
<dd>클래스 데코레이터를 추가하는 제안. 함수와 메서드 데코레이터는 <span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0318"><strong>PEP 318</strong></a>에서 도입되었습니다.</dd>
</dl>
</div>
</div>
<div class="section" id="coroutines">
<span id="async"></span><h2>8.8. 코루틴<a class="headerlink" href="#coroutines" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
<div class="section" id="coroutine-function-definition">
<span id="async-def"></span><span id="index-34"></span><h3>8.8.1. 코루틴 함수 정의<a class="headerlink" href="#coroutine-function-definition" title="제목 주소">¶</a></h3>
<pre>
<strong id="grammar-token-async-funcdef">async_funcdef</strong> ::=  [<a class="reference internal" href="#grammar-token-decorators"><code class="xref docutils literal notranslate"><span class="pre">decorators</span></code></a>] &quot;async&quot; &quot;def&quot; <a class="reference internal" href="#grammar-token-funcname"><code class="xref docutils literal notranslate"><span class="pre">funcname</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-parameter-list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;)&quot;
                   [&quot;-&gt;&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
</pre>
<p id="index-35">파이썬 코루틴의 실행은 여러 지점에서 일시 중지되거나 재개될 수 있습니다 (<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 을 보세요.). 코루틴의 바디 안에서, <code class="docutils literal notranslate"><span class="pre">await</span></code> 와 <code class="docutils literal notranslate"><span class="pre">async</span></code> 식별자는 예약 키워드가 됩니다; 어웨이트(<a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>) 표현식, <a class="reference internal" href="#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, <a class="reference internal" href="#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 는 코루틴 바디에서만 사용할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">“코루틴의 바디에서, <code class="docutils literal notranslate"><span class="pre">await</span></code> 와 <code class="docutils literal notranslate"><span class="pre">async</span></code> 식별자는 예약 키워드가 된다” 는 뜻은, <code class="docutils literal notranslate"><span class="pre">await</span></code>
와 <code class="docutils literal notranslate"><span class="pre">async</span></code> 를 그 밖의 다른 곳에서는 키워드가 아닌 일반 식별자로 쓸 수 있다는 뜻인데,
이는 파이썬 3.6 까지만 그렇고, 3.7 부터는 카워드로 변경되었습니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">“코루틴의 바디에서, <code class="docutils literal notranslate"><span class="pre">await</span></code> 와 <code class="docutils literal notranslate"><span class="pre">async</span></code> 식별자는 예약 키워드가 된다” 는 뜻은, <code class="docutils literal notranslate"><span class="pre">await</span></code>
와 <code class="docutils literal notranslate"><span class="pre">async</span></code> 를 그 밖의 다른 곳에서는 키워드가 아닌 일반 식별자로 쓸 수 있다는 뜻인데,
이는 파이썬 3.6 까지만 그렇고, 3.7 부터는 카워드로 변경되었습니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 문법으로 정의된 함수는 항상 코루틴 함수인데, <code class="docutils literal notranslate"><span class="pre">await</span></code> 나 <code class="docutils literal notranslate"><span class="pre">async</span></code> 키워드를 포함하지 않는 경우도 그렇습니다.</p>
<p>코루틴 함수의 바디 안에서 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 표현식을 사용하는 것은 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 입니다.</p>
<p>코루틴 함수의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">):</span>
    <span class="n">do_stuff</span><span class="p">()</span>
    <span class="k">await</span> <span class="n">some_coroutine</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="the-async-for-statement">
<span id="async-for"></span><span id="index-36"></span><h3>8.8.2. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문<a class="headerlink" href="#the-async-for-statement" title="제목 주소">¶</a></h3>
<pre>
<strong id="grammar-token-async-for-stmt">async_for_stmt</strong> ::=  &quot;async&quot; <a class="reference internal" href="#grammar-token-for-stmt"><code class="xref docutils literal notranslate"><span class="pre">for_stmt</span></code></a>
</pre>
<p><a class="reference internal" href="../glossary.html#term-asynchronous-iterable"><span class="xref std std-term">비동기 이터러블</span></a> 은 <em>iter</em> 구현에서 비동기 코드를 호출할 수 있고, <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 는 <em>next</em> 메서드에서 비동기 코드를 호출할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문은 비동기 이터레이터에 대한 편리한 이터레이션을 허락합니다.</p>
<p>다음과 같은 코드는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">TARGET</span> <span class="ow">in</span> <span class="n">ITER</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</pre></div>
</div>
<p>의미상으로 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">ITER</span><span class="p">)</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span><span class="o">.</span><span class="fm">__aiter__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
<span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">TARGET</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span><span class="o">.</span><span class="fm">__anext__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">StopAsyncIteration</span><span class="p">:</span>
        <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> 를 <a class="reference internal" href="datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 보면 됩니다.</p>
<p>코루틴 함수의 바디 밖에서 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문을 사용하는 것은 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 입니다.</p>
</div>
<div class="section" id="the-async-with-statement">
<span id="async-with"></span><span id="index-37"></span><h3>8.8.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문<a class="headerlink" href="#the-async-with-statement" title="제목 주소">¶</a></h3>
<pre>
<strong id="grammar-token-async-with-stmt">async_with_stmt</strong> ::=  &quot;async&quot; <a class="reference internal" href="#grammar-token-with-stmt"><code class="xref docutils literal notranslate"><span class="pre">with_stmt</span></code></a>
</pre>
<p><a class="reference internal" href="../glossary.html#term-asynchronous-context-manager"><span class="xref std std-term">비동기 컨텍스트 관리자</span></a> 는 <em>enter</em> 와 <em>exit</em> 메서드에서 실행을 일시 중지할 수 있는 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 입니다.</p>
<p>다음과 같은 코드는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">EXPR</span> <span class="k">as</span> <span class="n">VAR</span><span class="p">:</span>
    <span class="n">BLOCK</span>
</pre></div>
</div>
<p>의미상으로 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mgr</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXPR</span><span class="p">)</span>
<span class="n">aexit</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span><span class="fm">__aexit__</span>
<span class="n">aenter</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span><span class="fm">__aenter__</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

<span class="n">VAR</span> <span class="o">=</span> <span class="k">await</span> <span class="n">aenter</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="n">aexit</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()):</span>
        <span class="k">raise</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">aexit</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> 와 <a class="reference internal" href="datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> 를 보면 됩니다.</p>
<p>코루틴 함수의 바디 밖에서 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문을 사용하는 것은 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 입니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> - async 와 await 문법을 사용하는 코루틴</dt>
<dd>코루틴을 파이썬에서 적절한 독립적인 개념으로 만들고, 문법 지원을 추가한 제안.</dd>
</dl>
</div>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>다른 예외를 일으키는 <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 있지 않은 한 예외는 호출 스택으로 퍼집니다. 그 새 예외는 예전의 것을 잃어버리게 만듭니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>함수 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 함수의 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 어트리뷰트로 변환되어 함수의 <a class="reference internal" href="../glossary.html#term-docstring"><span class="xref std std-term">독스트링</span></a> 이 됩니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>클래스 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 그 이름 공간의 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 항목으로 변환되어 클래스의 <a class="reference internal" href="../glossary.html#term-docstring"><span class="xref std std-term">독스트링</span></a> 이 됩니다.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. 복합문(Compound statements)</a><ul>
<li><a class="reference internal" href="#the-if-statement">8.1. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 문</a></li>
<li><a class="reference internal" href="#the-while-statement">8.2. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code> 문</a></li>
<li><a class="reference internal" href="#the-for-statement">8.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 문</a></li>
<li><a class="reference internal" href="#the-try-statement">8.4. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 문</a></li>
<li><a class="reference internal" href="#the-with-statement">8.5. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문</a></li>
<li><a class="reference internal" href="#function-definitions">8.6. 함수 정의</a></li>
<li><a class="reference internal" href="#class-definitions">8.7. 클래스 정의</a></li>
<li><a class="reference internal" href="#coroutines">8.8. 코루틴</a><ul>
<li><a class="reference internal" href="#coroutine-function-definition">8.8.1. 코루틴 함수 정의</a></li>
<li><a class="reference internal" href="#the-async-for-statement">8.8.2. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문</a></li>
<li><a class="reference internal" href="#the-async-with-statement">8.8.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="이전 장">7. 단순문(Simple statements)</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="toplevel_components.html"
                        title="다음 장">9. 최상위 요소들</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="toplevel_components.html" title="9. 최상위 요소들"
             >다음</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>