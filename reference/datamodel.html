
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>3. 데이터 모델 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="4. 실행 모델" href="executionmodel.html" />
    <link rel="prev" title="2. 어휘 분석" href="lexical_analysis.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/reference/datamodel.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 어휘 분석"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="data-model">
<span id="datamodel"></span><h1><span class="section-number">3. </span>데이터 모델<a class="headerlink" href="#data-model" title="제목 주소">¶</a></h1>
<div class="section" id="objects-values-and-types">
<span id="objects"></span><h2><span class="section-number">3.1. </span>객체, 값, 형<a class="headerlink" href="#objects-values-and-types" title="제목 주소">¶</a></h2>
<p id="index-0"><em class="dfn">객체 (Objects)</em>는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 &quot;프로그램 내장식 컴퓨터(stored program computer)&quot; 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니다.)</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>폰 노이만 구조 이후의 하버드 구조와 대비시켜 볼 수도 있겠습니다.
폰 노이만 구조가 데이터와 코드를 같은 공간에 내장하는 반면, 하버드 구조에서는 데이터와 코드를 별도의
공간에 내장합니다. 이 것이 오히려 현대의 컴퓨터에 더 가깝다고 볼 수 있습니다. 파이썬은 코드 조차도 그
형태가 분명한 객체로 다루기 때문에, 노이만 구조에 가까운 가상 머신을 제공한다고 본다는 뜻으로 해석할 수 있습니다.</p>
</div>
<span class="target" id="index-1"></span><p>모든 객체는 아이덴티티(identity), 형(type), 값(value)을 갖습니다. 객체의 <em>아이덴티티</em> 는 한 번 만들어진 후에는 변경되지 않습니다. 메모리상에서의 객체의 주소로 생각해도 좋습니다. '<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>' 연산자는 두 객체의 아이덴티티를 비교합니다; <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 함수는 아이덴티티를 정수로 표현한 값을 돌려줍니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 의 경우, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 저장된 메모리의 주소입니다.</p>
</div>
<p>객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, &quot;길이를 갖고 있나?&quot;) 그 형의 객체들이 가질 수 있는 가능한 값들을 정의합니다. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 함수는 객체의 형(이것 역시 객체다)을 돌려줍니다. 아이덴티티와 마찬가지로, 객체의 <em class="dfn">형 (type)</em> 역시 변경되지 않습니다. <a class="footnote-reference brackets" href="#id8" id="id1">1</a></p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>객체의 형 역시 객체라면, 그 객체의 형은 무엇인가? 이런 식으로 꼬리를 물고 올라갈 경우 &quot;스스로 존재하는 자&quot; 가
필요합니다. 즉 자신의 형이 자기 자신인 존재가 필요하다는 뜻입니다. 이 것이 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>객체의 형은 제한적이나마 변경될 수 있습니다. 예를 들어 인스턴스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code> 어트리뷰트는 인스턴스
객체의 형(이 경우는 클래스가 됩니다)을 가리키는데, 대입이 가능합니다. 아무 값이나 대입할 수는 없지만,
다른 클래스를 대입할 수 있습니다. 변경 이후에는 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 함수도 새 클래스를 돌려주고, 다른 부분에서도
새 클래스의 인스턴스 인 것처럼 동작합니다. 하지만 각주에서 권하는 것처럼 극히 예외적인 경우로 다뤄야할 것입니다.</p>
</div>
<p>어떤 객체들의 <em>값</em> 은 변경할 수 있습니다. 값을 변경할 수 있는 객체들을 <em>가변(mutable)</em> 이라고 합니다. 일단 만들어진 후에 값을 변경할 수 없는 객체들을 <em>불변(immutable)</em> 이라고 합니다. (가변 객체에 대한 참조를 저장하고 있는 불변 컨테이너의 값은 가변 객체의 값이 변할 때 변경된다고 볼 수도 있습니다; 하지만 저장하고 있는 객체들의 집합이 바뀔 수 없으므로 컨테이너는 여전히 불변이라고 여겨집니다. 따라서 불변성은 엄밀하게는 변경 불가능한 값을 갖는 것과는 다릅니다. 좀 더 미묘합니다.) 객체의 가변성(mutability)은 그것의 형에 의해 결정됩니다; 예를 들어 숫자, 문자열, 튜플(tuple)은 불변이지만, 딕셔너리(dictionary) 와 리스트(list)는 가변입니다.</p>
<p id="index-2">객체는 결코 명시적으로 파괴되지 않습니다; 더 참조되지 않을 때(unreachable) 가비지 수거(garbage collect)됩니다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락됩니다 --- 아직 참조되는 객체들을 수거하지 않는 이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 문제입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 키워드는 객체에 대한 참조를 지우는 것이지 객체를 명시적으로 파괴하는 것이 아닙니다.
CPython 의 경우 참조를 지운 결과 카운트가 0 으로 떨어지면 즉시 수거되겠지만, 다른 곳에서
참조가 되고 있는 경우 카운트가 0 으로 떨어지지 않기 때문에 수거되지 않습니다.
다른 참조들을 모두 제거하기 전에, 객체를 강제로 파괴할 수 있는 방법은 없습니다.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) 순환적으로 연결된 가비지의 지연된 감지가 추가됩니다. 이 방법으로 대부분 객체를 참조가 제거되자마자 수거할 수 있습니다. 하지만 순환 참조가 있는 가비지들을 수거한다는 보장은 없습니다. 순환적 가비지 수거의 제어에 관한 정보는 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈 문서를 참조하면 됩니다. 다른 구현들은 다른 식으로 동작하고, CPython 도 변경될 수 있습니다. 참조가 제거될 때 즉각적으로 파이널리제이션(finalization)되는 것에 의존하지 말아야 합니다 (그래서 항상 파일을 명시적으로 닫아주어야 합니다).</p>
<div class="admonition-flowdas compound-middle admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈은 순환적 가비지 수거에 관해서만 관여합니다. CPython 의 경우 참조 횟수 계산은
언제나 일어나는 것이고, 중지 시킬 방법 같은 것은 없습니다.</p>
</div>
<div class="admonition-flowdas compound-last admonition">
<p class="admonition-title">flowdas</p>
<p>순환적 가비지 수거는 성능에 영향을 줍니다. (사실 대부분의 언어에서 가비지 수거는 늘 문제가 되는
부분입니다.) 만약 가비지들 간의 순환 참조가 발생하지 않거나, 관리 가능한 수준으로 유지할 수
있다면 아예 순환적 가비지 수거를 꺼버리는 것이 성능을 개선하는 경우가 있습니다.
<a class="reference internal" href="../library/gc.html#gc.disable" title="gc.disable"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.disable()</span></code></a> 로 끌 수 있습니다.</p>
</div>
</div>
<p>구현이 제공하는 추적이나 디버깅 장치의 사용은 그렇지 않으면 수거될 수 있는 객체들을 살아있도록 만들 수 있음에 주의해야 합니다. 또한 '<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>' 문으로 예외를 잡는 것도 객체를 살아있게 만들 수 있습니다.</p>
<p>어떤 객체들은 열린 파일이나 창 같은 &quot;외부(external)&quot; 자원들에 대한 참조를 포함합니다. 이 자원들은 객체가 가비지 수거될 때 반납된다고 이해되지만, 가비지 수거는 보장되는 것이 아니므로, 그런 객체들은 외부자원을 반납하는 명시적인 방법 또한 제공합니다. 보통 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 메서드다. 프로그램을 작성할 때는 그러한 객체들을 항상 명시적으로 닫아야(close) 합니다. '<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>' 문과 '<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 문은 이렇게 하는 편리한 방법을 제공합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 메서드를 제공하는 대부분의 객체들은, 컨텍스트 관리자 프로토콜을 지원하기 때문에
'<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 문 만으로 쉽고 안전하게 관리할 수 있습니다.
하지만 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 메서드만 지원하고 컨텍스트 관리자 프로토콜을 지원하지 않는다면,
'<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>' 문 보다는
<a class="reference internal" href="../library/contextlib.html#contextlib.closing" title="contextlib.closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">contextlib.closing()</span></code></a> 과 '<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 문을 사용하는 것을 권합니다.</p>
</div>
<p id="index-3">어떤 객체들은 다른 객체에 대한 참조를 포함하고 있습니다. 이런 것들을 <em>컨테이너(container)</em> 라고 부릅니다. 튜플, 리스트, 딕셔너리등이 컨테이너의 예입니다. 이 참조들은 컨테이너의 값의 일부입니다. 대부분은, 우리가 컨테이너의 값을 논할 때는, 들어있는 객체들의 아이덴티티 보다는 값을 따집니다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 가진 객체들의 아이덴티티만을 따집니다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 하고 있다면, 그 가변 객체가 변경되면 컨테이너의 값도 변경됩니다.</p>
<p>형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 줍니다. 객체의 아이덴티디가 갖는 중요성조차도 어떤 면에서는 영향을 받습니다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 있습니다. 반면에 가변 객체에서는 이런 것이 허용되지 않습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">a</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b</span></code> 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있습니다. 하지만 <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장됩니다. (<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 는 객은 객체를 <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 에 대입합니다.)</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>CPython 의 경우, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">a</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b</span></code> 는 동일한 객체가 됩니다.
성능 개선을 위해 -5 에서 256 사이의 정수를 캐싱하기 때문입니다. 중요한 것은, 이런 세부 사항을
기억하는 것이 아니라, 이런 문제 때문에 불변형에 대해서 <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 연산자를 사용할 때
조심해야한다는 것입니다.</p>
</div>
</div>
<div class="section" id="the-standard-type-hierarchy">
<span id="types"></span><h2><span class="section-number">3.2. </span>표준형 계층<a class="headerlink" href="#the-standard-type-hierarchy" title="제목 주소">¶</a></h2>
<p id="index-4">아래에 파이썬에 내장된 형들의 목록이 있습니다. (구현에 따라 C 나 자바나 다른 언어로 작성된) 확장 모듈들은 추가의 형을 정의할 수 있습니다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 (예를 들어, 유리수, 효율적으로 저장된 정수 배열 등등), 표준 라이브러리를 통해 추가될 가능성이 더 크기는 합니다.</p>
<p id="index-5">아래에 나오는 몇몇 형에 대한 설명은 '특수 어트리뷰트(special attribute)' 를 나열하는 문단을 포함합니다. 이것들은 구현에 접근할 방법을 제공하는데, 일반적인 사용을 위한 것이 아닙니다. 정의는 앞으로 변경될 수 있습니다.</p>
<dl>
<dt>None</dt><dd><p id="index-6">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 통해 접근합니다. 여러 가지 상황에서 값의 부재를 알리는 데 사용됩니다. 예를 들어, 명시적으로 뭔가를 돌려주지 않는 함수의 반환 값입니다. 논리값은 거짓입니다.</p>
</dd>
<dt>NotImplemented</dt><dd><p id="index-7">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 을 통해 접근합니다. 숫자 메서드(numeric method)와 비교(rich comparison) 메서드는 제공된 피연산자에 대해 연산이 구현되지 않으면 이 값을 돌려줘야 합니다. (그러면 인터프리터는 연산자에 따라 뒤집힌 연산이나, 어떤 다른 대안을 시도합니다.) 논리값은 참입니다.</p>
<p>더 자세한 내용은 <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">산술 연산 구현</span></a> 을 참고하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>숫자 메서드란, 숫자 형 또는 숫자를 흉내내는 형에서 이항 산술 연산(binary arithmetic operation)
(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>,
<code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) 의 기능을 제공하는 역할을 하는 다음과 같은
메서드들을 뜻합니다.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__sub__" title="object.__sub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__matmul__" title="object.__matmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__matmul__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__lshift__" title="object.__lshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lshift__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__rshift__" title="object.__rshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rshift__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__and__" title="object.__and__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__xor__" title="object.__xor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__xor__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__or__" title="object.__or__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code></a></p></li>
</ul>
<p>이 메서드들이 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려주면 해당 구현이 존재하지 않는 것으로 보고 뒤집힌 연산을
시도합니다. 뒤집힌 연산은 위에 나열한 메서드들의 이름에 <code class="docutils literal notranslate"><span class="pre">r</span></code> 접두어를 붙인 것들입니다.</p>
<p>예를들어 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 라는 표현식이 있을 때, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 를 정의하고 있다면 먼저
<code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 를 시도합니다. 정의 되어 있지 않거나 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려주면,
<code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> 를 시도합니다. 이렇게 하는 이유는 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span></code> 의 형이 다를 수 있기
때문입니다.(실제로 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span></code> 의 형이 같으면 <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a> 는 사용되지 않습니다.)</p>
<p>가령 분수를 표현하는 형을 하나 추가했고, 객체 <code class="docutils literal notranslate"><span class="pre">y</span></code> 를 만들었다고 합시다. 당연히 분수는 정수와 더할 수
있을 것이기 때문에, <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span></code> 라는 표현이 정수가 더해진 새 분수를 돌려주도록 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 를
정의해줄 수 있습니다. 그런데 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 라는 표현도 같은 결과를 돌려주어야 하지만, 내장된 정수형이 새로
만든 분수형 <code class="docutils literal notranslate"><span class="pre">y</span></code> 와 더하는 방법을 알리가 없습니다. 이 때 정수형은 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줍니다.
분수형에 <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a> 를 정의해 두었다면, 이 표현도 같은 결과를 줄 수 있습니다.</p>
<p><strong>숫자 메서드를 구현할 때는, 앞으로 추가될 형들과의 호환을 위해, 형 검사를 수행하고 모르는 형이 올 경우
NotImplemeted 를 돌려주도록 코딩하는 것이 좋습니다.</strong></p>
<p>뒤집힌 연산에서도 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줄 수 있는데, 이 경우는 더이상 대안을 찾지 않고 최종적인
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>숫자 메서드에는, 앞의 두 유형 외에 증분 대입 연산자를 처리하는데 사용되는 것들이 있습니다.
접두어 <code class="docutils literal notranslate"><span class="pre">i</span></code> 를 붙여서 나타냅니다. 예를 들어 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">+=</span></code> 연산을 제공합니다.
(<a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 연산은 대응하는 증분 대입이 없기 때문에 <code class="docutils literal notranslate"><span class="pre">__idivmod__</span></code> 는 존재하지 않습니다.)</p>
<p>증분 대입 연산은 그 성격상 대응하는 뒤집힌 연산이 없습니다. 대신에 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> 라는 문장을 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>
라는 문장으로 변환해서 시도합니다. 때문에 <code class="docutils literal notranslate"><span class="pre">x</span></code> 에 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> 가 정의되지 않았거나
<code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려주면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 를 시도하게 됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>증분 대입 연산 메서드는, 가변형의 경우 자신의 값을 수정한 후 <code class="docutils literal notranslate"><span class="pre">self</span></code> 를 돌려주는 것이 관례이고,
이 경우 아이덴티티의 변경(새로운 객체가 만들어진다는 의미)은 이루어지지 않습니다. 하지만 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>
형으로 변환되는 경우, 아이덴티티가 바뀔 수 있음에 주의해야 합니다. 불변형인 경우는, 아이덴티티의 변경을
수반하는 것이 자연스럽기 때문에 혼란을 일으킬 가능성이 적습니다.</p>
<p>간혹 일으키기 쉬운 실수는 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 와 이름이 비슷한 <a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>
(추상 메서드임을 가리키는데 사용하는 예외입니다) 를 돌려주는 것입니다. 이 경우 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>
예외를 일으키지 않고 좌변이 <a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 로 치환되게 됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>비교 메서드란, 두 값을 비교하는데 사용되는 비교 연산자(comparison operator)
(<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) 의 기능을 제공하는 역할을 하는, 다음과 같은
메서드들을 뜻합니다.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a></p></li>
<li><p><a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a></p></li>
</ul>
<p>3.0 이전의 파이썬에서는 값들 간의 대소 관계를 정수로 표현하는 <code class="docutils literal notranslate"><span class="pre">__cmp__</span></code> 메서드를 지원했고, 이를 비교
메서드라고 불렀습니다. 하지만 대소 관계(ordering)가 정의될 수 없는 경우도, 동등 관계(equality)는 정의될
수 있는 경우가 있고, 두 경우 모두 지원되는 경우도 동등 관계가 대소 관계에 비해 적은 계산이 필요한 경우가 많아서,
각 비교 연산을 별개의 메서드로 지원하는 방법이 새로 도입되었습니다. 그 전의 <code class="docutils literal notranslate"><span class="pre">__cmp__</span></code> 와 구분하기 위해 이
것들을 rich comparison 이라고 부릅니다. 하지만 파이썬 3.0 부터는 <code class="docutils literal notranslate"><span class="pre">__cmp__</span></code> 가 지원되지 않고, 좋은
번역어를 발견할 수도 없어서, 그냥 비교 메서드라고 부르기로 합니다. 앞으로 비교라는 단어는 rich comparison
을 가리키는 것으로 보면 됩니다.</p>
</div>
</dd>
<dt>Ellipsis</dt><dd><p id="index-8">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 리터럴 <code class="docutils literal notranslate"><span class="pre">...</span></code> 이나 내장된 이름 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 을 통해 접근합니다. 논리값은 참입니다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a></dt><dd><p id="index-9">이것들은 숫자 리터럴에 의해 만들어지고, 산순 연산과 내장 산술 함수들이 결과로 돌려줍니다. 숫자 객체는 불변입니다; 한 번 값이 만들어지면 절대 변하지 않습니다. 파이썬의 숫자는 당연히 수학적인 숫자들과 밀접하게 관련되어 있습니다, 하지만 컴퓨터의 숫자 표현상의 제약을 받고 있습니다.</p>
<p>파이썬은 정수, 실수, 복소수를 구분합니다:</p>
<dl>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></dt><dd><p id="index-10">이것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타냅니다.</p>
<p>두 가지 종류의 정수가 있습니다:</p>
<p>정수 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</p>
<blockquote>
<div><p>이것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현합니다. 시프트(shift)와 마스크(mask) 연산이 목적일 때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2's complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된 것과 같은 효과를 줍니다.</p>
</div></blockquote>
<dl>
<dt>불린 (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p id="index-11">이것은 논리값 거짓과 참을 나타냅니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 와 <code class="docutils literal notranslate"><span class="pre">True</span></code> 두 객체만 불린 형 객체입니다. 불린 형은 int 형의 자식형(subtype)이고, 대부분 상황에서 각기 0과1처럼 동작합니다. 예외는 문자열로 변환되는 경우인데, 각기 문자열 <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> 와 <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> 가 반환됩니다.</p>
</dd>
</dl>
<p id="index-12">정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미 있는 해석을 제공하기 위한 것입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>제약 없는 범위의 숫자를 지원한다고는 하지만 사실은 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 에 의해 제약이 가해집니다.
그러나, <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 가 충분히 크기 때문에, 이 제약에 도달하기 전에 메모리 한계에 도달하게됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>2의 보수는 어떤 숫자를 큰 2의 거듭제곱수에서 뺀 값을 뜻합니다. 가령 8비트 공간에서 숫자 1의 2의 보수는
<code class="docutils literal notranslate"><span class="pre">2**8</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">==</span> <span class="pre">255</span></code> 가 됩니다. 음수를 표현할 때 2의 보수를 사용한다는 것은, (계속 8비트 공간을 예로
들자면) -3 을 표현할 때, 그 양의 숫자 3(<code class="docutils literal notranslate"><span class="pre">0b0000_0011</span></code>) 의 2의 보수 253(<code class="docutils literal notranslate"><span class="pre">0b1111_1101</span></code>) 으로
표현한다는 뜻입니다. 이 값은 양의 숫자의 비트를 반전 시킨 후(<code class="docutils literal notranslate"><span class="pre">0b11111100</span></code>)에 1을 더한 값과 같습니다.</p>
<p>이 논리를 무한한 크기의 숫자로 확장하기위해, 양의 숫자 3을 비트 0 이 왼쪽에 무한히 붙어있다고
(<code class="docutils literal notranslate"><span class="pre">0b0000...0000_0011</span></code>) 상상해봅시다. <code class="docutils literal notranslate"><span class="pre">...</span></code> 자리가 모두 0으로 채워져 있는 숫자입니다. 이제 비트를
반전시키고 1을 더하면 <code class="docutils literal notranslate"><span class="pre">0b1111...1111_1101</span></code> 이 됩니다. <code class="docutils literal notranslate"><span class="pre">...</span></code> 자리는 모두 1로 채워진 것으로 바뀝니다.
이 개념 모델이 구현될 때, 그 방법은 구현마다 다를 수 있지만, 부호 비트(양수는 0, 음수는 1)를 유지하고, 꼭 필요한
크기의 정수 배열에 값을 저장한다는 점에서는 동일합니다. 그리고는 &quot;무한&quot; 에 해당하는 부분은 부호 비트와 동일한
비트로 채워져있다고 보는 것입니다. 더 큰 자리수가 필요할 때 이 가정을 물리적인 비트로 만듭니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>시프트(shift) 연산은 비트를 왼쪽이나 오른쪽으로 지정한 개수만큼 미는 것인데, 늘 부호가 유지됩니다.
어떤 숫자가 나올지는 앞에서 설명한 개념 모델을 떠올리면 쉽게 판단할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code> 은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">pow(2,n)</span></code> 과 같고, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code> 은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">pow(2,n)</span></code> 과 같습니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>마스크(mask) 연산은 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> 연산자를 사용하는 연산을 뜻하는데, 정수의 경우 비트열로 변환한 후
비트별로 AND, OR, XOR 연산을 수행하는 것을 뜻합니다. 이 경우 부호 비트끼리 AND, OR, XOR 를 수행해 보면
결과의 부호를 쉽게 파악할 수 있습니다. 개념 모델의 &quot;무한&quot; 부분은 이 값의 반복이 됩니다. 나머지 비트들은 어렵지
않게 파악할 수 있습니다.</p>
</div>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)</dt><dd><p id="index-13">이것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타냅니다. 허락되는 값의 범위와 오버플로의 처리에 관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수밖에 없습니다. 파이썬은 단정도(single precision) 부동 소수점 수를 지원하지 않습니다; 이것들을 사용하는 이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 비용과 상쇄되어 미미해집니다. 그 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>허락되는 값의 범위는 <a class="reference internal" href="../library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a> 에서 제공됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>대부분의 경우 IEEE 754 를 따르고 있습니다. 이 경우 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 는 64비트로 표현됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>대부분의 플랫폼에서, 오버플로우를 일으키면, 예외를 일으키지 않고 <a class="reference internal" href="../library/math.html#math.inf" title="math.inf"><code class="xref py py-const docutils literal notranslate"><span class="pre">math.inf</span></code></a> 나 -<a class="reference internal" href="../library/math.html#math.inf" title="math.inf"><code class="xref py py-const docutils literal notranslate"><span class="pre">math.inf</span></code></a>
를 돌려줍니다. 이런 동작은 표준 라이브러리의 fpectl 모듈을 통해 일부 변경할 수 있지만, 보통 fpectl 모듈이
제거된 상태로 배포되는 경우가 많고, 파이썬 3.7 부터는 이 모듈이 아예 삭제되었습니다.</p>
</div>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)</dt><dd><p id="index-14">이것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타냅니다. 부동 소수점 수와 한계와 문제점을 공유합니다. 복소수 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 실수부와 허수부는, 읽기 전용 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> 와 <code class="docutils literal notranslate"><span class="pre">z.imag</span></code> 로 꺼낼 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>시퀀스들</dt><dd><p id="index-15">음이 아닌 정수로 인덱싱(indexing)될 수 있는 유한한 길이의 순서 있는 집합을 나타냅니다. 내장함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 시퀀스가 가진 항목들의 개수를 돌려줍니다. 시퀀스의 길이가 <em>n</em> 일 때, 인덱스(index) 집합은 숫자 0, 1, ..., <em>n</em>-1을 포함합니다. 시퀀스 <em>a</em> 의 항목 <em>i</em> 는 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> 로 선택됩니다.</p>
<p id="index-16">시퀀스는 슬라이싱도 지원합니다: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> 는 <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>k</em> 를 선택합니다. 표현식에서 사용될 때, 슬라이스는 같은 형의 시퀀스입니다. 인덱스 집합은 0에서 시작되도록 다시 번호 매겨집니다.</p>
<p>어떤 시퀀스는 세 번째 &quot;스텝(step)&quot; 매개변수를 사용하는 &quot;확장 슬라이싱(extended slicing)&quot;도 지원합니다: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code>, <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>x</em> 를 선택합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>마치 확장 슬라이싱을 지원하지 않는 시퀀스가 존재하는 것처럼 표현되었지만, 사실 파이썬에 내장된 시퀀스들은
모두 확장 시퀀스를 지원합니다. 지원하지 않을 가능성이 있는 것들은 사용자 정의 시퀀스들 뿐입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>원래 확장 슬라이싱은 수치 계산용 라이브러리(NumPy 의 조상뻘 되는 것)를 만드는 그룹의 요청으로 들어온 기능
(가령 전치행렬(transposed matrix)은 스텝을 조작하는 것 만으로도 표현 가능합니다)이고, 그 당시에는
파이썬의 내장 시퀀스들이 오히려 확장 시퀀스를 지원하지 않고 있었습니다.</p>
</div>
<p>시퀀스는 불변성에 따라 구분됩니다</p>
<dl>
<dt>불변 시퀀스</dt><dd><p id="index-17">불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없습니다. (만약 다른 객체로의 참조를 포함하면, 그 객체는 가변일 수 있고, 변경될 수 있습니다; 하지만, 불변 객체로부터 참조되는 객체의 집합 자체는 변경될 수 없습니다.)</p>
<p>다음과 같은 형들은 불변 시퀀스입니다:</p>
<dl id="index-18">
<dt>문자열(Strings)</dt><dd><p id="index-19">문자열은 유니코드 코드 포인트(Unicode code point)들을 표현하는 값들의 시퀀스입니다. <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> 범위의 모든 코드 포인트들은 문자열로 표현될 수 있습니다. 파이썬에는 <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> 형이 없습니다. 대신에 문자열에 있는 각 코드 포인트는 길이 <code class="docutils literal notranslate"><span class="pre">1</span></code> 인 문자열 객체로 표현됩니다. 내장 함수 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 는 코드 포인트를 문자열 형식에서 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> 범위의 정수로 변환합니다; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 은 범위 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> 의 정수를 해당하는 길이 <code class="docutils literal notranslate"><span class="pre">1</span></code> 의 문자열 객체로 변환합니다. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 는 주어진 텍스트 인코딩을 사용해서 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 을 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 로 변환하고, <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 는 그 반대 작업을 수행합니다.</p>
</dd>
<dt>튜플(Tuples)</dt><dd><p id="index-20">튜플의 항목은 임의의 파이썬 객체입니다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 목록으로 만들 수 있습니다. 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 붙여서 만들 수 있습니다(괄호로 표현식을 묶을 수 있으므로, 표현식 만으로는 튜플을 만들지 않습니다). 빈 튜플은 한 쌍의 빈 괄호로 만들 수 있습니다.</p>
</dd>
<dt>바이트열(Bytes)</dt><dd><p id="index-21">바이트열(bytes) 객체는 불변 배열입니다. 항목은 8-비트 바이트인데, 0 &lt;= x &lt; 256 범위의 정수로 표현됩니다. 바이트 객체를 만들 때는 바이트열 리터럴(<code class="docutils literal notranslate"><span class="pre">b'abc'</span></code> 와 같은) 과 내장 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> 생성자(constructor)를 사용할 수 있습니다. 또한, 바이트열 객체는 <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 통해 문자열로 디코딩될 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>가변 시퀀스</dt><dd><p id="index-22">가변 시퀀스는 만들어진 후에 변경될 수 있습니다. 서브스크립션(subscription)과 슬라이싱은 대입문과 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (삭제) 문의 대상으로 사용될 수 있습니다.</p>
<p>현재 두 개의 내장 가변 시퀀스형이 있습니다:</p>
<dl>
<dt>리스트(Lists)</dt><dd><p id="index-23">리스트의 항목은 임의의 파이썬 객체입니다. 리스트는 콤마로 분리된 표현식을 대괄호 안에 넣어서 만들 수 있습니다. (길이 0이나 1의 리스트를 만드는데 별도의 규칙이 필요 없습니다.)</p>
</dd>
<dt>바이트 배열(Byte Arrays)</dt><dd><p id="index-24">바이트 배열(bytearray) 객체는 가변 배열입니다. 내장 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 생성자로 만들어집니다. 가변이라는 것(그래서 해싱 불가능하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) 객체와 같은 인터페이스와 기능을 제공합니다.</p>
</dd>
</dl>
<p id="index-25">확장 모듈 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 는 추가의 가변 시퀀스 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지입니다.</p>
</dd>
</dl>
</dd>
<dt>집합 형들(Set types)</dt><dd><p id="index-26">이것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타냅니다. 인덱싱할 수 없습니다. 하지만 이터레이트할 수 있고, 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 집합 안에 있는 항목들의 개수를 돌려줍니다. 집합의 일반적인 용도는 빠른 멤버십 검사(fast membership testing), 시퀀스에서 중복된 항목 제거, 교집합(intersection), 합집합(union), 차집합(difference), 대칭차집합(symmetric difference)과 같은 집합 연산을 계산하는 것입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이터레이트한다는 것은, 인덱싱할 수는 없어도, 집합이 갖고 있는 원소들을 중복 없고 빠짐 없이 하나씩
꺼내볼 수 있다는 뜻입니다.</p>
</div>
<p>집합의 원소들에는 딕셔너리 키와 같은 불변성 규칙이 적용됩니다. 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다는 점에 주의해야 합니다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), 그중 하나만 집합에 들어갈 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>딕셔너리 키와 동일한 불변성 규칙이라 함은 해시가능성(hashability)을 뜻합니다. 객체가
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드와 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 메서드를 제공할 때 해시가능하다고 합니다.
또한 두 메서드의 구현에는 두 개의 제약 조건이 더 붙는데, <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 는 항상 같은 값을
제공해야 하고, <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려주면 언제나 두 객체의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>
도 동일한 값을 제공해야 한다는 것입니다. 이 때문에 대체로 해시 가능성은 불변성을 포함하는 경향이
있지만 언어에서 강제하는 것은 아닙니다. 가령 내장 불변형들이 해시 가능하고, 가변 내장 컨테이너들이
해시 가능하지 않다는 사실은 이 관례를 따르고 있지만, 사용자 정의형들은 가변성의 여부와 관계없이
기본적으로 해시 가능합니다. 이는 사용자 정의형들의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 와 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>
기본 구현이 값은 무시하고 아이덴티티만 고려하기 때문입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>내장 불변 컨테이너가 무조건 적으로 해시 가능하지는 않습니다. 저장된 값들 역시 해시 가능해야 합니다.
가령 <code class="docutils literal notranslate"><span class="pre">()</span></code> 와 <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">'a')</span></code> 는 해시 가능하지만, <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">['a'])</span></code> 는 해시 가능하지 않습니다.
이는 불변성과 해시 가능성이 다른 조건임을 보여주는 한 예입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>집합과 딕셔너리의 키에서 해시가능성을 요구하는 이유는, 둘 다 해시테이블(hashtable) 기반의 자료
구조인데, 해시값이 변경될 경우 해시테이블을 재배치할 수 있는 메커니즘이 없기 때문입니다.(있어봐야
부담만 커지고 실익이 없기 때문입니다.) 내장 불변 컨테이너들은 값 기반의 깊은 해싱(deep hashing)을
사용하는데, 이 조건이 모든 경우에 필요한 것은 아니고, 단지 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 언제나 같은 값을
주어야 하고, <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 일관성이 있어야 하는데, 내장 불변형 컨테이너들은 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>
에서 이미 깊은 비교(deep comparison)를 제공하고 있기 때문입니다.</p>
</div>
<p>현재 두 개의 내장 집합 형이 있습니다:</p>
<dl>
<dt>집합(Sets)</dt><dd><p id="index-27">이것들은 가변 집합을 나타냅니다. 내장 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> 생성자로 만들 수 있고, <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> 같은 메서드들을 사용해서 나중에 수정할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>중괄호 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 를 쓰는 집합 리터럴을 사용해서 만들 수도 있습니다. 하지만 이 방법으로 빈 집합을
만들 수는 없습니다.</p>
</div>
</dd>
<dt>불변 집합(Frozen sets)</dt><dd><p id="index-28">이것들은 불변 집합을 나타냅니다. 내장 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> 생성자로 만들 수 있습니다. 불변 집합(frozenset)은 불변이고 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 하므로, 다른 집합의 원소나, 딕셔너리의 키로 사용될 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>매핑(Mappings)</dt><dd><p id="index-29">이것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 인덱스 표기법(subscript notation) <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> 는 매핑 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">k</span></code> 로 인덱스 되는 항목을 선택합니다; 이것은 표현식에 사용될 수도 있고, 대입이나 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문장의 대상이 될 수도 있습니다. 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 매핑에 포함된 항목들의 개수를 돌려줍니다.</p>
<p>현재 한 개의 내장 매핑 형이 있습니다:</p>
<dl>
<dt>딕셔너리(Dictionaries)</dt><dd><p id="index-30">이것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 키로 사용할 수 없는 것들은 리스트, 딕셔너리나 그 외의 가변형 중에서 아이덴티티가 아니라 값으로 비교되는 것들뿐입니다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 변경되지 않고 계속 같은 값으로 유지되도록 요구하고 있기 때문입니다. 키로 사용되는 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용됩니다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), 둘 다 같은 딕셔너리 항목을 인덱싱하는데 사용될 수 있습니다.</p>
<p>딕셔너리는 가변입니다; <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 표기법으로 만들 수 있습니다 (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">딕셔너리 디스플레이</span></a> 섹션을 참고하십시오).</p>
<p id="index-31">확장 모듈 <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> 과 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> 는 추가의 매핑 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지입니다.</p>
</dd>
</dl>
</dd>
<dt>콜러블(Callable types)</dt><dd><p id="index-32">이것들은 함수 호출 연산(<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 섹션 참고)이 적용될 수 있는 형들입니다:</p>
<dl>
<dt>사용자 정의 함수</dt><dd><p id="index-33">사용자 정의 함수 객체는 함수 정의를 통해 만들어집니다 (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션 참고). 함수의 형식 매개변수(formal parameter) 목록과 같은 개수의 항목을 포함하는 인자(argument) 목록으로 호출되어야 합니다.</p>
<p>특수 어트리뷰트들(Special attributes):</p>
<table class="docutils align-default" id="index-34">
<colgroup>
<col style="width: 37%" />
<col style="width: 46%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>의미</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></p></td>
<td><p>함수를 설명하는 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>; 서브 클래스로 상속되지 않습니다.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></p></td>
<td><p>함수의 이름.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></p></td>
<td><p>함수의 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">정규화된 이름</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></p></td>
<td><p>함수가 정의된 모듈의 이름 또는 (없는 경우) <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></p></td>
<td><p>인자의 기본값 또는 (없는 경우) <cite>None</cite> 으로 만들어진 튜플.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></p></td>
<td><p>컴파일된 함수의 바디(body) 를 나타내는 코드 객체</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></p></td>
<td><p>함수의 전역 변수들을 가진 딕셔너리에 대한 참조 --- 함수가 정의된 모듈의 전역 이름 공간(namespace)</p></td>
<td><p>읽기 전용</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></p></td>
<td><p>임의의 함수 어트리뷰트를 지원하는 이름 공간.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 함수의 자유 변수(free variable)들에 대한 연결을 가진 셀(cell)들의 튜플. <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> 어트리뷰트에 대한 정보는 아래를 보십시오.</p></td>
<td><p>읽기 전용</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></p></td>
<td><p>매개변수의 어노테이션을 가진 dict. dict의 키는 매개변수의 이름인데, 반환 값 어노테이션이 있다면 <code class="docutils literal notranslate"><span class="pre">'return'</span></code> 을 키로 사용합니다.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></p></td>
<td><p>키워드 형태로만 전달 가능한 매개변수들의 기본값을 가진 dict.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
</tbody>
</table>
<p>&quot;쓰기 가능&quot; 하다고 표시된 대부분의 어트리뷰트들은 값이 대입될 때 형을 검사합니다.</p>
<p>함수 객체는 임의의 어트리뷰트를 읽고 쓸 수 있도록 지원하는데, 예를 들어 함수에 메타데이터(metadata)를 붙이는데 사용될 수 있습니다. 어트리뷰트를 읽거나 쓸 때는 일반적인 점 표현법(dot-notation)이 사용됩니다. <em>현재 구현은 오직 사용자 정의 함수만 함수 어트리뷰트를 지원함에 주의해야 합니다. 내장 함수의 함수 어트리뷰트는 미래에 지원될 수 있습니다.</em></p>
<p>셀 객체는 <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> 어트리뷰트를 가지고 있습니다. 셀의 값을 읽을 뿐만 아니라 값을 설정하는 데도 사용할 수 있습니다.</p>
<p>함수 정의에 관한 추가적인 정보를 코드 객체로부터 얻을 수 있습니다. 아래에 나오는 내부 형의 기술을 참고하십시오. <a class="reference internal" href="../library/types.html#types.CellType" title="types.CellType"><code class="xref py py-data docutils literal notranslate"><span class="pre">셀</span></code></a> 형은 <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> 모듈에서 액세스할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>REPR 환경에서 정의된 경우 보통 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>다른 함수 내에서 정의되는 함수가, 전역도 지역도 아닌 변수를 사용하는 경우가 있습니다. 이 변수들을 자유 변수(free variable)라고 하는데, 이 때 이 변수들의 값이 셀(cell) 이라는 내부 객체에 보관됩니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code> 는 이 셀들의 목록을 튜플로 제공합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">counter</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">tick</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">nonlocal</span> <span class="n">n</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">n</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">tick</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counter</span><span class="o">.</span><span class="vm">__closure__</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="vm">__closure__</span>
<span class="go">(&lt;cell at 0x103e51b28: int object at 0x1009dcc60&gt;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cell_contents</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cell_contents</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>모듈의 전역 함수로 정의되지 않은 함수들에 접근하기 위해서는, 다른 객체들을 거쳐야 할 수 있습니다. 가령 앞에 소개한 <code class="docutils literal notranslate"><span class="pre">tick</span></code> 도 그렇고, 클래스의 메서드로 정의되는 함수들도 그렇습니다. <a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a> 은 함수에 접근하는데 필요한 이름들을 (모듈명은 제외하고) 모두 제공합니다. 반면 <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 함수의 이름만을 제공합니다. 앞의 예를 사용하면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">counter</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;counter&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counter</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;counter&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;tick&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;counter.&lt;locals&gt;.tick&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;f&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;X.f&#39;</span>
</pre></div>
</div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>또 다른 예를 하나 들어보겠습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">kp</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">n</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__annotations__</span>
<span class="go">{&#39;n&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span>
<span class="go">(5,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__kwdefaults__</span>
<span class="go">{&#39;kp&#39;: None}</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 형 정보가 지정된 인자들과 반환값의 형 정보를 제공합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code> 는 위치가 할당된 인자들의 기본 값들을 제공합니다. 튜플의 길이는 위치가 할당된 인자들의 개수와 일치합니다. 예에서 <code class="docutils literal notranslate"><span class="pre">args</span></code> 는 기본값을 가지는 것이 불가능하기 때문에  <code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code> 에 할당되는 자리도 없습니다. <code class="docutils literal notranslate"><span class="pre">*args</span></code> 뒤에 오는 인자들은 위치가 지정되지 않고, 오직 키워드 형태로만 전달될 수 있습니다. 이 것들의 기본 값은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code> 에 딕셔너리 형태로 제공됩니다.</p>
<p>이 값들은 단순한 정보가 아니고, 실제로 함수가 실행중에 사용하고 있는 값입니다. 때문에, 바꾸면 영향을 받습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">9</span>
</pre></div>
</div>
</div>
</dd>
<dt>인스턴스 메서드(Instance methods)</dt><dd><p id="index-35">인스턴스 메서드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합합니다.</p>
<p id="index-36">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 클래스 인스턴스 객체, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 는 함수 객체; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 메서드의 설명 (<code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code> 과 같습니다); <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 메서드의 이름 (<code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code> 과 같습니다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 메서드가 정의된 모듈의 이름이거나 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__self__</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__func__</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">f</span> <span class="c1"># C.f 는 일반 사용자 정의 함수입니다.</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span> <span class="c1"># 기반 함수의 어트리뷰트는 쓰기가능합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span> <span class="c1"># 인스턴스 메서드는 기반 함수의 특수 어트리뷰트를 반영합니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span>  <span class="c1"># 인스턴스 메서드의 특수 어트리뷰트는 읽기전용입니다</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;__name__&#39;</span>
</pre></div>
</div>
</div>
<p>메서드는 기반 함수의 모든 함수 어트리뷰트들을 읽을 수 있도록 지원합니다(하지만 쓰기는 지원하지 않습니다).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>앞의 예에서 계속됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># 함수 어트리뷰트</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sample</span>        <span class="c1"># 함수 어트리뷰트는 인스턴스 메서드에도 따라옵니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># 하지만 인스턴스 메서드의 어트리뷰트에 쓸 수는 없습니다</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;sample&#39;</span>
</pre></div>
</div>
</div>
<p>어트리뷰트가 사용자 정의 함수 객체이거나 클래스 메서드 객체면, 사용자 정의 메서드 객체는 클래스의 어트리뷰트를 읽을 때 만들어질 수 있습니다 (아마도 그 클래스의 인스턴스를 통해서).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span>
<span class="gp">... </span>    <span class="nd">@classmethod</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">cls</span>
<span class="gp">... </span>    <span class="nd">@staticmethod</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">h</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">f</span> <span class="c1"># 인스턴스 메서드는 새로 만들어지는 객체입니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">g</span> <span class="c1"># 클래스 메서드도 새로 만들어집니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">h</span> <span class="c1"># 하지만 스태틱 메서드는 새로 만들어지지 않습니다</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">f</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">f</span> <span class="c1"># 클래스틀 통하면 사용자 정의 함수는 새로 만들어지지 않습니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">h</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">h</span> <span class="c1"># 스태틱 메서드도 마찬가지입니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">g</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">g</span> <span class="c1"># 하지만 클래스 메서드는 클래스를 통해 읽을 때도 새로 만들어집니다</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<p>인스턴스 메서드 객체가 클래스 인스턴스를 통해 클래스의 사용자 정의 함수 객체를 읽음으로써 만들어질 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트는 인스턴스이고, 메서드 객체는 결합(bound)하였다고 말합니다. 새 메서드의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트는 원래의 함수 객체입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span>    <span class="c1"># 인스턴스 메서드를 bound method 라고 부릅니다</span>
<span class="go">&lt;bound method C.f of &lt;C object at 0x104f809b0&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__self__</span> <span class="ow">is</span> <span class="n">i</span> <span class="c1"># __self__ 는 연결된(bound) 인스턴스입니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__func__</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">f</span> <span class="c1"># __func__ 는 원래의 함수 객체입니다</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>조금 다른 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span>
<span class="gp">... </span>    <span class="nd">@classmethod</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">cls</span>
<span class="gp">... </span>    <span class="nd">@staticmethod</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">h</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">g</span> <span class="c1"># 클래스 메서드는 클래스로 접근해도 새로 만들어집니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">g</span> <span class="c1"># 클래스 메서드 역시 결합된 메서드입니다</span>
<span class="go">&lt;bound method C.g of &lt;class &#39;C&#39;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="vm">__func__</span> <span class="c1"># __func__ 는 일반 사용자 정의 함수 객체입니다</span>
<span class="go">&lt;function C.g at 0x10c4dc488&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="vm">__func__</span> <span class="c1"># 인스턴스 메서드의 __func__ 는 클래스 메서드 객체의 __func__ 로 연결됩니다</span>
<span class="go">&lt;function C.g at 0x10c4dc488&gt;</span>
</pre></div>
</div>
</div>
<p>인스턴스 메서드 객체가 클래스나 인스턴스로부터 클래스 메서드 객체를 읽음으로써 만들어질 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트는 클래스 자신이고, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트는 클래스 메서드가 기반을 두는 함수 객체입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>앞의 예에서 계속됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="vm">__self__</span> <span class="ow">is</span> <span class="n">C</span> <span class="c1"># 클래스 메서드의 __self__ 는 클래스입니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="vm">__self__</span> <span class="ow">is</span> <span class="n">C</span> <span class="c1"># 클래스 메서드로부터 만들어지는 인스턴스 메서드의 __self__ 역시 클래스입니다</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<p>인스턴스 메서드 객체가 호출될 때, 기반을 두는 함수 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) 가 호출되는데, 인자 목록의 앞에 클래스 인스턴스 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) 가 삽입됩니다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 가 함수 <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> 의 정의를 포함하는 클래스이고, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 의 인스턴스일 때, <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> 를 호출하는 것은 <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code> 을 호출하는 것과 같습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>앞의 예에서 계속됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="p">()</span> <span class="ow">is</span> <span class="n">i</span><span class="o">.</span>     <span class="c1"># 첫번째 인자로 __self__ 가 전달됩니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span><span class="p">()</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># i.f() 와 C.f(i) 는 같은 결과를 줍니다.</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">g</span><span class="p">()</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span>     <span class="c1"># 클래스 메서드는 __self__ 가 클래스입니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">g</span><span class="p">()</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">g</span><span class="p">()</span><span class="o">.</span> <span class="c1"># 클래스 메서드는 i.g() 와 C.g() 가 같은 결과를 줍니다. C.g 도 결합된 메서드입니다</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<p>인스턴스 메서드 객체가 클래스 메서드 객체로부터 올 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 에 저장된 &quot;클래스 인스턴스&quot; 는 실제로는 클래스 자신입니다. 그래서 <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> 을 호출하는 것은 <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> 를 호출하는 것과 같습니다 (<code class="docutils literal notranslate"><span class="pre">f</span></code> 는 기반 함수입니다).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>앞의 예에서 계속됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">g</span><span class="p">()</span> <span class="ow">is</span> <span class="n">i</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="vm">__func__</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># 클래스 메서드로 부터 온 인스턴스 메서드를 호출하는 것은 기반 함수에 클래스를 전달해서 호출하는 것과 같습니다.</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<p>함수 객체에서 인스턴스 객체로의 변환은 인스턴스로부터 어트리뷰트를 읽을 때마다 일어남에 주의해야 합니다. 어떤 경우에, 어트리뷰트를 지역 변수에 대입하고, 그 지역 변수를 호출하는 것이 효과적인 최적화가 됩니다. 또한, 이 변환이 사용자 정의 함수에 대해서만 발생함에 주의해야 합니다; 다른 콜러블 객체 (그리고 콜러블이 아닌 모든 객체)는 변환 없이 읽힙니다. 클래스 인스턴스의 어트리뷰트인 사용자 정의 함수는 결합한 메서드로 변환되지 않는다는 것도 중요합니다; 이 변환은 함수가 클래스 어트리뷰트일 때만 일어납니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>앞의 예에서 계속됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">f</span> <span class="c1"># 인스턴스 메서드는 읽을 때마다 새로 만들어집니다.</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">f</span> <span class="c1"># 인스턴스 메서드를 지역 변수에 저장해서 사용하면 성능을 개선할 수 있습니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">timeit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;i.f()&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="nb">locals</span><span class="p">())</span>
<span class="go">0.136665727943182</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;f()&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="nb">locals</span><span class="p">())</span>
<span class="go">0.09192681103013456</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span> <span class="c1"># 클래스 어트리뷰트로 사용자 정의 함수를 넣으면 메서드를 정의한 것과 같은 결과를 줍니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">p</span><span class="p">()</span> <span class="ow">is</span> <span class="n">i</span> <span class="c1"># 마찬가지 변환이 일어납니다.</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">q</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>     <span class="c1"># 인스턴스 어트리뷰트로 사용자 정의 함수를 넣으면</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">q</span> <span class="ow">is</span> <span class="n">q</span>    <span class="c1"># 변환이 일어나지 않습니다</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">q</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span> <span class="c1"># 따라서 __self__ 도 전달되지 않습니다.</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd>
<dt>제너레이터 함수(Generator functions)</dt><dd><p id="index-37"><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문(<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 문</span></a> 절 참조)을 사용하는 함수나 메서드를 <em class="dfn">제너레이터 함수 (generator function)</em> 라고 부릅니다. 이런 함수를 호출하면 항상 이터레이터(iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하는 데 사용됩니다: 이터레이터의 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> 메서드를 호출하면 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 문이 값을 제공할 때까지 함수가 실행됩니다. 함수가 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하거나 끝에 도달하면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으키고, 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이터레이터 프로토콜 이라는 것인데, <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> 메서드를 직접 호출하기 보다는
다음과 같은 네가지 방법을 많이 사용합니다.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 등 이터레이터를 받아들이는 컨테이너들의 생성자로 전달해서 변환</p></li>
<li><p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 문</p></li>
<li><p><a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 내장 함수</p></li>
</ul>
<p><a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 내장 함수를 사용하는 경우는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 직접 처리해야 하고,
나머지 경우는 그러지 않아도 됩니다.</p>
</div>
</dd>
<dt>코루틴 함수(Coroutine functions)</dt><dd><p id="index-38"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수나 메서드를 <em class="dfn">코루틴 함수 (coroutine function)</em> 라고 부릅니다. 이런 함수를 호출하면 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체를 돌려줍니다. <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 비롯해, <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 와 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문을 사용할 수 있습니다. <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">코루틴 객체(Coroutine Objects)</span></a> 섹션을 참조하십시오.</p>
</dd>
<dt>비동기 제너레이터 함수(Asynchronous generator functions)</dt><dd><p id="index-39"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수가 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 사용하면 <em class="dfn">비동기 제너레이터 함수 (asynchronous generator function)</em> 라고 부릅니다. 이런 함수를 호출하면 항상 비동기 이터레이터(asynchronous iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하기 위해 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용됩니다.</p>
<p>비동기 이터레이터의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__()</span></code> 메서드를 호출하면 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 을 돌려주는데, await 할 때 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문이 값을 제공할 때까지 함수가 실행됩니다. 함수가 빈 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하거나 끝에 도달하면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외를 일으키고, 비동기 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다.</p>
</dd>
<dt>내장 함수(Built-in functions)</dt><dd><p id="index-40">내장 함수 객체는 C 함수를 둘러싸고 있습니다(wrapper). 내장 함수의 예로는 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 과 <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 는 표준 내장 모듈입니다) 가 있습니다. 인자의 개수와 형은 C 함수에 의해 결정됩니다. 특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 함수의 설명 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 함수의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정됩니다 (하지만 다음 항목을 보십시오); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 함수가 정의된 모듈의 이름이거나 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
</dd>
<dt>내장 메서드(Built-in methods)</dt><dd><p id="index-41">이것은 사실 내장 함수의 다른 모습입니다. 이번에는 묵시적인 추가의 인자로 C 함수에 전달되는 객체를 갖고 있습니다. 내장 메서드의 예로는 <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code> 가 있는데, <em>alist</em> 는 리스트 객체입니다. 이 경우에, 특수 읽기 전용 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 <em>alist</em> 로 표현된 객체로 설정됩니다.</p>
</dd>
<dt>클래스(Classes)</dt><dd><p>클래스는 콜러블입니다. 이 객체들은 보통 자신의 새로운 인스턴스를 만드는 팩토리(factory)로 동작하는데, <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드를 재정의(override)하는 클래스 형에서는 달라질 수도 있습니다. 호출 인자는 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 로 전달되고, 일반적으로, 새 인스턴스를 초기화하기 위해 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 로도 전달됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 인스턴스 객체를 만드는데 사용되고, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 그 객체를
초기화하는데 사용됩니다. 일반적으로는 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 를 재정의하지 않는데, 이 경우 새 인스턴스가
만들어집니다. 하지만 특별한 목적으로 이를 재정의할 수 있습니다. 가령 클래스의 인스턴스가 오직 하나만
만들어지게 하고 싶다거나, 예전에 반납한 인스턴스들을 재활용 하고 싶다거나 하는 경우입니다. 이런 경우
언제나 새 인스턴스가 만들어진다고 보장할 수는 없고, 두 번 초기화될 가능성이 있기 때문에
<a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 를 호출할지 여부를 결정하는 규칙이 존재합니다.
자세한 내용은 <a class="reference internal" href="#customization"><span class="std std-ref">기본적인 커스터마이제이션</span></a> 섹션에 나옵니다.</p>
</div>
</dd>
<dt>클래스 인스턴스(Class Instances)</dt><dd><p>클래스에서 <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 메서드를 정의함으로써, 클래스 인스턴스를 콜러블로 만들 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>모듈(Modules)</dt><dd><p id="index-42">모듈은 파이썬 코드의 기본적인 조직화 단위이고, <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문이나, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 과 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 호출해서 구동할 수 있는 <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">임포트 시스템</span></a> 에 의해 만들어집니다. 모듈 객체는 딕셔너리 객체로 구현되는 이름 공간을 갖습니다(이 딕셔너리 객체는 모듈에서 정의되는 함수들의 <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> 어트리뷰트로 참조됩니다). 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code> 와 같습니다. 모듈 객체는 모듈을 초기화하는데 사용된 코드 객체를 갖고 있지 않습니다 (일단 초기화가 끝나면 필요 없으므로).</p>
<p>어트리뷰트 대입은 모듈의 이름 공간 딕셔너리를 갱신합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> 은 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> 과 같습니다.</p>
<p id="index-43">미리 정의된 (쓰기 가능한) 어트리뷰트들: <a class="reference internal" href="import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 모듈의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 모듈의 설명 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다; (없을 수도 있는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 모듈의 바디를 실행하면서 수집된 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a> 들을 담은 딕셔너리입니다; <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 은 모듈이 로드된 파일의 경로명입니다. 인터프리터에 정적으로 연결된 C 모듈과 같은 어떤 종류의 모듈들에서는 <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트가 제공되지 않습니다; 공유 라이브러리(shared library)로부터 동적으로 로딩되는 확장 모듈의 경우 공유 라이브러리의 경로명이 제공됩니다.</p>
<p id="index-44">특수 읽기 전용 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 딕셔너리로 표현되는 모듈의 이름 공간입니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 이 모듈 딕셔너리를 비우는 방법 때문에, 딕셔너리에 대한 참조가 남아있더라도, 모듈이 스코프를 벗어나면 모듈 딕셔너리는 비워집니다. 이것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 이용하는 동안은 모듈을 잡아두어야 합니다.</p>
</div>
</dd>
<dt>사용자 정의 클래스(Custom classes)</dt><dd><p>사용자 정의 클래스 형들은 보통 클래스 정의 때문에 만들어집니다 (<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a> 섹션 참조). 클래스는 딕셔너리로 구현된 이름 공간을 갖습니다. 클래스 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">C.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> 로 변환됩니다 (하지만 어트리뷰트에 접근하는 다른 방법들을 허락하는 여러 가지 훅(hook)이 있습니다.). 거기에서 어트리뷰트 이름이 발견되지 않으면, 어트리뷰트 검색은 부모 클래스들에서 계속됩니다. 이 부모 클래스 검색은 C3 메서드 결정 순서(method resolution order)를 사용하는데, 다중 상속이 같은 부모 클래스로 모이는 '다이아몬드(diamond)' 계승 구조가 존재해도 올바르게 동작합니다. 파이썬이 사용하는 C3 MRO에 관한 좀 더 자세한 내용은 2.3 배포에 첨부된 문서 <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> 에서 찾아볼 수 있습니다.</p>
<p id="index-45">클래스 어트리뷰트 참조가 (클래스 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 라고 하자) 클래스 메서드 객체로 귀결될 때는, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트가 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 인 인스턴스 메서드 객체로 변환됩니다. 스태틱 메서드로 귀결될 때는, 스태틱 메서드 객체가 감싸고 있는 객체로 변환됩니다. 클래스로부터 얻은 어트리뷰트가 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 에 저장된 값과 달라지도록 만드는 다른 방법이 <a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> 섹션에 나옵니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>&quot;스태틱 메서드 객체가 감싸고 있는 객체&quot;는 기반 함수를 뜻합니다. 즉 원래 함수가 스태틱 메서드
객체라는 껍데기를 벗고 그대로 제공됩니다. 그럼에도 불구하고 껍데기를 씌워두는 것은 인스턴스를 통해
어트리뷰트를 참조할 경우 때문입니다. 껍데기를 씌워두지 않으면 일반적인 인스턴스 메서드로 변환되기
때문에, 이를 막고자, 스태틱 메서드라는 껍데기를 씌워둔 후에, 클래스나 인스턴스 어느쪽이건
어트리뷰트에 접근하면 껍데기를 벗겨서 돌려줍니다.</p>
<p>이런 변환 없이 클래스 어트리뷰트에 저장된 원본(클래스 메서드는 클래스 메서드 인스턴스, 스태틱
메서드는 스태틱 메서드 인스턴스)을 조회하려면, 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>
어트리뷰트에서 꺼내면 됩니다. 다만 이 곳에는 부모 클래스가 제공하는 어트리뷰트는 들어있지 않습니다.</p>
</div>
<p id="index-46">클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 건드리지는 않습니다.</p>
<p id="index-47">클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보십시오) 호출될 수 있습니다(위를 보십시오).</p>
<p id="index-48">특수 어트리뷰트들:<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 클래스의 이름입니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 클래스가 정의된 모듈의 이름입니다. <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 클래스의 이름 공간을 저장하는 딕셔너리입니다; <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 는 부모 클래스들을 저장하는 튜플입니다; 부모 클래스 목록에 나타나는 순서를 유지합니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 클래스의 설명 문자열 이거나 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다; (없을 수 있는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 클래스의 바디를 실행하면서 수집된 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a> 들을 담은 딕셔너리입니다.</p>
</dd>
<dt>클래스 인스턴스(Class instances)</dt><dd><p id="index-49">클래스 인스턴스는 클래스 객체를 호출해서 (위를 보십시오) 만들어집니다. 클래스 인스턴스는 딕셔너리로 구현되는 이름 공간을 갖는데, 어트리뷰트를 참조할 때 가장 먼저 검색되는 곳입니다. 그곳에서 어트리뷰트가 발견되지 않고, 인스턴스의 클래스가 그 이름의 어트리뷰트를 갖고 있으면, 클래스 어트리뷰트로 검색이 계속됩니다. 만약 발견된 클래스 어트리뷰트가 사용자 정의 함수면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트가 인스턴스인 인스턴스 메서드로 변환됩니다. 스태틱 메서드와 클래스 메서드 객체 또한 변환됩니다. 위의 &quot;사용자 정의 클래스(Custom Classes)&quot; 부분을 보십시오. 클래스로부터 얻은 어트리뷰트가 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 에 저장된 값과 달라지도록 만드는 다른 방법이 <a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> 섹션에 나옵니다. 만약 클래스 어트리뷰트도 발견되지 않고, 클래스가 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 메서드를 가지면, 조회를 만족시키기 위해 그 메서드를 호출합니다.</p>
<p id="index-50">어트리뷰트 대입과 삭제는 인스턴스의 딕셔너리를 갱신할 뿐, 결코 클래스의 딕셔너리를 건드리지 않습니다. 만약 클래스가 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 이나 <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 메서드를 가지면, 인스턴스의 딕셔너리를 갱신하는 대신에 그 메서드들을 호출합니다.</p>
<p id="index-51">어떤 특별한 이름들의 메서드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인 척할 수 있습니다. <a class="reference internal" href="#specialnames"><span class="std std-ref">특수 메서드 이름들</span></a> 섹션을 보십시오.</p>
<p id="index-52">특수 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 어트리뷰트 딕셔너리입니다; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 는 인스턴스의 클래스입니다.</p>
</dd>
<dt>I/O 객체 (파일 객체라고도 알려져 있습니다)</dt><dd><p id="index-53"><a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 는 열린 파일을 나타냅니다. 파일 객체를 만드는 여러 가지 단축법이 있습니다: <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 내장 함수, <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> 과 소켓 객체의 <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 메서드들).</p>
<p><code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 는 인터프리터의 표준 입력, 출력, 에러 스트림으로 초기화된 파일 객체들입니다; 모두 텍스트 모드로 열려서 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 추상 클래스에 의해 정의된 인터페이스를 따릅니다.</p>
</dd>
<dt>내부 형(Internal types)</dt><dd><p id="index-54">인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출됩니다. 인터프리터의 미래 버전에서 이들의 정의는 변경될 수 있지만, 완전함을 위해 여기서 언급합니다.</p>
<dl id="index-55">
<dt>코드 객체(Code objects)</dt><dd><p>코드 객체는 <em>바이트로 컴파일된(byte-compiled)</em> 실행 가능한 파이썬 코드를 나타내는데, 그냥 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 라고도 부릅니다. 코드 객체와 함수 객체 간에는 차이가 있습니다; 함수 객체는 함수의 전역 공간(globals) (함수가 정의된 모듈)을 명시적으로 참조하고 있지만, 코드 객체는 어떤 문맥(context)도 갖고 있지 않습니다; 또한 기본 인자값들이 함수 객체에 저장되어 있지만 코드 객체에는 들어있지 않습니다 (실행 시간에 계산되는 값들을 나타내기 때문입니다). 함수 객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) 갖고 있지 않습니다.</p>
<p id="index-56">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> 은 함수의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> 는 위치 인자들 (위치 전용 인자와 기본값이 있는 인자들도 포함됩니다)의 총 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_posonlyargcount</span></code> 는 위치 전용 인자들 (기본값이 있는 인자들도 포함됩니다)의 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_kwonlyargcount</span></code> 는 키워드 전용 인자들 (기본값이 있는 인자들도 포함됩니다)의 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> 는 함수가 사용하는 지역 변수들 (인자들을 포함합니다)의 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> 는 지역 변수들의 이름을 담고 있는 튜플입니다(인자들의 이름이 먼저 나옵니다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> 는 중첩된 함수들이 참조하는 지역 변수들의 이름을 담고 있는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> 는 자유 변수(free variables)들의 이름을 담고 있는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> 는 바이트 코드 명령 시퀀스를 나타내는 문자열입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> 는 바이트 코드가 사용하는 리터럴을 포함하는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> 는 바이트 코드가 사용하는 이름들을 담고 있는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> 은 컴파일된 코드를 제공한 파일의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> 는 함수의 첫 번째 줄 번호입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> 은 바이트 코드에서의 위치를 줄 번호로 매핑하는 법을 문자열로 인코딩한 값입니다 (자세한 내용은 인터프리터의 소스 코드를 참고하십시오); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> 는 필요한 스택의 크기입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 는 인터프리터의 여러 플래그(flag)들을 정수로 인코딩한 값입니다.</p>
<p id="index-57">다음과 같은 값들이 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 를 위해 정의되어 있습니다: 함수가 가변 개수의 위치 인자를 받아들이기 위해 사용되는 <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> 문법을 사용하면 비트 <code class="docutils literal notranslate"><span class="pre">0x04</span></code> 가 1이 됩니다; 임의의 키워드 인자를 받아들이기 위해 사용하는 <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> 문법을 사용하면 비트 <code class="docutils literal notranslate"><span class="pre">0x08</span></code> 이 1이 됩니다; 비트 <code class="docutils literal notranslate"><span class="pre">0x20</span></code> 은 함수가 제너레이터일 때 설정됩니다.</p>
<p>퓨처 기능 선언 (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) 또한 코드 객체가 특정 기능이 활성화된 상태에서 컴파일되었는지를 나타내기 위해 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 의 비트들을 사용합니다: 함수가 퓨처 division이 활성화된 상태에서 컴파일되었으면 비트 <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> 이 설정됩니다; 비트 <code class="docutils literal notranslate"><span class="pre">0x10</span></code> 과 <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> 는 예전 버전의 파이썬에서 사용되었습니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 의 다른 비트들은 내부 사용을 위해 예약되어 있습니다.</p>
<p id="index-58">만약 코드 객체가 함수를 나타낸다면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> 의 첫 번째 항목은 설명 문자열이거나 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
</dd>
</dl>
<dl id="frame-objects">
<dt>프레임 객체(Frame objects)</dt><dd><p id="index-59">프레임 객체는 실행 프레임(execution frame)을 나타냅니다. 트레이스백 객체에 등장할 수 있고 (아래를 보십시오), 등록된 추적 함수로도 전달됩니다.</p>
<p id="index-60">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> 은 이전 스택 프레임 (호출자 방향으로)을 가리키거나, 이게 스택의 바닥이라면 <code class="docutils literal notranslate"><span class="pre">None</span></code>; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> 는 이 프레임에서 실행되는 코드 객체; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> 는 지역 변수를 조회하는데 사용되는 딕셔너리; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> 는 전역 변수에 사용됩니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> 는 내장된(intrinsic) 이름들에 사용됩니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> 는 정확한 바이트 코드 명령(instruction)을 제공합니다 (코드 객체의 바이트 코드 문자열에 대한 인덱스입니다).</p>
<p id="index-61">특수 쓰기 가능 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code> 는, <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 코드 실행 중의 여러 이벤트로 인해 호출되는 함수입니다 (디버거에서 사용됩니다). 보통 이벤트는 각 새 소스 줄에서 발생합니다 - <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code>를 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>로 설정하면 이것을 비활성화할 수 있습니다.</p>
<p>구현은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code>를 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>로 설정하는 것으로 요청되는 옵코드(opcode) 당 이벤트를 허용할 수 있습니다. 추적 함수에 의해 발생 된 예외가 추적되는 함수로 빠져나오면 정의되지 않은 인터프리터 동작을 유발할 수 있음에 주의해야 합니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> 는 프레임의 현재 줄 번호입니다 --- 트레이스 함수(f_trace)에서 이 값을 쓰면 해당 줄로 점프합니다 (오직 가장 바닥 프레임에서만 가능합니다). 디버거는 f_lineno 를 쓰기 위한 점프 명령을 구현할 수 있습니다 (소위 Set Next Statement).</p>
<p>프레임 객체는 한가지 메서드를 지원합니다:</p>
<dl class="method">
<dt id="frame.clear">
<code class="sig-prename descclassname">frame.</code><code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 프레임이 잡은 지역 변수들에 대한 모든 참조를 제거합니다. 또한, 만약 프레임이 제너레이터에 속하면, 제너레이터가 종료됩니다(finalize). 이것은 프레임 객체가 관련된 참조 순환을 깨는 데 도움을 줍니다 (예를 들어, 예외를 잡아서 트레이스백을 추후 사용을 위해 저장할 때).</p>
<p>만약 프레임이 현재 실행 중이면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 예외가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

</dd>
</dl>
<dl id="traceback-objects">
<dt>트레이스백 객체(Traceback objects)</dt><dd><p id="index-62">트레이스백 객체는 예외의 스택 트레이스를 나타냅니다. 트레이스백 객체는 예외가 발생할 때 만들어지고, <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a> 를 호출해서 명시적으로 만들 수도 있습니다.</p>
<p>묵시적으로 만들어진 트레이스백의 경우, 예외 처리기를 찾아서 실행 스택을 되감을 때, 각각 되감기 단계마다 현재 트레이스백의 앞에 트레이스백 객체를 삽입합니다. 예외 처리기에 들어가면, 스택 트레이스를 프로그램이 사용할 수 있습니다. (<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 문</span></a> 섹션 참조.) <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code> 가 돌려주는 튜플의 세 번째 항목이나 잡힌 예외의 <code class="docutils literal notranslate"><span class="pre">__traceback__</span></code> 어트리뷰트로 액세스할 수 있습니다.</p>
<p>프로그램이 적절한 처리기를 제공하지 않는 경우, 스택 트레이스는 표준 에러 스트림으로 (보기 좋게 포맷되어) 출력됩니다; 만약 인터프리터가 대화형이면, <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code> 으로 사용자에게 제공합니다.</p>
<p>명시적으로 생성된 트레이스백의 경우, <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> 어트리뷰트를 어떻게 연결하여 전체 스택 트레이스를 형성해야 하는지를 결정하는 것은 트레이스백을 만드는 주체에게 달려 있습니다.</p>
<p id="index-63">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> 은 현 단계에서의 실행 프레임입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> 는 예외가 발생한 줄의 번호를 줍니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> 정확한 바이트 코드 명령을 가리킵니다. 만약 예외가 except 절이나 finally 절이 없는 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문에서 발생하면, 줄 번호와 트레이스백의 마지막 명령(last instruction)은 프레임 객체의 줄 번호와 다를 수 있습니다.</p>
<p id="index-64">특수 쓰기 가능 어트리뷰트: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> 는 스택 트레이스의 다음 단계 (예외가 발생한 프레임 방향으로)이거나 다음 단계가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>트레이스백 객체는 이제 파이썬 코드에서 명시적으로 인스턴스를 만들 수 있으며 기존 인스턴스의 <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> 어트리뷰트를 변경할 수 있습니다.</p>
</div>
</dd>
<dt>슬라이스 객체(Slice objects)</dt><dd><p id="index-65">슬라이스 객체는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드를 위한 슬라이스를 나타냅니다. 내장 함수 <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> 로 만들 수도 있습니다.</p>
<p id="index-66">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> 는 하한(lower bound) 입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 은 상한(upper bound) 입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> 은 스텝 값입니다; 각 값은 생략될 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다. 이 어트리뷰트들은 임의의 형이 될 수 있습니다.</p>
<p>슬라이스 객체는 하나의 메서드를 지원합니다.</p>
<dl class="method">
<dt id="slice.indices">
<code class="sig-prename descclassname">slice.</code><code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">length</em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 하나의 정수 인자 <em>length</em> 를 받아서 슬라이스 객체가 길이 <em>length</em> 인 시퀀스에 적용되었을 때 그 슬라이스에 대한 정보를 계산합니다. 세 개의 정수로 구성된 튜플을 돌려줍니다: 이것들은 각각 <em>start</em> 와 <em>stop</em> 인덱스와, <em>step</em> 또는 슬라이스의 스트라이드(stride) 길이입니다. 생략되었거나 범위를 벗어난 인덱스들은 일반적인 슬라이스와 같은 방법으로 다뤄집니다.</p>
</dd></dl>

</dd>
<dt>스태틱 메서드 객체(Static method objects)</dt><dd><p>스태틱 메서드 객체는 위에서 설명한 함수 객체를 메서드 객체로 변환하는 과정을 방지하는 방법을 제공합니다. 스태틱 메서드 객체는 다른 임의의 객체, 보통 사용자 정의 메서드를 둘러쌉니다. 스태틱 메서드가 클래스나 클래스 인스턴스로부터 읽힐 때 객체가 실제로 돌려주는 것은 둘러싸여 있던 객체인데, 다른 어떤 변환도 적용되지 않은 상태입니다. 둘러싸는 객체는 그렇더라도, 스태틱 메서드 객체 자체는 콜러블이 아닙니다. 스태틱 메서드 객체는 내장 <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 생성자로 만듭니다.</p>
</dd>
<dt>클래스 메서드 객체(Class method objects)</dt><dd><p>스태틱 메서드 객체처럼, 클래스 메서드 객체 역시 다른 객체를 둘러싸는데, 클래스와 클래스 인스턴스로부터 그 객체를 꺼내는 방식에 변화를 줍니다. 그런 조회에서 클래스 메서드 객체가 동작하는 방식에 대해서는 위 &quot;사용자 정의 메서드(User-defined methods)&quot; 에서 설명했습니다. 클래스 메서드 객체는 내장 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 생성자로 만듭니다.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="special-method-names">
<span id="specialnames"></span><h2><span class="section-number">3.3. </span>특수 메서드 이름들<a class="headerlink" href="#special-method-names" title="제목 주소">¶</a></h2>
<p id="index-67">클래스는 특별한 이름의 메서드들을 정의함으로써 특별한 문법 (산술 연산이나 인덱싱이나 슬라이딩 같은)에 의해 시작되는 어떤 연산들을 구현할 수 있습니다. 이것이 <em class="dfn">연산자 오버 로딩 (operator overloading)</em>에 대한 파이썬의 접근법인데, 클래스가 언어의 연산자에 대해 자기 자신의 동작을 정의할 수 있도록 합니다. 예를 들어, 클래스가 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 이라는 이름의 메서드를 정의하고, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 이 클래스의 인스턴스라면, <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> 는 대략 <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code> 와 동등합니다. 언급된 경우를 제외하고, 적절한 메서드가 정의되지 않았을 때 연산은 예외를 일으킵니다 (보통 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 나 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>특수 메서드를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하는 것은 해당 연산이 제공되지 않는다는 것을 가리킵니다. 예를 들어, 만약 클래스가 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하면, 클래스는 이터러블이 아닙니다. 따라서 이 인스턴스에 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 를 호출하면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생합니다. (<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 대안으로 시도하지 않습니다.) <a class="footnote-reference brackets" href="#id9" id="id2">2</a></p>
<p>내장형을 흉내 내는 클래스를 구현할 때, 모방은 모형화하는 객체에 말이 되는 수준까지만 구현하는 것이 중요합니다. 예를 들어, 어떤 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있습니다. 하지만 슬라이스를 꺼내는 것은 말이 안 될 수 있습니다. (이런 한가지 예는 W3C의 Document Object Model의 <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> 인터페이스입니다.)</p>
<div class="section" id="basic-customization">
<span id="customization"></span><h3><span class="section-number">3.3.1. </span>기본적인 커스터마이제이션<a class="headerlink" href="#basic-customization" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="object.__new__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__new__</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="정의 주소">¶</a></dt>
<dd><p id="index-68">클래스 <em>cls</em> 의 새 인스턴스를 만들기 위해 호출됩니다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 스태틱 메서드입니다 (그렇게 선언하지 않아도 되는 특별한 경우입니다)인데, 첫 번째 인자로 만들려고 하는 인스턴스의 클래스가 전달됩니다. 나머지 인자들은 객체 생성자 표현(클래스 호출)에 전달된 것들입니다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 의 반환 값은 새 객체 인스턴스이어야 합니다 (보통 <em>cls</em> 의 인스턴스).</p>
<p>일반적인 구현은 <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> 에 적절한 인자들을 전달하는 방법으로 슈퍼 클래스의 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 를 호출해서 새 인스턴스를 만든 후에, 돌려주기 전에 필요한 수정을 가합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>적절한 인자를 전달한다는 것은 <code class="docutils literal notranslate"><span class="pre">super().__new__()</span></code> 가 받을 수 있는 인자를 전달한다는 뜻이지,
<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 로 전달된 모든 인자를 전달한다는 뜻이 아닙니다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 를 재정의 하는
클래스는 그 성격상 아무것도 계승하고 있지 않을(즉 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 만 계승할) 가능성이 많습니다.
이 때는 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__new__()</span></code></a> 가 호출되는데, 이 메서드는 <em>cls</em> 외에는 아무것도 받지 않습니다.</p>
</div>
<p>만약 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 객체 생성 중에 호출되고, <em>cls</em>나 서브 클래스의 인스턴스를 돌려준다면, 새 인스턴스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드가 <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code> 처럼 호출되는데, <em>self</em> 는 새 인스턴스이고, 나머지 인자들은 객체 생성자로 전달된 것들과 같습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>만약 새로 인스턴스를 만들지 않고, 이미 존재하는 인스턴스를 돌려주려고 한다면, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가
두 번 호출될 수 있습니다.</p>
</div>
<p>만약 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 <em>cls</em> 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 호출되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려주면, 클래스 호출 자체의 결과가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 됩니다.
때문에 클래스만으로도 팩토리 함수처럼 동작하도록 만들 수 있습니다.</p>
</div>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 주로 불변형(int, str, tuple과 같은)의 서브 클래스가 인스턴스 생성을 커스터마이즈할 수 있도록 하는 데 사용됩니다. 또한, 사용자 정의 메타 클래스에서 클래스 생성을 커스터마이즈하기 위해 자주 사용됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>불변형은 일단 만들어진 후에는 수정할 수 없기 때문에, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 에서 커스터마이즈 하기가
곤란합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__init__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="정의 주소">¶</a></dt>
<dd><p id="index-69">(<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 호출됩니다. 인자들은 클래스 생성자 표현으로 전달된 것들입니다. 만약 베이스 클래스가 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 갖고 있다면, 서브 클래스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는, 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분이 올바르게 초기화됨을 확실히 하기 위해 명시적으로 호출해주어야 합니다; 예를 들어: <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code>.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__init__()</span></code></a> 가 정의되어 있기 때문에, 이 규칙은 사실상 모든 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>
는 항상 <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code> 를 호출해야 한다는 뜻이됩니다. 예를 들어봅시다.
세 개의 클래스가 다음과 같은 다중 계승 구조를 이루고 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B1&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B2</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B2&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">()</span>
<span class="go">D</span>
<span class="go">B1</span>
<span class="go">&lt;D object at 0x10c70ff28&gt;</span>
</pre></div>
</div>
<p>B1 과 B2 가 이 규칙을 무시하고, <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> 를 호출하지 않았습니다.
<a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__init__()</span></code></a> 는 별다른 일을 하지 않기 때문에, B1 과 B2 자체를 사용하는데는 문제를
일으키지 않습니다. 하지만 이들을 다중 계승하는 다른 클래스에서 문제가 발생합니다. 이 경우
<code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 가 호출되지 않음을 볼 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">D.__init__()</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> 대신에 <code class="docutils literal notranslate"><span class="pre">B1.__init__()</span></code> 와
<code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 를 차례대로 호출하면 되지 않겠는가 하고 생각할 수도 있지만, 이는 다른 문제를
만들게 되는데, 다음에 설명합니다. 이제 B1 과 B2 를 올바르게 구성해봅시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B1&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B2</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B2&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">()</span>
<span class="go">D</span>
<span class="go">B1</span>
<span class="go">B2</span>
<span class="go">&lt;D object at 0x10c72a2b0&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">D.__init__()</span></code> 를 바꾸지 않았는데도, <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 가 호출됨을 확인할 수 있습니다.
약간은 마술같은 일이 벌어졌는데, 모두 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 때문에 일어나는 일입니다. <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는
다음에 설명합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>다중 계승에서 발생하는 진짜 문제는 소위 다이아몬드 계승이라는 것입니다. 가령 위의 예에서 B1 과 B2 가
같은 클래스 B 를 또 계승하고 있는 것입니다. 이 때 <code class="docutils literal notranslate"><span class="pre">B.__init__()</span></code> 가 정확히 한번만 호출되어야
합니다. 예를 들어봅시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B1</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B1&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B2</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B2&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">()</span>
<span class="go">D</span>
<span class="go">B1</span>
<span class="go">B2</span>
<span class="go">B</span>
<span class="go">&lt;D object at 0x10c509208&gt;</span>
</pre></div>
</div>
<p>보시다시피, 언제나 <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> 를 한번 호출한다는 규칙을 따르는 한 문제가 발생하지
않습니다. 하지만 만약 <code class="docutils literal notranslate"><span class="pre">D.__init__()</span></code> 가 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 를 사용하지 않고, <code class="docutils literal notranslate"><span class="pre">B1.__init__()</span></code>
와 <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 를 직접호출 하면 이런일이 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">):</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">B1</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">B2</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">()</span>
<span class="go">D</span>
<span class="go">B1</span>
<span class="go">B2</span>
<span class="go">B</span>
<span class="go">B2</span>
<span class="go">B</span>
<span class="go">&lt;D object at 0x10c509160&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">B.__init__()</span></code> 뿐만 아니라 <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 도 두 번씩 호출되고 있습니다.
첫번째 <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 는 <code class="docutils literal notranslate"><span class="pre">B1.__init__()</span></code> 가 호출한 것인데 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 의 동작
원리 때문입니다. (이 역시 마술같은 일이지만, 이번에는 흑마술입니다.) 이처럼 다중 계승에서 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>
가 제공하는 메커니즘은 모든 클래스가 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 를 사용하는 경우에만 올바로 동작합니다.</p>
<p>그러면 아예 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 를 사용하지 않는다면? 그럴 경우는 <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 가 두 번 호출되지는
않겠지만, <code class="docutils literal notranslate"><span class="pre">B.__init__()</span></code> 가 두 번 호출되는 것은 피할 수 없습니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 이런 문제를 풀기 위한 특별한 메커니즘을 제공합니다. <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 다양한
방법으로 사용될 수 있지만, 지금의 경우에 국한한다면, 이런 일이 일어납니다.</p>
<p><a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 현재의 인스턴스(<code class="docutils literal notranslate"><span class="pre">self</span></code>) 의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code> 어트리뷰트를 살핍니다.
이 값은 어떤 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 실행되고 있는지에 관계 없이 (같은 <code class="docutils literal notranslate"><span class="pre">self</span></code> 가 전달되기 때문에)
같습니다. 또 한가지 살피는 것은 지금 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 를 제공하는 클래스입니다. 즉 <code class="docutils literal notranslate"><span class="pre">D.__init__()</span></code>
에서 호출되는 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">self</span></code> 와 <code class="docutils literal notranslate"><span class="pre">D</span></code> 를 파악합니다.</p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">self.__mro__</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">D</span></code> 를 검색해서 그 위치를 기억합니다. 이제 <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> 를
호출하면, 먼저 <code class="docutils literal notranslate"><span class="pre">super()</span></code> 로부터 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 라는 이름의 어트리뷰트를 요청해야하는데, <code class="docutils literal notranslate"><span class="pre">super()</span></code>
는 <code class="docutils literal notranslate"><span class="pre">self.__mro__</span></code> 에서 현재 위치 다음에 나오는 클래스들 중에서 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 를 제공하는 클래스를
찾아서 줍니다. <code class="docutils literal notranslate"><span class="pre">self.__mro__</span></code> 의 끝에는 항상 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 가 들어있기 때문에 늘
<a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__init__()</span></code></a> 로 끝납니다.</p>
<p>이 메커니즘을 잘 따져보면, 언제나 한 방향으로만 검색하기 때문에 <code class="docutils literal notranslate"><span class="pre">self.__mro__</span></code> 에 클래스가 두 번 등장하지
않는 이상, 한 클래스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 두 번 호출될 일은 없습니다.</p>
<p>보통, 클래스를 정의할 때 이 순서가 결정됩니다. 이 순서를 MRO (method resolution order) 라고 부르는데,
베이스 클래스들의 계승 순서들을 따져서, 중복되지 않고 일관성있는 순서를 결정합니다. 인스턴스나 클래스의
어트리뷰트를 검색할 때도 같은 순서에 따라 검색합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>그런데 한 가지 문제가 남아있습니다. <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> 에 어떤 인자를 전달할 것인가 하는 문제입니다.
이 것이 문제가 되는 이유는, 어떤 클래스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 호출되는지 정확히 알기 어렵기 때문입니다.
가령 위의 예에서 <code class="docutils literal notranslate"><span class="pre">B1.__init__()</span></code> 에 포함된 <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> 는 <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 를
호출하게 됩니다. 그런데 B1 을 작성하는 프로그래머는 B 에 대해서만 파악했을 뿐, B2 에 대해서는 들어본 일이
없을 수도 있습니다. B2 는 D 를 만드는 프로그래머가 새로 추가했을 수 있습니다. 그렇다면 B1 을 작성할
당시에는 <code class="docutils literal notranslate"><span class="pre">B2.__init__()</span></code> 가 어떤 인자를 필요로 하는지 알 길이 없습니다.</p>
<p>이 문제는 일관성있는 관례를 정하는 것 외에는 풀 길이 없는 문제입니다. 그 관례라 함은, 모두 같은 형식의 인자를
받아야 한다는 것입니다. 이는 설계의 문제인데, 클래스 계승 구조 전체에서 일관되게 사용될 수 있는 정책을 마련해야
합니다. 자주 사용되는 정책은, 아예 인자를 받지 않는 것과, 키워드 인자들만 받고 지원하지 않는 인자들은 모두
무시하는 것입니다. 결국 다승 계승 구조는 전체 적인 사전 설계가 필요한 작업이고, 특히 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가
정의된 클래스들을 사전 설계없이 다중 계승 구조에 병합하는 것은 문제를 일으킬 수 있습니다.</p>
</div>
<p>객체를 만드는데 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 와 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 협력하고 있으므로 (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 만들고, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 그것을 커스터마이즈합니다), <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값을 돌려주면 실행시간에 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__del__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__del__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="정의 주소">¶</a></dt>
<dd><p id="index-70">인스턴스가 파괴되기 직전에 호출됩니다. 파이널라이저 또는 (부적절하게) 파괴자라고 불립니다. 만약 베이스 클래스가 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드를 갖고 있다면, 자식 클래스의 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는, 정의되어 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분을 적절하게 삭제하기 위해, 명시적으로 베이스 클래스의 메서드를 호출해야 합니다.</p>
<p>(권장하지는 않지만!) <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는 인스턴스에 대한 새로운 참조를 만듦으로써 인스턴스의 파괴를 지연시킬 수 있습니다. 이것을 객체 <em>부활</em> 이라고 부릅니다. 부활한 객체가 파괴될 때 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 두 번째로 호출될지는 구현에 따라 다릅니다; 현재 <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> 구현은 오직 한 번만 호출합니다.</p>
<p>인터프리터가 종료할 때 아직 남아있는 객체들에 대해서는 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드의 호출이 보장되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 인스턴스의 파괴를 지연시키는 경우, CPython 3.4 이후로 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>
은 오직 한번만 호출됩니다. 파괴의 지연은 가능하지만 지연된 객체가 다시 파괴될 때는 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>
이 호출되지 않습니다. 자세한 내용은 <span class="target" id="index-71"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a> 를 참고하세요.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 인스턴스의 파괴를 지연시키는 예를 들어보자면 이렇습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X.__del__&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">x</span>
<span class="go">X.__del__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">x</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;x&#39; is not defined</span>
</pre></div>
</div>
<p>첫 번째 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">X.__del__()</span></code> 이 호출되는데, 전역 변수 <code class="docutils literal notranslate"><span class="pre">x</span></code> 에 자신을 대입하기
때문에, 참조 회수가 0 이 되지 않도록 만듭니다. 때문에 실제로는 파괴되지 않고 살아있게 됩니다.
그래서 두 번째 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 역시 정상 동작하고, 이 때 파괴가 실제로 일어나지만, <code class="docutils literal notranslate"><span class="pre">X.__del__()</span></code> 은
호출되지 않습니다. 이제 실제로 파괴되었기 때문에, 세번째 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 는 예외를 일으키게 됩니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 는 직접 <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> 를 호출하지 않습니다 --- 앞에 있는 것은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 참조 횟수(reference count)를 하나 감소시키고, 뒤에 있는 것은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 참조 횟수가 0 이 될 때 호출됩니다.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame's
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈에 대한 문서.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 호출되는 불안정한 상황 때문에, 이것이 실행 중에 발생시키는 예외는 무시되고, 대신에 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 로 경고가 출력됩니다. 특히:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 은 (임의의 스레드에서) 임의의 코드가 실행되는 동안 호출될 수 있습니다. <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 록을 얻어야 하거나 다른 블로킹 자원을 호출하면, <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 을 실행하기 위해 중단된 코드가 자원을 이미 차지했을 수 있으므로 교착 상태에 빠질 수 있습니다.</p></li>
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 은 인터프리터를 종료할 때 실행될 수 있습니다. 결과적으로, 액세스해야 하는 전역 변수(다른 모듈 포함)가 이미 삭제되었거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되었을 수 있습니다. 파이썬은 이름이 하나의 밑줄로 시작하는 전역 객체가 다른 전역 객체들보다 먼저 삭제됨을 보장합니다; 이것은, 만약 그 전역 객체들에 대한 다른 참조가 존재하지 않는다면, <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드가 호출되는 시점에, 임포트된 모듈들이 남아있도록 확실히 하는 데 도움이 될 수 있습니다.</p></li>
</ul>
</div>
<span class="target" id="index-72"></span></dd></dl>

<dl class="method">
<dt id="object.__repr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 내장 함수에 의해 호출되어 객체의 &quot;형식적인(official)&quot; 문자열 표현을 계산합니다. 만약 가능하다면, 이것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 수 있는 올바른 파이썬 표현식처럼 보여야 합니다. 가능하지 않다면, <code class="docutils literal notranslate"><span class="pre">&lt;...쓸모있는</span> <span class="pre">설명...&gt;</span></code> 형태의 문자열을 돌려줘야 합니다. 반환 값은 반드시 문자열이어야 합니다. 만약 클래스가 <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 없이 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 만 정의한다면, <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 은 그 클래스 인스턴스의 &quot;비형식적인(informal)&quot; 문자열 표현이 요구될 때 사용될 수 있습니다.</p>
<p>이것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않게 하는 것이 중요합니다.</p>
<span class="target" id="index-73"></span></dd></dl>

<dl class="method">
<dt id="object.__str__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> 와 내장 함수 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 에 의해 호출되어 객체의 &quot;비형식적인(informal)&quot; 또는 보기 좋게 인쇄 가능한 문자열 표현을 계산합니다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">문자열</span></a> 객체여야 합니다.</p>
<p>이 메서드는 <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 점에서 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 과 다릅니다: 더 편리하고 간결한 표현이 사용될 수 있습니다.</p>
<p>내장형 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 에 정의된 기본 구현은 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 을 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__bytes__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="정의 주소">¶</a></dt>
<dd><p id="index-74"><a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 에 의해 호출되어 객체의 바이트열 표현을 계산합니다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체여야 합니다.</p>
<span class="target" id="index-75"></span></dd></dl>

<dl class="method">
<dt id="object.__format__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__format__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">format_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 내장 함수, 확대하면, <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴(formatted string literals)</span></a> 의 계산과 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 메서드에 의해 호출되어, 객체의 &quot;포맷된&quot; 문자열 표현을 만들어냅니다. <em>format_spec</em> 인자는 요구되는 포맷 옵션들을 포함하는 문자열입니다. <em>format_spec</em> 인자의 해석은 <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 을 구현하는 형에 달려있으나, 대부분 클래스는 포매팅을 내향형들의 하나로 위임하거나, 비슷한 포맷 옵션 문법을 사용합니다.</p>
<p>표준 포매팅 문법에 대해서는 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">포맷 명세 미니 언어</span></a> 를 참고하면 됩니다.</p>
<p>반환 값은 반드시 문자열이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">object</span></code> 의 __format__ 메서드 자신은, 빈 문자열이 아닌 인자가 전달되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 <code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">format(str(self),</span> <span class="pre">'')</span></code> 가 아니라 <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> 와 동등합니다.</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="method">
<dt id="object.__lt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lt__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="정의 주소">¶</a></dt>
<dt id="object.__le__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__le__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="정의 주소">¶</a></dt>
<dt id="object.__eq__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="정의 주소">¶</a></dt>
<dt id="object.__ne__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="정의 주소">¶</a></dt>
<dt id="object.__gt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__gt__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="정의 주소">¶</a></dt>
<dt id="object.__ge__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ge__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="정의 주소">¶</a></dt>
<dd><p id="index-76">이것들은 소위 &quot;풍부한 비교(rich comparison)&quot; 메서드입니다. 연산자 기호와 메서드 이름 간의 관계는 다음과 같습니다: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code> 를 호출합니다.</p>
<p>풍부한 비교 메서드는 주어진 한 쌍의 인자에게 해당 연산을 구현하지 않는 경우 단일자(singleton) <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줄 수 있습니다. 관례상, 성공적인 비교면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려줍니다. 하지만, 이 메서드는 어떤 형의 값이건 돌려줄 수 있습니다, 그래서 비교 연산자가 논리 문맥(Boolean context) (예를 들어 <code class="docutils literal notranslate"><span class="pre">if</span></code> 문의 조건)에서 사용되면, 파이썬은 결과의 참 거짓을 파악하기 위해 값에 대해 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> 을 호출합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 메서드가 어떤 형의 값이건 돌려줄 수 있도록 한 애초의 이유는, 벡터나 행렬과 같은 것들을 다루는 확장
모듈들을 지원하기 위해서입니다. 이런 모듈들에서 벡터간의 비교는 역시 항목들간의 비교값으로 구성된 벡터를
만들어냅니다. 하지만 이런 이런 용도로만 제한되지는 않습니다.</p>
</div>
<p>기본적으로, <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 는 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 호출한 후 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 가 아니라면 그 결과를 뒤집습니다. 비교 연산자 간의 다른 암시적인 관계는 없습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> 가 참이라고 해서 <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 가 참일 필요는 없습니다. 하나의 기본 연산으로부터 대소관계 연산을 자동으로 만들어내려면 <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a> 를 보면 됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 를 구현하지 않아도 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 만 구현되어 있으면 <code class="docutils literal notranslate"><span class="pre">x==y</span></code> 뿐만 아니라
<code class="docutils literal notranslate"><span class="pre">x!=y</span></code> 역시 자동 지원되고, 그 값은 <code class="docutils literal notranslate"><span class="pre">!(x==y)</span></code> 가 된다는 뜻입니다. <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 를 직접
구현한다면, 이 관계가 꼭 성립할 필요는 없습니다.</p>
<p>하지만 그 반대는 지원하지 않습니다. <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지 않고, <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 만 정의하는
경우, 여전히 <code class="docutils literal notranslate"><span class="pre">x==y</span></code> 가 지원되지만, 이 경우는 두 객체의 아이덴티티를 비교하는 기본 구현이 사용되는
것이지, <code class="docutils literal notranslate"><span class="pre">!(x!=y)</span></code> 로 변환된 것이 아닙니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a> 은 데코레이터로 사용되는데, 클래스에 이 데코레이터를 적용하면
<a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a>, <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 중에서 새로 정의한 것
하나를 골라 기본 연산으로 삼고, 빠진 것들을 기본 연산과 <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <a class="reference internal" href="expressions.html#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a>,
<a class="reference internal" href="expressions.html#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a>, <a class="reference internal" href="expressions.html#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> 를 사용한 구현들로 채워넣습니다.</p>
<p>일반적으로 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 만 정의합니다. 이 때 객체들의 모든 값은 일관성있게
대소 비교(totally ordered)가 가능하게 됩니다. <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a> 이
<a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 나 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 를 만들지는 않습니다.</p>
</div>
<p>사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 객체를 만드는 것에 관한 몇 가지 중요한 내용이 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 에 관한 문단에 나옵니다.</p>
<p>이 메서드들에 대한 (왼편의 인자는 연산을 지원하지 않지만, 오른편 인자가 지원할 때 사용되는) 뒤집힌 버전은 따로 없습니다; 대신에 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 와 <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 는 서로의 뒤집힌 연산입니다; <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> 와 <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 는 서로의 뒤집힌 연산입니다; <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 는 서로의 뒤집힌 연산입니다; 만약 피연산자가 서로 다른 형이고, 오른편 피연산자의 형이 왼편 피연산자의 형의 직간접적인 서브 클래스면, 오른편 피연산자의 뒤집힌 버전이 우선순위가 높습니다; 그렇지 않으면 왼편 피연산자의 메서드가 우선순위가 높습니다. 가상 서브클래싱(virtual subclassing)은 고려되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>두 피연산자 중 어느 하나의 형이 다른 하나의 형과 서브 클래스 관계에 있으면, 서브 클래스 쪽이 우선권을
가져서, 처음 부터 뒤집힌 연산이 먼저 시도된다는 뜻입니다.</p>
<p>이 규칙은 뒤집힌 버전이 따로 제공되는 산술 연산자에서도 적용됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>가상 서브클래싱(virtual subclassing) 이란, 소위 추상 베이스 클래스(ABC - Abstract Base
Class)에서 사용되는 것인데, 클래스 정의에서 베이스 클래스를 정의하는 대신, ABC 의
<a class="reference internal" href="../library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abc.ABCMeta.register()</span></code></a> 메서드를 사용해서 계승 관계를 정의해 주는 것을 뜻합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__hash__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="정의 주소">¶</a></dt>
<dd><p id="index-77">내장 함수 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 와 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 와 같은 해시형 컬렉션의 멤버에 대한 연산에서 호출됩니다. <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 는 정수를 돌려줘야 합니다. 같다고 비교되는 객체들이 같은 해시값을 가져야 한다는 성질만 요구됩니다. 객체의 비교에 사용되는 요소들로 튜플을 구성하고, 그 튜플의 해시값을 취함으로써 요소들의 해시값을 섞는 것을 권합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 는 객체가 정의한 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 돌려주는 값을 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> 의 크기로 자릅니다(truncate). 이것은 보통 64-bit 빌드에서는 8바이트고, 32-bit 빌드에서는 4바이트입니다. 만약 객체의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 서로 다른 비트 크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 빌드들에서의 폭을 검사해야 합니다. 이렇게 하는 쉬운 방법은 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code> 입니다.</p>
</div>
<p>만약 클래스가 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지 않으면 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 역시 정의하지 말아야 합니다. 만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지만 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는다면, 그것의 인스턴스는 해시 가능 컬렉션에서 사용될 수 없습니다. 만약 클래스가 가변형 객체를 정의하고 있고 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 구현한다면, <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 구현하지 말아야 하는데, 해시 가능 컬렉션들의 구현이 키의 해시값이 불변이도록 요구하고 있기 때문입니다(만약 객체의 해시값이 변하면, 잘못된 해시 버킷(hash bucket)에 있게 됩니다).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>두 객체가 같다고 비교될 경우 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 역시 같은 값을 주어야 한다는 조건과, 해시형
컬렉션들이 요구하는 키의 해시값이 불변이라는 조건을 합치면, 일단 해시형 컬렉션에서 키로 사용되기
위해서는 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 기준으로 불변이어야 한다는 뜻이됩니다. 이 때문에 가변형 객체에서
<a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하는 경우, <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 말라고 하는 것입니다.
일단 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 가 정의되면 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 의 기본 구현이 제거되기 때문에,
해시형 컬렉션에서 사용할 수 없는 상태가 됩니다.</p>
</div>
<p>사용자 정의 클래스는 기본적으로 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 갖습니다; 모든 객체는 (자기 자신을 제외하고) 같지 않다고 비교되고, <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> 는 적절한 값을 돌려주어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 일 때 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> 가 동시에 성립할 수 있도록 합니다.</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하고 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는 클래스는 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정됩니다. 클래스의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 클래스의 인스턴스는 프로그램이 해시값을 얻으려 시도할 때 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키고, <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 로 검사할 때 해시 가능하지 않다고 올바로 감지됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하고 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는 클래스에 대해
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하는 것은, 개별 클래스 정의마다 일어나는 일입니다.
부모 클래스의 정의가 어떠한지는 상관없습니다. <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지 않으면
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 는 부모클래스로 부터 계승됩니다.</p>
</div>
<p>만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하는 클래스가 부모 클래스로부터 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 의 구현을 물려받고 싶으면 인터프리터에게 명시적으로 이렇게 지정해주어야 합니다: <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code>.</p>
<p>만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 을 포함해야 합니다. 자신의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 을 정의한 후에 직접 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키는 경우는 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 호출이 해시 가능하다고 잘못 인식합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>기본적으로, str과 bytes 객체들의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 값은 예측할 수 없는 난수값으로 &quot;솔트되어(salted)&quot; 있습니다. 개별 파이썬 프로세스 내에서는 변하지 않는 값으로 유지되지만, 파이썬을 반복적으로 실행할 때는 예측할 수 없게 됩니다.</p>
<p>이것은 dict 삽입의 최악의 경우 성능(worst case performance), O(n^2) 복잡도, 을 활용하기 위해 주의 깊게 선택한 입력에 의한 서비스 거부(denial-of-service) 공격에 대한 방어를 제공하기 위한 목적입니다. 자세한 내용은 <a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> 에 있습니다.</p>
<p>해시값의 변경은 집합의 이터레이션 순서에 영향을 줍니다, 파이썬은 이 순서에 대해 어떤 보장도 하지 않습니다 (그리고 보통 32-bit 와 64-bit 빌드 사이에서도 다릅니다).</p>
<p><span class="target" id="index-118"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 를 참고하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>해시 난수 화는 기본적으로 활성화됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__bool__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="정의 주소">¶</a></dt>
<dd><p id="index-79">논리값 검사와 내장 연산 <code class="docutils literal notranslate"><span class="pre">bool()</span></code> 구현을 위해 호출됩니다; <code class="docutils literal notranslate"><span class="pre">False</span></code> 나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려줘야 합니다. 이 메서드가 정의되지 않는 경우, 정의되어 있다면 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 이 호출되어, 값이 0 이 아니면 참으로 인식합니다. 만약 클래스가 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 모두 정의하지 않는다면, 모든 인스턴스는 참으로 취급됩니다.</p>
</dd></dl>

</div>
<div class="section" id="customizing-attribute-access">
<span id="attribute-access"></span><h3><span class="section-number">3.3.2. </span>어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="#customizing-attribute-access" title="제목 주소">¶</a></h3>
<p>클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, <code class="docutils literal notranslate"><span class="pre">x.name</span></code> 을 삭제하기)의 의미를 변경하기 위해 다음과 같은 메서드들이 정의될 수 있습니다.</p>
<dl class="method">
<dt id="object.__getattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattr__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="정의 주소">¶</a></dt>
<dd><p>기본 어트리뷰트 액세스가 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 로 실패할 때 호출됩니다 (<em>name</em> 이 인스턴스 어트리뷰트 또는 <code class="docutils literal notranslate"><span class="pre">self</span></code> 의 클래스 트리에 있는 어트리뷰트가 아니라서 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키거나; <em>name</em> 프로퍼티의 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 이 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으킬 때). 이 메서드는 (계산된) 어트리뷰트 값을 반환하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다.</p>
<p>일반적인 메커니즘을 통해 어트리뷰트가 발견되면 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 이 호출되지 않음에 주의해야 합니다 (이것은 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 과 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 간의 의도된 비대칭입니다). 이렇게 하는 이유는 효율 때문이기도 하고, 그렇게 하지 않으면 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 때문이기도 합니다. 적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그것들을 다른 객체에 넣습니다) 완전한 제어인 것처럼 조작할 수 있습니다. 어트리뷰트 액세스를 실제로 완전히 조작하는 방법에 대해서는 아래에 나오는 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 에서 다룹니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이미 존재하는 어트리뷰트의 경우, 대입할 때는 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 가 호출되는데, 읽을 때는
<a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 가 호출되지 않습니다.</p>
<p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 가 기능을 구현할 때는 다른 어트리뷰트를 대입하지 않고도 가능합니다.
가령 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 는 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 에 직접 값을 넣을 수 있는데,
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 의 내용을 바꾸는 것일뿐, <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 라는 어트리뷰트 자체를 변경하는
것은 아닙니다. 이 때문에 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 이 다시 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 을 재귀적으로
호출하는 의도하지 않은 상황을 피할 수 있습니다.</p>
<p>하지만 어트리뷰트를 읽지 않고 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 을 구현하는 것은, 특별한 경우라면 모를까
일반적으로 가능한 일은 아닙니다. 물론 예외 규칙을 도입하면 됩니다. 그 가장 간단한 예외 규칙 하나가,
이미 있는 어트리뷰트에 대해서는 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 를 호출하지 않는다는 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__getattribute__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattribute__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="정의 주소">¶</a></dt>
<dd><p>클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건 없이 호출됩니다. 만약 클래스가 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 도 함께 구현하면, <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 명시적으로 호출하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키지 않는 이상 <cite>__getattr__</cite> 는 호출되지 않습니다. 이 메서드는 어트리뷰트의 (계산된) 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다. 이 메서드에서 무한 재귀(infinite recursion)가 발생하는 것을 막기 위해, 구현은 언제나 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>언어 문법이나 내장 함수에 의한 묵시적인 호출이 결과로 특수 메서드를 참조하는 경우에는 이 메서드를 거치지 않을 수 있습니다. 자세한 내용은 <a class="reference internal" href="#special-lookup"><span class="std std-ref">특수 메서드 조회</span></a> 에서 다룹니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트 대입이 시도될 때 호출됩니다. 일반적인 메커니즘(즉 인스턴스 딕셔너리에 값을 저장하는 것) 대신에 이것이 호출됩니다. <em>name</em> 은 어트리뷰트 이름이고, <em>value</em> 는 그것에 대입하려는 값입니다.</p>
<p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 에서 인스턴스 어트리뷰트에 대입하려고 할 때는, 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code></p>
</dd></dl>

<dl class="method">
<dt id="object.__delattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delattr__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> 이 객체에 의미가 있는 경우에만 구현되어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__dir__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="정의 주소">¶</a></dt>
<dd><p>객체에 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 이 호출될 때 호출됩니다. 시퀀스를 돌려줘야 합니다. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 은 돌려준 시퀀스를 리스트로 변환한 후 정렬합니다.</p>
</dd></dl>

<div class="section" id="customizing-module-attribute-access">
<h4><span class="section-number">3.3.2.1. </span>모듈 어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="#customizing-module-attribute-access" title="제목 주소">¶</a></h4>
<p id="index-80">특수한 이름 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 는 모듈 어트리뷰트에 대한 접근을 사용자 정의하는 데 사용될 수도 있습니다. 모듈 수준의 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 함수는 하나의 인자로 어트리뷰트의 이름을 받아서 계산된 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 발생시켜야 합니다. 일반적인 조회(즉 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>)를 통해 어트리뷰트가 모듈 객체에서 발견되지 않으면, <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키기 전에 모듈 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 을 검색합니다. 발견되면, 어트리뷰트 이름으로 그 함수를 호출하고 결과를 돌려줍니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 함수는 인자를 받지 않고 모듈에서 접근 할 수 있는 이름을 나타내는 문자열의 시퀀스를 돌려줘야 합니다. 존재하면, 이 함수는 모듈에 대한 표준 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 검색을 재정의합니다.</p>
<p>모듈 동작(어트리뷰트 설정, 프로퍼티 등)을 보다 세밀하게 사용자 정의하려면, 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 어트리뷰트를 <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> 의 서브 클래스로 설정할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;Verbose </span><span class="si">{self.__name__}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Setting </span><span class="si">{attr}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>모듈 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 정의와 모듈 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 설정은 어트리뷰트 액세스 구문을 사용하는 조회에만 영향을 미칩니다 -- 모듈 전역에 대한 직접적인 액세스(모듈 내의 코드에 의한 액세스이거나 모듈의 전역 딕셔너리에 대한 참조를 거치거나)는 영향받지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 모듈 어트리뷰트가 쓰기 가능합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 모듈 어트리뷰트.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-119"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0562"><strong>PEP 562</strong></a> - 모듈 __getattr__ 과 __dir__</dt><dd><p>모듈에 대한 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 함수를 설명합니다.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="implementing-descriptors">
<span id="descriptors"></span><h4><span class="section-number">3.3.2.2. </span>디스크립터 구현하기<a class="headerlink" href="#implementing-descriptors" title="제목 주소">¶</a></h4>
<p>다음에 오는 메서드들은 메서드를 가진 클래스(소위 <em>디스크립터(descriptor)</em> 클래스)의 인스턴스가 <em>소유자(owner)</em> 클래스에 등장할 때만 적용됩니다(디스크립터는 소유자 클래스의 딕셔너리나 그 부모 클래스 중 하나의 딕셔너리에 있어야 합니다). 아래의 예에서, &quot;어트리뷰트&quot; 는 이름이 소유자 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 의 키로 사용되고 있는 어트리뷰트를 가리킵니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이런 상황을 뜻합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Descriptor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="o">...</span>

<span class="k">class</span> <span class="nc">Owner</span><span class="p">:</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">()</span>

<span class="n">instance</span> <span class="o">=</span> <span class="n">Owner</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Descriptor</span></code> 를 디스크립터 클래스라고 부르고, <code class="docutils literal notranslate"><span class="pre">Owner</span></code> 를 소유자 클래스라고 부릅니다.
디스크립터 클래스의 인스턴스가 소유자 클래스의 클래스 어트리뷰트로 들어간다는 것이 중요합니다.
이럴 때 <code class="docutils literal notranslate"><span class="pre">Owner.attribute</span></code> 나 <code class="docutils literal notranslate"><span class="pre">instance.attribute</span></code> 표현식을 계산하려고 하면
<code class="docutils literal notranslate"><span class="pre">Descriptor.__get__()</span></code> 이 끼어들게 됩니다.</p>
</div>
<dl class="method">
<dt id="object.__get__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__get__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em>, <em class="sig-param">owner=None</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 어트리뷰트를 취하려고 할 때 호출됩니다. 선택적 <em>owner</em> 인자는 소유자 클래스입니다. 반면에 <em>instance</em> 는 어트리뷰트 참조가 일어나고 있는 인스턴스이거나, 어트리뷰트가 <em>owner</em> 를 통해 액세스 되는 경우 <cite>None</cite> 입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>위의 예에서 <code class="docutils literal notranslate"><span class="pre">instance.attribute</span></code> 는 <code class="docutils literal notranslate"><span class="pre">Descriptor.__get__(self,</span> <span class="pre">instance,</span> <span class="pre">Owner)</span></code>
가 호출되도록 하고, <code class="docutils literal notranslate"><span class="pre">Owner.attribute</span></code> 는 <code class="docutils literal notranslate"><span class="pre">Descriptor.__get__(self,</span> <span class="pre">None,</span> <span class="pre">Owner)</span></code>
이 호출되도록 한다는 뜻입니다. <code class="docutils literal notranslate"><span class="pre">self</span></code> 로는 <code class="docutils literal notranslate"><span class="pre">Owner.__dict__['attribute']</span></code> 가 전달됩니다.</p>
</div>
<p>이 메서드는 계산된 어트리뷰트 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다.</p>
<p><span class="target" id="index-120"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a>는 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>이 하나나 두 개의 인자를 갖는 콜러블이라고 지정합니다. 파이썬 자신의 내장 디스크립터는 이 명세를 지원합니다; 그러나, 일부 제삼자 도구에는 두 인수를 모두 요구하는 디스크립터가 있을 수 있습니다. 파이썬 자신의 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 구현은 필요한지와 관계없이 항상 두 인자를 모두 전달합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__set__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 새 값 <em>value</em> 로 설정할 때 호출됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>위의 예에서 <code class="docutils literal notranslate"><span class="pre">instance.attribute</span> <span class="pre">=</span> <span class="pre">value</span></code> 하는 경우입니다. <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 과 달리
클래스 어트리뷰트의 대입 <code class="docutils literal notranslate"><span class="pre">Owner.attribute</span> <span class="pre">=</span> <span class="pre">value</span></code> 는 디스크립터를 호출하지 않습니다.</p>
</div>
<p><a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>이나 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>를 추가하면 디스크립터 유형이 &quot;데이터 디스크립터(data descriptor)&quot;로 변경됨에 유의하십시오. 자세한 내용은 <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">디스크립터 호출하기</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delete__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delete__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 삭제할 때 호출됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>위의 예에서 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">instance.attribute</span></code> 하는 경우입니다. <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 과 달리 클래스
어트리뷰트의 삭제 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">Owner.attribute</span></code> 는 디스크립터를 호출하지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__set_name__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set_name__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">owner</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스 <em>owner</em> 가 만들어질 때 호출됩니다. 이 디스크립터가 <em>name</em> 에 대입되었습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>위의 예에서, <code class="docutils literal notranslate"><span class="pre">Owner</span></code> 클래스가 정의될 때,
<code class="docutils literal notranslate"><span class="pre">Descriptor.__set_name__(self,</span> <span class="pre">Owner,</span> <span class="pre">'attribute')</span></code> 가 호출됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>디스크립터는 자신이 어떤 이름의 클래스 어트리뷰트로 등록되었는지를 알면 유용한 경우가 많습니다. 가령
디스크립터는 데이터베이스 ORM 에서 컬럼을 표현할 때 자주 사용되는데, 자신이 어떤 이름의 컬럼에 매핑되어
있는지 알아야, 자신이 테이블의 어떤 컬럼에 매핑되는지 파악할 수 있습니다. 3.6 이전의 버전에서는 이 메서드가
제공되지 않았기 때문에 좀 더 복잡한 다른 방법(가령 메타클래스)으로 이 이름을 알아내곤 했습니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a>은 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 생성자의 일부로 묵시적으로만 호출되므로, 초기 생성 이후에 디스크립터가 클래스에 추가될 때 적절한 매개 변수로 명시적으로 호출할 필요가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>
<span class="n">descr</span> <span class="o">=</span> <span class="n">custom_descriptor</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">descr</span>
<span class="n">descr</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;attr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="#class-object-creation"><span class="std std-ref">클래스 객체 만들기</span></a> 을 참고하십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<p>어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> 는 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈에 의해 이 객체가 정의된 클래스를 지정하는 것으로 해석됩니다(이 값을 적절히 설정하면 동적인 클래스 어트리뷰트의 실행시간 인트로스펙션(introspection)을 지원할 수 있습니다). 콜러블의 경우, 첫 번째 위치 인자에, 주어진 형(또는 서브 클래스)의 인스턴스가 기대되거나 요구됨을 가리킬 수 있습니다(예를 들어, CPython 은 C로 구현된 연결되지 않은 메서드(unbound method)에 이 어트리뷰트를 설정합니다).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>디스크립터 메서드의 경우 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> 를 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈이 조사하기는
하지만, 그리 쓸모있는 역할을 하고 있지는 못합니다.</p>
</div>
</div>
<div class="section" id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4><span class="section-number">3.3.2.3. </span>디스크립터 호출하기<a class="headerlink" href="#invoking-descriptors" title="제목 주소">¶</a></h4>
<p>일반적으로, 디스크립터는 &quot;결합한 동작(binding behavior)&quot;을 가진 객체 어트리뷰트입니다. 어트리뷰트 액세스가 디스크립터 프로토콜(descriptor protocol)의 메서드들에 의해 재정의됩니다: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. 이 메서드들 중 하나라도 정의되어 있으면, 디스크립터라고 부릅니다.</p>
<p>어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것입니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code> 에서 시작해서 <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> 를 거쳐 <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> 의 메타 클래스를 제외한 베이스 클래스들을 거쳐 가는 일련의 조회로 구성됩니다.</p>
<p>그러나, 만약 조회한 값이 디스크립터 메서드를 구현한 객체면, 파이썬은 기본 동작 대신에 디스크립터 메서드를 호출할 수 있습니다. 우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 메서드가 정의되어 있고 어떤 식으로 호출되는지에 따라 다릅니다.</p>
<p>디스크립터 호출의 시작점은 결합(binding)입니다, <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. 어떻게 인자들이 조합되는지는 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에 따라 다릅니다:</p>
<dl class="simple">
<dt>직접 호출</dt><dd><p>가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메서드를 직접 호출할 때입니다: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code></p>
</dd>
<dt>인스턴스 결합</dt><dd><p>객체 인스턴스에 결합하면, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 이런 호출로 변환됩니다: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt>클래스 결합</dt><dd><p>클래스에 결합하면, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> 는 이런 호출로 변환됩니다: <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt>Super 결합</dt><dd><p><a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code></a> 의 인스턴스에 결합하면, 결합 <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> 은 <code class="docutils literal notranslate"><span class="pre">obj.__class__.__mro__</span></code> 를 검색해서 <code class="docutils literal notranslate"><span class="pre">B</span></code> 바로 다음에 나오는 베이스 클래스 <code class="docutils literal notranslate"><span class="pre">A</span></code> 를 찾은 후에 이렇게 디스크립터를 호출합니다: <code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code>.</p>
</dd>
</dl>
<p>인스턴스 결합의 경우, 디스크립터 호출의 우선순위는 어떤 디스크립터 메서드가 정의되어있는지에 따라 다릅니다. 디스크립터는 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> 를 어떤 조합으로도 정의할 수 있습니다. 만약 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 를 정의하지 않는다면, 어트리뷰트 액세스는, 객체의 인스턴스 딕셔너리에 값이 있지 않은 이상 디스크립터 객체 자신을 돌려줍니다. 만약 디스크립터가 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 이나 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> 중 어느 하나나 둘 다 정의하면, 데이터 디스크립터(data descriptor)입니다. 둘 다 정의하지 않는다면 비데이터 디스크립터(non-data descriptor)입니다. 보통, 데이터 디스크립터가 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 과 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 을 모두 정의하는 반면, 비데이터 디스크립터는 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 메서드만 정의합니다. <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 과 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 이 있는 데이터 디스크립터는 인스턴스 딕셔너리에 있는 값에 우선합니다. 반면에 비데이터 디스크립터는 인스턴스보다 우선순위가 낮습니다.</p>
<p>파이썬 메서드 (<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 를 포함해서) 는 비데이터 디스크립터로 구현됩니다. 이 때문에, 인스턴스는 메서드를 새로 정의하거나 덮어쓸 수 있습니다. 이것은 개별 인스턴스가 같은 클래스의 다른 인스턴스들과는 다른 동작을 얻을 수 있도록 만듭니다.</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 함수는 데이터 디스크립터로 구현됩니다. 이 때문에, 인스턴스는 프로퍼티(property)의 동작을 변경할 수 없습니다.</p>
</div>
<div class="section" id="slots">
<span id="id3"></span><h4><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="#slots" title="제목 주소">¶</a></h4>
<p><em>__slots__</em> 은 (프로퍼티처럼) 데이터 멤버를 명시적으로 선언하고 (<em>__slots__</em> 에 명시적으로 선언하거나 부모로부터 물려받지 않는 한) <em>__dict__</em> 와 <em>__weakref__</em> 생성을 거부할 수 있도록 합니다.</p>
<p><em>__dict__</em> 를 사용할 때에 비교해 절약되는 공간은 상당할 수 있습니다. 어트리뷰트 조회 속도도 크게 개선할 수 있습니다.</p>
<dl class="data">
<dt id="object.__slots__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="정의 주소">¶</a></dt>
<dd><p>이 클래스 변수에는 인스턴스에 의해 사용되는 변수들의 이름을 제공하는 문자열, 이터러블(iterable), 문자열의 시퀀스가 대입될 수 있습니다. <em>__slots__</em> 은 선언된 변수들을 위한 공간을 예약하고, 간 인스턴스마다 <em>__dict__</em> 와 <em>__weakref__</em> 가 만들어지는 것을 막습니다.</p>
</dd></dl>

<div class="section" id="notes-on-using-slots">
<h5><span class="section-number">3.3.2.4.1. </span><em>__slots__</em> 사용에 관한 노트<a class="headerlink" href="#notes-on-using-slots" title="제목 주소">¶</a></h5>
<ul>
<li><p><em>__slots__</em> 가 없는 클래스를 계승할 때, 인스턴스의 <em>__dict__</em> 와 <em>__weakref__</em> 어트리뷰트는 항상 제공됩니다.</p></li>
<li><p><em>__dict__</em> 변수가 없으므로 인스턴스는 <em>__slots__</em> 정의에 나열되지 않은 새 변수를 대입할 수 없습니다. 나열되지 않은 변수명으로 대입하려고 하면 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으킵니다. 만약 동적으로 새 변수를 대입하는 것이 필요하다면, <em>__slots__</em> 선언의 문자열 시퀀스에 <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> 를 추가합니다.</p></li>
<li><p>인스턴스마다 <em>__weakref__</em> 변수가 없으므로, <em>__slots__</em> 를 정의하는 클래스는 인스턴스에 대한 약한 참조(weak reference)를 지원하지 않습니다. 만약 약한 참조 지원이 필요하다면, <em>__slots__</em> 선언의 문자열 시퀀스에 <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> 를 추가합니다.</p></li>
<li><p><em>__slots__</em> 는 각 변수 이름마다 디스크립터를 만드는 방식으로 클래스 수준에서 구현됩니다(<a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a>). 결과적으로, 클래스 어트리뷰트는 <em>__slots__</em> 로 정의된 인스턴스 변수들을 위한 기본값을 제공할 목적으로 사용될 수 없습니다. 클래스 어트리뷰트는 디스크립터 대입을 무효로 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>클래스 정의에서 <em>__slots__</em> 로 정의된 인스턴스 변수와 같은 이름의 클래스 어트리뷰트를 제공하면
예외를 일으킵니다. 하지만 클래스 어트리뷰트는 클래스 정의 밖에서도 제공할 수 있는데, 이 때
디스크립터가 제거되게 됩니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 선언은 되었으나, self.value 에 아직 값이 대입되지 않았습니다.</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 클래스 어트리뷰트는 디스크립터입니다.</span>
<span class="go">&lt;member &#39;value&#39; of &#39;X&#39; objects&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># 값을 대입할 수는 있습니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 이제 예외가 발생하지 않습니다.</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 기본 값으로 사용되도록 클래스 어트리뷰트를 설정하려고 하지만, 결과적으로 디스크립터를 제거하게됩니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 디스크립터가 제거되어, 아까 설정한 값도 읽을 수 없게됩니다.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># 값을 다시 대입할 수도 없게됩니다.</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;X&#39; object attribute &#39;value&#39; is read-only</span>
</pre></div>
</div>
</div>
</li>
<li><p><em>__slots__</em> 선언으로 인한 효과는 그것이 정의된 클래스로 한정되지 않습니다. 부모가 선언한 <em>__slots__</em> 은 자식 클래스에 제공됩니다. 하지만, 자식 서브 클래스가 자신의 <em>__slots__</em> (새로 <em>추가되는</em> 변수들만 포함해야 합니다) 을 정의하지 않는다면 <em>__dict__</em> 와 <em>__weakref__</em> 를 갖게 됩니다.</p></li>
<li><p>클래스가 베이스 클래스의 <em>__slots__</em> 에 정의된 이름과 같은 이름의 변수를 <em>__slots__</em> 에 선언한다면, 베이스 클래스가 정의한 변수는 액세스할 수 없는 상태가 됩니다(베이스 클래스로부터 디스크립터를 직접 조회하는 경우는 예외다). 이것은 프로그램을 정의되지 않은 상태로 보내게 됩니다. 미래에는, 이를 방지하기 위한 검사가 추가될 것입니다.</p></li>
<li><p><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>과 같은 &quot;가변 길이(valiable-length)&quot; 의 내장형들을 계승하는 클래스에서는 오직 빈 <em>__slots__</em> 만 지원됩니다.</p></li>
<li><p><em>__slots__</em> 에는 문자열 이외의 이터러블을 대입할 수 있습니다. 매핑도 역시 사용할 수 있습니다. 하지만, 미래에, 각 키에 대응하는 값들의 의미가 부여될 수 있습니다.</p></li>
<li><p>두 클래스가 같은 <em>__slots__</em> 을 갖는 경우만 <em>__class__</em> 대입이 동작합니다.</p></li>
<li><p>슬롯을 사용하는 여러 부모 클래스들을 다중 상속할 수 있지만, 오직 하나의 부모만 슬롯으로 만들어진 어트리뷰트를 가질 수 있습니다 (다른 베이스들은 빈 슬롯을 가져야만 합니다) - 이를 어기면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p></li>
<li><p>이터레이터가 <em>__slots__</em>에 사용되면 각 이터레이터의 값에 대해 디스크립터가 만들어집니다. 그러나, <em>__slots__</em> 어트리뷰트는 빈 이터레이터가 됩니다.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="customizing-class-creation">
<span id="class-customization"></span><h3><span class="section-number">3.3.3. </span>클래스 생성 커스터마이제이션<a class="headerlink" href="#customizing-class-creation" title="제목 주소">¶</a></h3>
<p>클래스가 다른 클래스를 상속할 때, 그 클래스의 <em>__init_subclass__</em> 가 호출됩니다. 이 방법으로, 서브 클래스의 동작을 변경하는 클래스를 쓰는 것이 가능합니다. 이런 용도는 클래스 데코레이터와도 밀접히 관련되어 있습니다. 하지만 클래스 데코레이터는 그들을 사용하는 특정한 클래스에만 작용하지만, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 단독으로 그 메서드를 정의하는 클래스의 미래 서브 클래스 모두에게 작용합니다.</p>
<dl class="method">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init_subclass__</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 포함하는 클래스의 서브 클래스가 만들어질 때마다 호출됩니다. <em>cls</em> 는 새 서브 클래스입니다. 만약 일반적인 인스턴스 메서드로 정의되면, 이 메서드는 묵시적으로 클래스 메서드로 변경됩니다.</p>
<p>새 클래스에 주어진 키워드 인자들은 부모 클래스의 <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달됩니다. <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 를 사용하는 다른 클래스들과의 호환성을 위해, 필요한 키워드 인자들을 꺼낸 후에 다른 것들을 베이스 클래스로 전달해야 합니다. 이런 식입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>기본 구현 <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> 는 아무 일도 하지 않지만, 인자가 포함되어 호출되면 예외를 발생시킵니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>메타 클래스 힌트 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 는 나머지 형 절차에 의해 소비되고, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달되지 않습니다. 실제 메타 클래스 (명시적인 힌트 대신에) 는 <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code> 로 액세스할 수 있습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<div class="section" id="metaclasses">
<span id="id4"></span><h4><span class="section-number">3.3.3.1. </span>메타 클래스<a class="headerlink" href="#metaclasses" title="제목 주소">¶</a></h4>
<p id="index-83">기본적으로, 클래스는 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 을 사용해서 만들어집니다. 클래스의 바디는 새 이름 공간에서 실행되고, 클래스 이름은 <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> 의 결과에 지역적으로 연결됩니다.</p>
<p>클래스를 만드는 과정은 클래스 정의 줄에 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 키워드 인자를 전달하거나, 그런 인자를 포함한 이미 존재하는 클래스를 계승함으로써 커스터마이즈될 수 있습니다. 다음 예에서, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 와 <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> 는 모두 <code class="docutils literal notranslate"><span class="pre">Meta</span></code> 의 인스턴스입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타 클래스 연산들로 전달됩니다.</p>
<p>클래스 정의가 실행될 때, 다음과 같은 단계가 수행됩니다.:</p>
<ul class="simple">
<li><p>MRO 항목이 결정됩니다;</p></li>
<li><p>적절한 메타 클래스가 결정됩니다;</p></li>
<li><p>클래스 이름 공간이 준비됩니다;</p></li>
<li><p>클래스 바디가 실행됩니다;</p></li>
<li><p>클래스 객체가 만들어집니다.</p></li>
</ul>
</div>
<div class="section" id="resolving-mro-entries">
<h4><span class="section-number">3.3.3.2. </span>MRO 항목 결정하기<a class="headerlink" href="#resolving-mro-entries" title="제목 주소">¶</a></h4>
<p>클래스 정의에 나타나는 베이스 클래스가 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 의 인스턴스가 아닌 경우, 거기에서 <code class="docutils literal notranslate"><span class="pre">__mro_entries__</span></code> 메서드를 검색합니다. 발견되면, 원래의 베이스 튜플로 호출됩니다. 이 메서드는 이 베이스 대신에 사용될 클래스의 튜플을 돌려줘야 합니다. 튜플은 비어있을 수 있습니다. 이 경우 원래 베이스는 무시됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-121"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - typing 모듈과 제네릭 형에 대한 코어 지원</p>
</div>
</div>
<div class="section" id="determining-the-appropriate-metaclass">
<span id="flowdas-determining-the-appropriate-metaclass"></span><h4><span class="section-number">3.3.3.3. </span>적절한 메타 클래스 선택하기<a class="headerlink" href="#determining-the-appropriate-metaclass" title="제목 주소">¶</a></h4>
<p id="index-85">클래스 정의의 적절한 메타 클래스는 다음과 같이 결정됩니다:</p>
<ul class="simple">
<li><p>베이스와 명시적인 메타 클래스를 주지 않는 경우 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 이 사용됩니다;</p></li>
<li><p>명시적인 메타 클래스가 지정되고, 그것이 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 <em>아니면</em>, 그것을 메타 클래스로 사용합니다;</p></li>
<li><p><a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 명시적인 메타 클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타 클래스가 사용됩니다.</p></li>
</ul>
<p>가장 많이 파생된 메타 클래스는 명시적으로 지정된 메타 클래스(있다면)와 지정된 모든 베이스 클래스들의 메타 클래스들(즉, <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) 중에서 선택됩니다. 가장 많이 파생된 메타 클래스는 이들 <em>모두</em> 의 서브 타입(subtype)입니다. 만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> 를 발생시키며 실패합니다.</p>
</div>
<div class="section" id="preparing-the-class-namespace">
<span id="prepare"></span><h4><span class="section-number">3.3.3.4. </span>클래스 이름 공간 준비하기<a class="headerlink" href="#preparing-the-class-namespace" title="제목 주소">¶</a></h4>
<p id="index-86">일단 적절한 메타 클래스가 식별되면, 클래스 이름 공간이 준비됩니다. 만약 메타 클래스가 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 어트리뷰트를 가지면, <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> 같은 식으로 호출됩니다(추가적인 키워드 인자가 있다면 클래스 정의에서 온 것입니다). <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 메서드는 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>로 구현되어야 합니다.</p>
<p>만약 메타 클래스에 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 어트리뷰트가 없다면, 클래스 이름 공간은 빈 순서 있는 매핑(ordered mapping) 으로 초기화됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-122"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - 파이썬 3000 에서의 메타 클래스</dt><dd><p><code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 이름 공간 훅을 도입했습니다</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="executing-the-class-body">
<h4><span class="section-number">3.3.3.5. </span>클래스 바디 실행하기<a class="headerlink" href="#executing-the-class-body" title="제목 주소">¶</a></h4>
<p id="index-88">클래스 바디는 (대략) <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> 과같이 실행됩니다. 일반적인 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 호출과 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 어휘 스코핑(lexical scoping) 이 클래스 바디(모든 메서드들을 포함해서)로 하여금 현재와 외부 스코프에 있는 이름들을 참조하도록 허락한다는 것입니다.</p>
<p>하지만, 클래스 정의가 함수 내부에서 이루어질 때조차도, 클래스 내부에서 정의된 메서드들은 클래스 스코프에서 정의된 이름들을 볼 수 없습니다. 클래스 변수는 인스턴스나 클래스 메서드의 첫 번째 매개변수를 통해 액세스하거나 다음 섹션에서 설명하는 묵시적으로 어휘 스코핑된 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 참조를 통해야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>메서드에서 클래스 어트리뷰트를 직접 참조할 수 없다는 뜻입니다. 하지만 <em>self</em>, <em>cls</em>,
<code class="docutils literal notranslate"><span class="pre">__class__</span></code> 를 통하는 것 외에도, 클래스 객체에 대한 직접적인 참조를 통해 접근할 수 있습니다.
예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;type(self) is&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;__class__ is&#39;</span><span class="p">,</span> <span class="vm">__class__</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X is&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cls is&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;__class__ is&#39;</span><span class="p">,</span> <span class="vm">__class__</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X is&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;__class__ is&#39;</span><span class="p">,</span> <span class="vm">__class__</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X is&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>클래스 <code class="docutils literal notranslate"><span class="pre">X</span></code> 에 대한 직접적인 참조는, 클래스 정의가 함수 내부에서 이루어져도 가능한데, 메서드가
함수의 자유 변수들을 볼 수 있다는 규칙 때문입니다. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 의 주 용도는, <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>
에 인자를 주지 않을 경우(즉 <code class="docutils literal notranslate"><span class="pre">super()</span></code> 라고 쓸 경우), 현재 메서드가 정의된 클래스를 찾는 것입니다.
이 때문에 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 는 <code class="docutils literal notranslate"><span class="pre">type(self)</span></code> 나 <em>cls</em> 보다는 <code class="docutils literal notranslate"><span class="pre">X</span></code> 를 사용할 때 처럼
동작합니다. 가령:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span><span class="p">()</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="go">type(self) is Y</span>
<span class="go">__class__ is X</span>
<span class="go">X is X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
<span class="go">cls is Y</span>
<span class="go">__class__ is X</span>
<span class="go">X is X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="go">__class__ is X</span>
<span class="go">X is X</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="creating-the-class-object">
<span id="class-object-creation"></span><h4><span class="section-number">3.3.3.6. </span>클래스 객체 만들기<a class="headerlink" href="#creating-the-class-object" title="제목 주소">¶</a></h4>
<p id="index-89">일단 클래스 이름 공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> 을 통해 만들어집니다(여기에서 전달되는 추가적인 키워드 인자들은 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 에 전달된 것들과 같습니다).</p>
<p>이 클래스 객체는 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 에 인자를 주지 않는 경우 참조되는 것입니다. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 는 클래스 바디의 메서드들 중 어느 하나라도 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 나 <code class="docutils literal notranslate"><span class="pre">super</span></code> 를 참조할 경우 컴파일러에 의해 만들어지는 묵시적인 클로저(closure) 참조입니다. 이것은 인자 없는 형태의 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 가 어휘 스코핑 기반으로 현재 정의되고 있는 클래스를 올바르게 찾을 수 있도록 합니다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메서드로 전달된 첫 번째 인자에 기초해서 식별됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 3.6 이상에서, <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 셀(cell)은 클래스 이름 공간의 <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> 엔트리로 메타 클래스에 전달됩니다. 만약 존재한다면, 이것은 클래스가 올바르게 초기화되기 위해 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 호출까지 거슬러서 전파되어야 합니다. 이렇게 하지 못하면 파이썬 3.8 에서는 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>로 이어질 것입니다.</p>
</div>
<p>기본 메타 클래스 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 을 사용할 때나 다른 메타 클래스가 결국 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 를 호출할 때, 클래스 객체를 만든 후에, 다음과 같은 추가의 커스터마이제이션 단계가 실행됩니다:</p>
<ul class="simple">
<li><p>첫째로, <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 는 <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> 을 정의하는 클래스 이름 공간의 모든 디스크립터들을 수집합니다;</p></li>
<li><p>둘째로, 이렇게 수집된 모든 <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> 을 호출하는데, 정의되고 있는 클래스와 디스크립터에 주어진 이름을 인자로 전달합니다;</p></li>
<li><p>마지막으로, 메서드 결정 순서에 따라 가장 가까운 부모에 대해 <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> 훅이 호출됩니다.</p></li>
</ul>
<p>클래스 객체가 만들어진 후에, 클래스 정의에 포함된 클래스 데코레이터들에게 (있다면) 클래스를 전달하고, 그 결과를 클래스가 정의되는 지역 이름 공간에 연결합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 로 새 클래스가 만들어질 때, 이름 공간 매개변수로 제공되는 객체는 새로 만든 순서 있는 매핑으로 복사되고, 원래의 객체는 버립니다. 새 사본은 읽기 전용 프락시(read-only proxy)로 둘러싸이는데, 이것이 클래스 객체의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트가 됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-123"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - 새 super</dt><dd><p>묵시적인 __class__ 클로저 참조를 설명합니다</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="uses-for-metaclasses">
<h4><span class="section-number">3.3.3.7. </span>메타 클래스의 용도<a class="headerlink" href="#uses-for-metaclasses" title="제목 주소">¶</a></h4>
<p>메타 클래스의 잠재적인 용도에는 한계가 없습니다. 탐색 된 몇 가지 아이디어들에는 enum, 로깅, 인터페이스 검사, 자동화된 위임(automatic delegation), 자동화된 프로퍼티(properety) 생성, 프락시(proxy), 프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource locking/synchronization) 등이 있습니다.</p>
</div>
</div>
<div class="section" id="customizing-instance-and-subclass-checks">
<h3><span class="section-number">3.3.4. </span>인스턴스 및 서브 클래스 검사 커스터마이제이션<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="제목 주소">¶</a></h3>
<p>다음 메서드들은 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 내장 함수들의 기본 동작을 재정의하는 데 사용됩니다.</p>
<p>특히, 메타 클래스 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> 는 추상 베이스 클래스(Abstract Base Class, ABC)를 다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함합니다)에 &quot;가상 베이스 클래스(virtual base class)&quot;로 추가할 수 있게 하려고 이 메서드들을 구현합니다.</p>
<dl class="method">
<dt id="class.__instancecheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__instancecheck__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="정의 주소">¶</a></dt>
<dd><p><em>instance</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 인스턴스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasscheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__subclasscheck__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="정의 주소">¶</a></dt>
<dd><p><em>subclass</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 서브 클래스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출됩니다.</p>
</dd></dl>

<p>이 메서드들은 클래스의 형(메타 클래스)에서 조회된다는 것에 주의해야 합니다. 실제 클래스에서 클래스 메서드로 정의될 수 없습니다. 이것은 인스턴스에 대해 호출되는 특수 메서드들의 조회와 일관성 있습니다. 이 경우 인스턴스는 클래스 자체다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-124"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 추상 베이스 클래스의 도입</dt><dd><p><a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> 와 <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a> 를 통해 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 의 동작을 커스터마이징하는 데 필요한 규약을 포함하는데, 이 기능의 동기는 언어에 추상 베이스 클래스 (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 모듈을 보십시오)를 추가하고자 하는 데 있습니다.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="emulating-generic-types">
<h3><span class="section-number">3.3.5. </span>제네릭 형 흉내 내기<a class="headerlink" href="#emulating-generic-types" title="제목 주소">¶</a></h3>
<p>특수 메서드를 정의함으로써 <span class="target" id="index-125"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>에서 지정된 제네릭 클래스 문법(예를 들면 <code class="docutils literal notranslate"><span class="pre">List[int]</span></code>)을 구현할 수 있습니다:</p>
<dl class="method">
<dt id="object.__class_getitem__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__class_getitem__</code><span class="sig-paren">(</span><em class="sig-param">cls</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="정의 주소">¶</a></dt>
<dd><p><em>key</em> 에 있는 형 인자에 의한 제네릭 클래스의 특수화를 나타내는 객체를 돌려줍니다.</p>
</dd></dl>

<p>이 메서드는 클래스 개체 자체에서 조회되며, 클래스 바디에 정의된 경우, 이 메서드는 묵시적으로 클래스 메서드입니다. 이 메커니즘은 주로 정적 형 힌트와 함께 사용하기 위해 예약되어 있습니다. 다른 용도는 권장하지 않습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-126"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - typing 모듈과 제네릭 형에 대한 코어 지원</p>
</div>
</div>
<div class="section" id="emulating-callable-objects">
<span id="callable-types"></span><h3><span class="section-number">3.3.6. </span>콜러블 객체 흉내 내기<a class="headerlink" href="#emulating-callable-objects" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="object.__call__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="정의 주소">¶</a></dt>
<dd><p id="index-94">인스턴스가 함수처럼 &quot;호출될&quot; 때 호출됩니다; 이 메서드가 정의되면, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 의 줄인 표현입니다.</p>
</dd></dl>

</div>
<div class="section" id="emulating-container-types">
<span id="sequence-types"></span><h3><span class="section-number">3.3.7. </span>컨테이너형 흉내 내기<a class="headerlink" href="#emulating-container-types" title="제목 주소">¶</a></h3>
<p>컨테이너 객체를 구현하기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 컨테이너는 보통 시퀀스(리스트와 튜플 같은)나 매핑(딕셔너리 같은)이지만, 다른 컨테이너들 역시 표현할 수 있습니다. 첫 번째 메서드 집합은 시퀀스나 매핑을 흉내 내는 데 사용됩니다; 차이점은, 시퀀스의 경우 허락되는 키는 <em>N</em> 이 시퀀스의 길이일 때 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> 를 만족하는 정수 <em>k</em> 와 항목들의 범위를 정의하는 슬라이스 객체만 허락된다는 것입니다. 파이썬의 표준 딕셔너리 객체와 비슷하게 동작하도록, 매핑에 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 를 제공하는 것이 좋습니다. <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 모듈은 <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> 추상 베이스 클래스를 제공하는데, 기본 집합 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> 로 부터 이들 메서드들을 만드는 데 도움을 줍니다. 파이썬의 표준 리스트 객체처럼, 가변 시퀀스는 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 를 제공해야 합니다. 마지막으로 시퀀스 형은 아래에서 설명하는 메서드 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a>, <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a> 를 정의해서 더하기(이어붙이기를 뜻합니다)와 곱하기(반복을 뜻합니다)를 구현해야 합니다. 다른 숫자 연산자들은 정의하지 말아야 합니다. <code class="docutils literal notranslate"><span class="pre">in</span></code> 연산자의 효과적인 사용을 허락하기 위해, 매핑과 시퀀스 모두 <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 메서드를 구현하도록 권장합니다. 매핑의 경우, <code class="docutils literal notranslate"><span class="pre">in</span></code> 은 매핑의 키를 검색해야 합니다; 시퀀스의 경우, 값들을 검색해야 합니다. 컨테이너의 효율적인 이터레이션을 허락하기 위해, 매핑과 시퀀스 모두 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 메서드를 구현하는 것 또한 권장합니다; 매핑의 경우, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 는 객체의 키를 이터레이트 해야 합니다; 시퀀스의 경우, 값들을 이터레이트해야 합니다.</p>
<dl class="method">
<dt id="object.__len__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="정의 주소">¶</a></dt>
<dd><p id="index-95">내장함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 를 구현하기 위해 호출됩니다. 객체의 길이를 돌려줘야 하는데, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0인 정수입니다. 또한 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 메서드를 정의하지 않은 객체의 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 이 0을 돌려주면 논리 문맥에서 거짓으로 취급됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 에서, 길이는 최대 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 일 것이 요구됩니다. 만약 길이가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code> 보다 크면, 어떤 기능들 (<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 과 같은)은 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 를 일으킬 수 있습니다. 참 거짓 검사에서 <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> 가 일어나는 것을 막기 위해, 객체는 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 를 정의해야 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__length_hint__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__length_hint__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a> 를 구현하기 위해 호출됩니다. 객체의 추정된 길이를 돌려줘야 합니다(실제 길이보다 크거나 작을 수 있습니다). 길이는 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0인 정수여야 합니다. 반환 값은 <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-const docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> 일 수도 있으며, <code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> 메서드가 아예 존재하지 않는 것처럼 처리됩니다. 이 메서드는 순수하게 최적화를 위한 것이고 결코 올바름이 요구되지는 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-96">
<p class="admonition-title">참고</p>
<p>슬라이싱은 전적으로 다음에 나오는 세 메서드들에의해 수행됩니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>과 같은 호출은</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>로 번역되고, 다른 형태도 마찬가지입니다. 빠진 슬라이스 항목은 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 채워집니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>&quot;다음에 나오는 세 메서드들&quot; 은 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>,
<a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a> 를 의미합니다.</p>
</div>
</div>
<dl class="method">
<dt id="object.__getitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 의 값을 구하기 위해 호출됩니다. 시퀀스형의 경우, 정수와 슬라이스 객체만 키로 허용됩니다. 음수 인덱스(만약 클래스가 시퀀스 형을 흉내 내길 원한다면)의 특별한 해석은 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드에 달려있음에 주의해야 합니다. 만약 <em>key</em> 가 적절하지 않은 형인 경우, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생할 수 있습니다; 만약 시퀀스의 인덱스 범위를 벗어나면(음수에 대한 특별한 해석 후에), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 를 일으켜야 합니다. 매핑 형의 경우, <em>key</em> 가 (컨테이너에) 없으면, <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 를 일으켜야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프는 시퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 가 일어날 것으로 기대하고 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프는, 객체가 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 정의하지 않을 경우, 0 부터 시작해서
하나씩 증가하는 정수를 사용해서 차례대로 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 호출합니다.
<a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 가 발생할 때까지 이 과정을 계속 진행합니다. 이 때 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>
는 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프의 종료 신호로 사용될 뿐, 루프 바깥으로 확산되지 않습니다.</p>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 로의 대입을 구현하기 위해 호출됩니다. <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요합니다. 매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 경우는 항목이 교체될 수 있을 때만 구현되어야 합니다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 의 삭제를 구현하기 위해 호출됩니다. <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요합니다. 매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 제거될 수 있을 때만 구현되어야 합니다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__missing__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__missing__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 이 dict 서브 클래스에서 키가 딕셔너리에 없으면 <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 를 구현하기 위해 호출합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 가 이 메서드를 미리 정의하고 있지는 않습니다. 서브 클래스가 정의한다면 호출한다는 뜻입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="정의 주소">¶</a></dt>
<dd><p>컨테이너의 이터레이터가 필요할 때 이 메서드가 호출됩니다. 이 메서드는 컨테이너에 포함된 모든 객체를 이터레이트할 수 있는 이터레이터 객체를 돌려줘야 합니다. 매핑의 경우, 컨테이너의 키를 이터레이트해야 합니다.</p>
<p>이터레이터 객체 역시 이 메서드를 구현할 필요가 있습니다; 자기 자신을 돌려줘야 합니다. 이터레이터 객체에 대한 추가의 정보는 <a class="reference internal" href="../library/stdtypes.html#typeiter"><span class="std std-ref">이터레이터 형</span></a> 에 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__reversed__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__reversed__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장 함수가 역 이터레이션(reverse iteration)을 구현하기 위해 (있다면) 호출합니다. 컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 합니다.</p>
<p><a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 메서드가 제공되지 않으면, <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장함수는 시퀀스 프로토콜(<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>)을 대안으로 사용합니다. 시퀀스 프로토콜을 지원하는 객체들은 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 가 제공하는 것보다 더 효율적인 구현을 제공할 수 있을 때만 <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 를 제공해야 합니다.</p>
</dd></dl>

<p>멤버십 검사 연산자들(<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) 은 보통 컨테이너에 대한 이터레이션으로 구현됩니다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 특수 메서드를 통해 제공할 수 있습니다. 이 경우 객체는 이터러블일 필요도 없습니다.</p>
<dl class="method">
<dt id="object.__contains__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="정의 주소">¶</a></dt>
<dd><p>멤버십 검사 연산자를 구현하기 위해 호출됩니다. <em>item</em> 이 <em>self</em> 에 있으면 참을, 그렇지 않으면 거짓을 돌려줘야 합니다. 매핑 객체의 경우, 키-값 쌍이 아니라 매핑의 키가 고려되어야 합니다.</p>
<p><a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 를 정의하지 않는 객체의 경우, 멤버십 검사는 먼저 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 통한 이터레이션을 시도한 후, <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 통한 낡은 시퀀스 이터레이션 프로토콜을 시도합니다. <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">언어 레퍼런스의 이 절</span></a>을 참고하십시오.</p>
</dd></dl>

</div>
<div class="section" id="emulating-numeric-types">
<span id="numeric-types"></span><h3><span class="section-number">3.3.8. </span>숫자 형 흉내 내기<a class="headerlink" href="#emulating-numeric-types" title="제목 주소">¶</a></h3>
<p>숫자 형을 흉내 내기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 구현되는 특별한 종류의 숫자에 의해 지원되지 않는 연산들(예를 들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메서드들을 정의되지 않은 채로 남겨두어야 합니다.</p>
<dl class="method">
<dt id="object.__add__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="정의 주소">¶</a></dt>
<dt id="object.__sub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="정의 주소">¶</a></dt>
<dt id="object.__mul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="정의 주소">¶</a></dt>
<dt id="object.__matmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__matmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="정의 주소">¶</a></dt>
<dt id="object.__truediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__truediv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="정의 주소">¶</a></dt>
<dt id="object.__floordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floordiv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="정의 주소">¶</a></dt>
<dt id="object.__mod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="정의 주소">¶</a></dt>
<dt id="object.__divmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__divmod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="정의 주소">¶</a></dt>
<dt id="object.__pow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="정의 주소">¶</a></dt>
<dt id="object.__lshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="정의 주소">¶</a></dt>
<dt id="object.__rshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="정의 주소">¶</a></dt>
<dt id="object.__and__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__and__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="정의 주소">¶</a></dt>
<dt id="object.__xor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__xor__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="정의 주소">¶</a></dt>
<dt id="object.__or__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__or__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="정의 주소">¶</a></dt>
<dd><p id="index-97">이 메서드들은 이항 산술 연산들(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>)을 구현하기 위해 호출됩니다. 예를 들어, <em>x</em> 가 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 메서드를 가진 클래스의 인스턴스일 때, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 의 값을 구하기 위해, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 가 호출됩니다. <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> 메서드는 <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> 와 <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> 를 사용하는 것과 동등해야 합니다; <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> 와 연관되지 않아야 합니다; 내장 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 함수의 삼 항 버전이 지원되기 위해서는, <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> 메서드가 생략할 수 있는 세 번째 인자를 받도록 정의되어야 함에 주의해야 합니다.</p>
<p>만약 이 메서드들 중 하나가 제공된 인자에 대해 연산을 지원하지 않으면, <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줘야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__radd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__radd__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="정의 주소">¶</a></dt>
<dt id="object.__rsub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rsub__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="정의 주소">¶</a></dt>
<dt id="object.__rmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="정의 주소">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmatmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="정의 주소">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rtruediv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="정의 주소">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rfloordiv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="정의 주소">¶</a></dt>
<dt id="object.__rmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="정의 주소">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rdivmod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="정의 주소">¶</a></dt>
<dt id="object.__rpow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rpow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="정의 주소">¶</a></dt>
<dt id="object.__rlshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rlshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="정의 주소">¶</a></dt>
<dt id="object.__rrshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rrshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="정의 주소">¶</a></dt>
<dt id="object.__rand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rand__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="정의 주소">¶</a></dt>
<dt id="object.__rxor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rxor__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="정의 주소">¶</a></dt>
<dt id="object.__ror__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ror__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="정의 주소">¶</a></dt>
<dd><p id="index-98">이 메서드들은 뒤집힌 피연산자들에 대해 이항 산술 연산들(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>)을 구현하기 위해 호출됩니다. 이 함수들은 왼쪽의 피연산자가 해당 연산을 지원하지 않고 <a class="footnote-reference brackets" href="#id10" id="id5">3</a>, 피연산자들이 서로 다른 형일 때만 호출됩니다. <a class="footnote-reference brackets" href="#id11" id="id6">4</a> 예를 들어, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> 의 값을 구하려고 할 때, <em>y</em> 가 <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a> 를 갖는 클래스의 인스턴스이고, <code class="docutils literal notranslate"><span class="pre">x.__sub__(y)</span></code> 가 <em>NotImplemented</em> 를 돌려주면 <code class="docutils literal notranslate"><span class="pre">y.__rsub__(x)</span></code> 가 호출됩니다.</p>
<p id="index-99">삼 항 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 는 <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> 를 호출하려고 시도하지 않음에 주의해야 합니다 (그렇게 하려면 코어션 규칙이 너무 복잡해집니다).</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브 클래스이고, 그 서브 클래스가 연산의 뒤집힌 메서드들 제공하면, 이 메서드가 왼쪽 연산자의 뒤집히지 않은 메서드보다 먼저 호출됩니다. 이 동작은 서브 클래스가 조상들의 연산을 재정의할 수 있도록 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iadd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iadd__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="정의 주소">¶</a></dt>
<dt id="object.__isub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__isub__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="정의 주소">¶</a></dt>
<dt id="object.__imul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="정의 주소">¶</a></dt>
<dt id="object.__imatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imatmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="정의 주소">¶</a></dt>
<dt id="object.__itruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__itruediv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="정의 주소">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ifloordiv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="정의 주소">¶</a></dt>
<dt id="object.__imod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="정의 주소">¶</a></dt>
<dt id="object.__ipow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ipow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="정의 주소">¶</a></dt>
<dt id="object.__ilshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ilshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="정의 주소">¶</a></dt>
<dt id="object.__irshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__irshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="정의 주소">¶</a></dt>
<dt id="object.__iand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iand__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="정의 주소">¶</a></dt>
<dt id="object.__ixor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ixor__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="정의 주소">¶</a></dt>
<dt id="object.__ior__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ior__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="정의 주소">¶</a></dt>
<dd><p>이 메서드들은 증분 산술 대입(<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>)을 구현하기 위해 호출됩니다. 이 메서드는 연산을 제자리에서(<em>self</em> 를 수정해서) 하도록 시도해야 하고, 결과(반드시 그래야 하는 것은 아니지만 <em>self</em> 일 수 있습니다)를 돌려줘야 합니다. 만약 특정 메서드가 정의되지 않으면, 중분 대입은 일반적인 메서드들을 대신 사용합니다. 예를 들어, <em>x</em> 가 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> 메서드를 갖는 클래스의 인스턴스면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> 와 동등합니다. 그렇지 않으면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 의 값을 구할 때처럼, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> 가 고려됩니다. 어떤 상황에서, 증분 대입은 예상치 못한 에러로 이어질 수 있습니다. (<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">덧셈은 작동하는데, 왜 a_tuple[i] += ['item']이 예외를 일으킵니까?</span></a> 를 보십시오). 하지만 이 동작은 사실 데이터 모델의 일부입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">덧셈은 작동하는데, 왜 a_tuple[i] += ['item']이 예외를 일으킵니까?</span></a> 는 이런 상황을 예시하고 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>이 에러는 <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span> <span class="pre">+=</span> <span class="pre">['item']</span></code> 을 동등한 표현인
<code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span> <span class="pre">=</span> <span class="pre">a_tuple[0].__iadd__(['item'])</span></code> 로 풀어 써 보면 당연한 결과입니다.
대입문의 우변을 계산하는데는 문제가 없지만, 튜플의 항목에 대입하려는 순간 에러가 발생합니다.
이 사실 자체는 튜플이 불변객체이기 때문에 이상할 것이 없습니다.</p>
<p>하지만 진짜 문제는 증분 대입문이 원자적이지 않다는 사실입니다. 원자적이지 않다는 것은 오류가
발생해서 실패했음에도 불구하고, 실행 전과 비교할 때 뭔가 달라졌다는 뜻입니다. 우변의 표현은
성공하는데, 이 때 실행된 것은 <code class="docutils literal notranslate"><span class="pre">list.__iadd__()</span></code> 입니다. 이 메서드는 자기 자신을 변경한
후에 <code class="docutils literal notranslate"><span class="pre">self</span></code> 를 돌려줍니다. 그 결과, 비록 튜플을 변경하려는 시도는 실패하지만, 이미 튜플안에
들어있던 리스트는 변경된 상태로 남게 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span>
<span class="go">([&#39;foo&#39;, &#39;item&#39;], &#39;bar&#39;)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__neg__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__neg__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="정의 주소">¶</a></dt>
<dt id="object.__pos__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pos__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="정의 주소">¶</a></dt>
<dt id="object.__abs__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__abs__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="정의 주소">¶</a></dt>
<dt id="object.__invert__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__invert__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="정의 주소">¶</a></dt>
<dd><p id="index-100">일 항 산술 연산(<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">~</span></code>)을 구현하기 위해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__complex__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__complex__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="정의 주소">¶</a></dt>
<dt id="object.__int__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__int__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="정의 주소">¶</a></dt>
<dt id="object.__float__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__float__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="정의 주소">¶</a></dt>
<dd><p id="index-101">내장 함수 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>를 구현하기 위해 호출됩니다. 적절한 형의 값을 돌려줘야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__index__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__index__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a> 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 없이 변환해야 할 때(슬라이싱이나 내장 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a>, <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 함수들에서와같이)마다 호출됩니다. 이 메서드의 존재는 숫자 객체가 정수 형임을 가리킵니다. 반드시 정수를 돌려줘야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>가령 <code class="docutils literal notranslate"><span class="pre">x[y:]</span></code> 라는 표현이 있을 때 <code class="docutils literal notranslate"><span class="pre">y</span></code> 가 정수형이 아니면
<code class="docutils literal notranslate"><span class="pre">x[y.__index__():]</span></code> 와 같은 표현으로 변환된다는 뜻입니다.</p>
</div>
<p><a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 및 <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a>가 정의되어 있지 않으면, 해당 내장 함수 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 및 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>는 <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__round__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__round__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="정의 주소">¶</a></dt>
<dt id="object.__trunc__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__trunc__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="정의 주소">¶</a></dt>
<dt id="object.__floor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floor__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="정의 주소">¶</a></dt>
<dt id="object.__ceil__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ceil__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="정의 주소">¶</a></dt>
<dd><p id="index-102">내장 함수 <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>와 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 함수 <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>, <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> 을 구현하기 위해 호출됩니다. <em>ndigits</em> 가 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> 로 전달되지 않는 한, 이 메서드들은 모두 <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (보통 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) 로 잘린 객체의 값을 돌려줘야 합니다.</p>
<p><a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 가 정의되어 있지 않으면, 내장 함수 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 는 <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> 를 사용합니다.</p>
</dd></dl>

</div>
<div class="section" id="with-statement-context-managers">
<span id="context-managers"></span><h3><span class="section-number">3.3.9. </span>with 문 컨텍스트 관리자<a class="headerlink" href="#with-statement-context-managers" title="제목 주소">¶</a></h3>
<p><em class="dfn">컨텍스트 관리자 (context manager)</em> 는 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 실행할 때 자리 잡는 실행 컨텍스트(context)를 정의하는 객체입니다. 코드 블록의 실행을 위해, 컨텍스트 관리자는 원하는 실행시간 컨텍스트로의 진입과 탈출을 처리합니다. 컨텍스트 관리자는 보통 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문(<a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 문</span></a> 섹션에서 설명합니다)으로 시작되지만, 그들의 메서드를 호출해서 직접 사용할 수도 있습니다.</p>
<p id="index-103">컨텍스트 관리자의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 복구하는 것, 자원을 로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것 등이 있습니다.</p>
<p>컨텍스트 관리자에 대한 더 자세한 정보는 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">컨텍스트 관리자 형</span></a> 에 나옵니다.</p>
<dl class="method">
<dt id="object.__enter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="정의 주소">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트에 진입합니다. <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 절로 지정된 대상이 있다면, 이 메서드의 반환 값을 연결합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__exit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">exc_type</em>, <em class="sig-param">exc_value</em>, <em class="sig-param">traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="정의 주소">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트를 종료합니다. 매개변수들은 컨텍스트에서 벗어나게 만든 예외를 기술합니다. 만약 컨텍스트가 예외 없이 종료한다면, 세 인자 모두 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 됩니다.</p>
<p>만약 예외가 제공되고, 메서드가 예외를 중지시키고 싶으면 (즉 확산하는 것을 막으려면) 참(true)을 돌려줘야 합니다. 그렇지 않으면 예외는 이 메서드가 종료한 후에 계속 진행됩니다.</p>
<p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드가 전달된 예외를 다시 일으키지(reraise) 않도록 주의해야 합니다; 이것은 호출자(caller)의 책임입니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-127"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; 문</dt><dd><p>파이썬 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 대한 규격, 배경, 예.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="special-method-lookup">
<span id="special-lookup"></span><h3><span class="section-number">3.3.10. </span>특수 메서드 조회<a class="headerlink" href="#special-method-lookup" title="제목 주소">¶</a></h3>
<p>사용자 정의 클래스의 경우, 묵시적인 특수 메서드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 형에 정의되어 있을 때만 올바르게 동작함이 보장됩니다. 이런 동작은 다음과 같은 코드가 예외를 일으키는 원인입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>이런 동작의 배경에 깔린 논리는, 모든 객체(형 객체를 포함해서)에 의해 구현되는 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 나 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 과 같은 많은 특수 메서드들과 관련이 있습니다. 만약 이 메서드들에 대한 묵시적인 조회가 일반적인 조회 프로세스를 거친다면, 형 객체 자체에 대해 호출되었을 때 실패하게 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>구문 분석 단계를 무사히 통과하기 위해서, 숫자 리터럴 <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">.</span></code> 사이에 공백이 삽입되었습니다.
그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">.</span></code> 이 숫자 리터럴의 일부로 판단되어 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 가 발생합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><code class="docutils literal notranslate"><span class="pre">int.__hash__()</span></code> 는 클래스 메서드가 아닌 일반 메서드입니다. 따라서 일반적인 메서드 호출 규칙을
따르고, <code class="docutils literal notranslate"><span class="pre">self</span></code> 에 해당하는 인자를 필요로 합니다. 이렇게 모든 객체에 공통적으로 적용되는 메서드들은,
한가지 유형을 공유해야 하기 때문에, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">.__hash__()</span></code> 에서는 일반 메서드 호출 규칙을 따르고,
<code class="docutils literal notranslate"><span class="pre">int.__hash__()</span></code> 에서는 클래스 메서드 호출 규칙을 따르는 식으로 처리하려면, 메서드 호출 규칙이
너무 복잡해집니다. 때문에 메서드 호출 규칙은 손대지 않고 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 가 항상 대상 객체의 형에 정의된
<code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> 를 사용하는 것으로 딜레마를 해결합니다. 따라서 <code class="docutils literal notranslate"><span class="pre">hash(1)</span></code> 은 <code class="docutils literal notranslate"><span class="pre">int.__hash__()</span></code>
를 사용하고, <code class="docutils literal notranslate"><span class="pre">hash(int)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">type.__hash__()</span></code> 를 사용합니다.
(<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 은 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 형의 메타클래스입니다.)</p>
</div>
<p>클래스의 연결되지 않은 메서드를 호출하려는 이런 식의 잘못된 시도는 종종 '메타 클래스 혼란(metaclass confusion)' 이라고 불리고, 특수 메서드를 조회할 때 인스턴스를 우회하는 방법으로 피할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>올바름을 추구하기 위해 인스턴스 어트리뷰트들을 우회하는 것에 더해, 묵시적인 특수 메서드 조회는 객체의 메타 클래스의 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 메서드 조차도 우회합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>이런 식으로 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 절차를 우회하는 것은 특수 메서드 처리의 유연함을 일부 포기하는 대신(특수 메서드가 인터프리터에 의해 일관성 있게 호출되기 위해서는 <em>반드시</em> 클래스 객체에 설정되어야 합니다), 인터프리터 내부에서의 속도 최적화를 위한 상당한 기회를 제공합니다.</p>
</div>
</div>
<div class="section" id="coroutines">
<span id="index-105"></span><h2><span class="section-number">3.4. </span>코루틴(Coroutines)<a class="headerlink" href="#coroutines" title="제목 주소">¶</a></h2>
<div class="section" id="awaitable-objects">
<h3><span class="section-number">3.4.1. </span>어웨이터블 객체(Awaitable Objects)<a class="headerlink" href="#awaitable-objects" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체는 일반적으로 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 메서드를 구현합니다. <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수가 돌려주는 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체는 어웨이터블입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>어웨이터블 객체란 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식에 사용될 수 있는 객체를 뜻합니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> 이나 <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a> 로 데코레이션된 제너레이터가 돌려주는 <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">제너레이터 이터레이터</span></a> 객체 또한 어웨이터블이지만 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 를 구현하지 않습니다.</p>
</div>
<dl class="method">
<dt id="object.__await__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__await__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 를 돌려줘야 합니다. <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 구현하기 위해 사용되어야 합니다. 예를 들어, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 는 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식과 호환되기 위해 이 메서드를 구현합니다.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-128"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있습니다.</p>
</div>
</div>
<div class="section" id="coroutine-objects">
<span id="id7"></span><h3><span class="section-number">3.4.2. </span>코루틴 객체(Coroutine Objects)<a class="headerlink" href="#coroutine-objects" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체는 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체입니다. 코루틴의 실행은 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 를 호출하고 그 결과를 이터레이트하는 방법으로 제어될 수 있습니다. 코루틴이 실행을 완료하고 복귀할 때, 이터레이터는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으키고, 예외의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> 어트리뷰트가 반환 값을 갖고 있습니다. 만약 코루틴이 예외를 일으키면, 이터레이터에 의해 퍼집니다. 코루틴이 직접 잡히지 않은 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으키지는 말아야 합니다.</p>
<p>코루틴은 다음에 나열하는 메서드들 또한 갖고 있는데, 제너레이터(<a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">제너레이터-이터레이터 메서드</span></a> 를 보십시오)의 것들과 닮았습니다. 하지만, 제너레이터와는 달리, 코루틴은 이터레이션을 직접 지원하지는 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.2에서 변경: </span>코루틴을 두 번 await 하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 를 일으킵니다.</p>
</div>
<dl class="method">
<dt id="coroutine.send">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="정의 주소">¶</a></dt>
<dd><p>코루틴의 실행을 시작하거나 재개합니다. <em>value</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 가 돌려준 이터레이터를 전진시키는 것과 같습니다. <em>value</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 이 메서드는 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드로 위임합니다. 결과(반환 값, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 이나 다른 예외)는 위에서 설명한 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 의 반환 값을 이터레이트할 때와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.throw">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param">type</em><span class="optional">[</span>, <em class="sig-param">value</em><span class="optional">[</span>, <em class="sig-param">traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="정의 주소">¶</a></dt>
<dd><p>코루틴에서 지정한 예외가 발생하도록 합니다. 이 메서드는 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 메서드로 위임합니다(그런 메서드를 가지는 경우). 그렇지 않으면, 일시 중지지점에서 예외가 발생합니다. 결과(반환 값, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 이나 다른 예외)는 위에서 설명한 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 의 반환 값을 이터레이트할 때와 같습니다. 만약 예외가 코루틴에서 잡히지 않는다면 호출자에게 되돌아 전파됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.close">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="정의 주소">¶</a></dt>
<dd><p>코루틴이 자신을 정리하고 종료하도록 만듭니다. 만약 코루틴이 일시 중지 중이면, 이 메서드는 먼저 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드로 위임합니다(그런 메서드를 가지는 경우). 그런 다음 일시 중지지점에서 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 발생시키는데, 코루틴이 즉시 자신을 정리하도록 만듭니다. 마지막으로 코루틴에 실행을 종료했다고 표시하는데, 아직 시작하지조차 않았을 때도 그렇다.</p>
<p>코루틴 객체가 파괴될 때는 위의 프로세스에 따라 자동으로 닫힙니다(closed).</p>
</dd></dl>

</div>
<div class="section" id="asynchronous-iterators">
<span id="async-iterators"></span><h3><span class="section-number">3.4.3. </span>비동기 이터레이터(Asynchronous Iterators)<a class="headerlink" href="#asynchronous-iterators" title="제목 주소">¶</a></h3>
<p><em>비동기 이터레이터</em> 는 자신의 <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 메서드에서 비동기 코드를 호출할 수 있습니다.</p>
<p>비동기 이터레이터는 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용될 수 있습니다.</p>
<dl class="method">
<dt id="object.__aiter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aiter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="정의 주소">¶</a></dt>
<dd><p><em>비동기 이터레이터</em> 객체를 돌려줘야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__anext__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__anext__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="정의 주소">¶</a></dt>
<dd><p>이터레이터의 다음 값을 주는 <em>어웨이터블</em> 을 돌려줘야 합니다. 이터레이션이 끝나면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 에러를 일으켜야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>다음에 나오는 예에서 드러나듯이, <a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 를 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 로 구현하는 경우,
코루틴이 만들어지기 때문에 항상 어웨이터블을 돌려줍니다. 이 경우, 메서드의 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>
문에서 이터레이터의 다음 값을 제공하면 됩니다.</p>
</div>
</dd></dl>

<p>비동기 이터러블 객체의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>파이썬 3.7 이전에, <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 는 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 로 결정될 <em>어웨이터블</em> 을 반환 할 수 있었습니다.</p>
<p>파이썬 3.7부터, <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 는 반드시 비동기 이터레이터 객체를 돌려줘야 합니다. 다른 것을 돌려주면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 에러가 발생합니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>CPython 3.5.0 과 3.5.1 에서만 이 호환성 문제가 발생하는데, 이 버전들에서는 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>
가 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 로 정의되었었습니다.</p>
</div>
</div>
<div class="section" id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3><span class="section-number">3.4.4. </span>비동기 컨텍스트 관리자<a class="headerlink" href="#asynchronous-context-managers" title="제목 주소">¶</a></h3>
<p><em>비동기 컨텍스트 관리자(asynchronous context manager)</em> 는 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> 와 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 메서드에서 실행을 일시 중지할 수 있는 <em>컨텍스트 관리자</em> 입니다.</p>
<p>비동기 컨텍스트 관리자는 <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문에서 사용될 수 있습니다.</p>
<dl class="method">
<dt id="object.__aenter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aenter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드와 의미상으로 유사한데, 유일한 차이점은 <em>어웨이터블</em> 을 돌려줘야 한다는 것입니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__aexit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aexit__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">exc_type</em>, <em class="sig-param">exc_value</em>, <em class="sig-param">traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드와 의미상으로 유사한데, 유일한 차이점은 <em>어웨이터블</em> 을 돌려줘야 한다는 것입니다.</p>
</dd></dl>

<p>비동기 컨텍스트 관리자 클래스의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>어떤 제한된 조건으로, 어떤 경우에 객체의 형을 변경하는 것이 <em>가능합니다</em>. 하지만 잘못 다뤄지면 아주 괴상한 결과로 이어질 수 있으므로 일반적으로 좋은 생각이 아닙니다.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 메서드들이 이런 경우에 대한 특별한 처리를 포함하고 있습니다; 다른 것들도 여전히 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 을 일으키지만, 단지 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 콜러블이 아니므로 그런 것뿐입니다.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>여기서 &quot;지원하지 않는다&quot; 는 클래스가 그런 메서드를 갖지 않거나, 메서드가 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줌을 뜻합니다. 오른쪽 피연산자의 뒤집힌 메서드를 사용하는 대안이 시도되도록 하려면 메서드를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하지 말아야 합니다 - 그렇게 하는 것은 그런 대안을 명시적으로 <em>금지하는</em> 반대 효과를 줍니다.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>피연산자들이 같은 형이면, 뒤집히지 않은 메서드(<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 같은)가 실패하면 그 연산이 지원되지 않는 것으로 간주합니다. 이것이 뒤집힌 메서드가 호출되지 않는 이유입니다.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. 데이터 모델</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. 객체, 값, 형</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 표준형 계층</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. 특수 메서드 이름들</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. 기본적인 커스터마이제이션</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. 어트리뷰트 액세스 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. 모듈 어트리뷰트 액세스 커스터마이제이션</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. 디스크립터 구현하기</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. 디스크립터 호출하기</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. <em>__slots__</em> 사용에 관한 노트</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. 클래스 생성 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. 메타 클래스</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. MRO 항목 결정하기</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. 적절한 메타 클래스 선택하기</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. 클래스 이름 공간 준비하기</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. 클래스 바디 실행하기</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. 클래스 객체 만들기</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. 메타 클래스의 용도</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. 제네릭 형 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. 콜러블 객체 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. 컨테이너형 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. 숫자 형 흉내 내기</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. with 문 컨텍스트 관리자</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.10. 특수 메서드 조회</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. 코루틴(Coroutines)</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. 어웨이터블 객체(Awaitable Objects)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. 코루틴 객체(Coroutine Objects)</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. 비동기 이터레이터(Asynchronous Iterators)</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. 비동기 컨텍스트 관리자</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="이전 장"><span class="section-number">2. </span>어휘 분석</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="다음 장"><span class="section-number">4. </span>실행 모델</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             >다음</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 어휘 분석"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>